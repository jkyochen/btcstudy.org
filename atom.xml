<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BTC Study</title>
  
  <subtitle>学习比特币</subtitle>
  <link href="https://www.btcstudy.org/atom.xml" rel="self"/>
  
  <link href="https://www.btcstudy.org/"/>
  <updated>2024-09-02T04:30:25.037Z</updated>
  <id>https://www.btcstudy.org/</id>
  
  <author>
    <name>btcstudy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多方共享的 UTXO：形式与特性</title>
    <link href="https://www.btcstudy.org/2024/08/30/on-sharing-utxo-forms-and-features/"/>
    <id>https://www.btcstudy.org/2024/08/30/on-sharing-utxo-forms-and-features/</id>
    <published>2024-08-30T09:04:37.000Z</published>
    <updated>2024-09-02T04:30:25.037Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Anony</em></p></blockquote><p>“多方共享的 UTXO（sharing UTXO）”（下文缩写为 “共享 UTXO”），顾名思义，就是让多个用户共享对一个 UTXO 的所有权、让他们的资金寄身于同一个 UTXO 中。这个概念的侧重点不是对权限的管理，而是对内部状态的表达和控制 —— 让多个用户的资金容身于一个 UTXO 中，但依然能保证自主保管，而不会被其它用户侵犯所有权。</p><p>对 “共享 UTXO” 这个概念的关注和开发由来已久。从最广义的角度看，任何超过一方控制 UTXO 的设计，都可算作此类。这个最广义的定义会将 “闪电通道” 这样的两方共享 UTXO 也包含在内。即使我们有意排除这样的两方共享 UTXO，只包含三方及以上共享 UTXO 的情形，那么，于 2018 年提出的 “通道工厂（channel factory）” <sup><a href="#note1" id="jump-1">[1]</a></sup> 概念也无疑是共享 UTXO 的一个子集。此外，于 2020 年提出的 “支付池（CoinPool）”  <sup><a href="#note2" id="jump-2">[2]</a></sup> 概念，以及在讨论 “限制条款（covenant）” 提议时 “顺带” 提出的一些设计 <sup><a href="#note3" id="jump-3">[3]</a></sup>，都为这个主题增加了内容。</p><p>实际上，人们提出的设计是如此多样，已界临容易引起困惑和混淆的程度（至少对我自己来说是如此）。这些理解上的障碍，要求我们归纳这些设计的共性、确定一个基础概念，并基于这个基础概念以及配套的术语来解释这些设计。</p><p>值得一提的是，一些作者已明确开始这样做了（将看似不同的概念当成同一概念上的有区别设计） <sup><a href="#note4" id="jump-4">[4]</a></sup>；Optech 的主题界面，也将意义相近的 “payment pool” 和 “Coinpool” 都合并到了 “Joinpool” 的名下 <sup><a href="#note5" id="jump-5">[5]</a></sup>（但依旧未提出 “Joinpool” 和 “通道工厂” 的基础概念）。</p><p>在这些努力的启发下，本文尝试将 “共享 UTXO” 作为基础概念，讨论这个概念要面临的基础问题，并解释常见的一些设计（比如：通道工厂、Statechain、ARK）的形式和特性。</p><p>在此之前，我们要先解释一些更基础的概念。</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="承诺交易"><a href="#承诺交易" class="headerlink" title="承诺交易"></a>承诺交易</h3><p>在合约式协议（contractual protocol）中，“承诺交易（commitment transaction）” 指的是得到了对手方的签名（因而有效、可用）、但默认不向外广播的交易。这些交易可以被当成对手方给出的 “可信承诺”，也是参与者确保自己可以单方面取回自己应得的资金的保证。</p><p>比如，在闪电通道中，通道初始化以及每次更新通道状态的时候，双方都要交给对手方一个承诺交易；这些承诺交易记录了两方在通道内的最新状态（余额），一旦被发送到链上确认，就会将通道资金分拆给双方。</p><p>这里要强调的是承诺交易表达一个合约内部状态的能力。一个闪电通道在链上仅仅表现为一个 UTXO，但它却能容纳两个用户的资金在里面，所依靠的，正是承诺交易的这种能力。</p><h3 id="vTXO"><a href="#vTXO" class="headerlink" title="vTXO"></a>vTXO</h3><p>在 “共享 UTXO” 的语境下，“vTXO（虚拟的 UTXO）” 指的是寄身于 UTXO 中的用户资金的<strong>最基本单元</strong>。提出这个术语是为了分析和表达上的便利。但同时，这样的称谓也有严格的事实基础：给定我们以承诺交易的输出（TXO）来表达用户的资金，这些资金的动作跟 UTXO 是没有分别的。</p><p>在这里，我将 vTXO 分成两种类型：（1）排他性占有的资金（就像常见的单签名 UTXO），可称为 “coin”；（2）<strong>闪电通道</strong>。这里之所以分成两种类型（而不是将闪电通道也当成一种共享 UTXO，从而当作只有前者一种类型），是因为：（1）闪电通道的交易输出中都留有为实现下文即将提到的 “链下更新机制” 而专门设计的装置，不能算作 coin；（2）排他性占有的资金与闪电通道在使用体验上有极大的不同：闪电通道允许发起即时支付（同时，闪电网络可以放大这种支付能力），而且支付的大小是可以调整的；但在排他性占有的资金中，这两者都是做不到的；（3）关于闪电通道的特性，我们已经积累了大量的知识，也有了可以描述这些特性的术语，没有必要将其表述为一种共享 UTXO、然后用共享 UTXO 的术语将这些特性重新表述一遍；将它当成一个基本的可分析的单元，会在理解上提供极大的便利。</p><p>这种分类，从字面上看当然是不完美的，但却是有用的。往后我们会看到，从形式上看，一些设计（比如：带有服务商的单向通道）似乎也符合闪电通道的分类理由，但其实际用法却更接近于 coin；这种情况下，我依然将其归类为 coin。</p><h3 id="链下更新机制"><a href="#链下更新机制" class="headerlink" title="链下更新机制"></a>链下更新机制</h3><p>仅仅拥有 “承诺交易”，还不足以构造出闪电通道。设想一下，如果我们只是能让两个用户的资金寄身于同一个 UTXO 中，但每次他们要相互支付时，都依然需要发起一笔链上交易，那么这种构造的实用性是很值得怀疑的。闪电通道的成功之处，就在于设计出了一种可用的、在链下更新承诺交易的机制（“LN-Panelty”），从而允许双方相互支付而无需发起链上交易。</p><p>在共享 UTXO 的语境下，链下更新机制指的是能在 vTXO 之间转移资金而不需要链上确认的机制。</p><h2 id="共享-UTXO"><a href="#共享-UTXO" class="headerlink" title="共享 UTXO"></a>共享 UTXO</h2><p>在 <em>CoinPool</em> 一文 <sup><a href="#note2" id="jump-2">[2]</a></sup> 中，两位作者归纳了一种重要的特性：“<strong>非交互式任意顺序取款</strong>”，意思是，无论何时退出，用户总能取回自己应得的资金，并且取款过程不需要他人的帮助。我认为，这一属性是共享 UTXO 的根本属性，缺失了这一属性，就会沦为一种托管方案；不管这种托管方案内部有什么样的设计，都不能称为 “共享 UTXO”。</p><p>在技术上，这就意味着，我们需要让每一方（每一个 vTXO 的持有者），都能否决共享 UTXO 的状态变更，否则，就有可能出现多数参与者侵犯某个参与者资金所有权的事情。也即，所有可能发生的状态变更，都必须得到每一位参与者（预先或即时）的同意。</p><p>比如，如果有 3 个用户共享一个 UTXO，那么不论是甲动用其中的资金向外支付，还是甲希望给乙支付，只要交易以该共享 UTXO 为输入，都必须保证：没有丙的签名同意，这些交易就不能生效。否则，甲和乙就有可能串谋倾吞丙的资金。</p><p>技术上，这很容易解决，只需要求每一位用户都参与的多签名装置即可。</p><p>然而，在实用性上，这就构成了一种挑战：一旦某个用户离线，其它用户更新状态的能力就会受到影响（虽然取款能力不受影响）。（类似于在闪电通道中，对手方离线会使你无法操作通道中的资金）。</p><p>可以说，所有的共享 UTXO 的设计，都是在应对这个挑战。</p><p>接下来，我们会用一系列的例子，介绍在共享 UTXO 内部表达状态的形式以及 vTXO 的类型，如何决定离线用户对共享 UTXO 的影响，并相应影响共享 UTXO 的实用性和使用体验。</p><h3 id="拥堵控制"><a href="#拥堵控制" class="headerlink" title="拥堵控制"></a>拥堵控制</h3><p>先考虑一种最简单的多人共享 UTXO：n 方都在一个 UTXO 内拥有资金（vTXO），并且这些 vTXO 都是排他性控制的；这些 vTXO 都得到了同一笔承诺交易的承诺（每一方都持有同一笔承诺交易，并且都得到了其它所有人的签名）；一旦这样的承诺交易得到广播和区块确认，就会将这个共享 UTXO 完全分解，即内部状态完全曝光、每个人都拿回自己原本存放在共享 UTXO 中的资金。如下图所示：</p><p><img src="/../images/on-sharing-utxo-forms-and-features/congestion-control.svg" alt="congestion-control-s"></p><p>这是一种最简单的设计：vTXO 使用了最简单的类型、没有链下更新机制（因此三人无法在链下发起内部支付）、任何一个人单方面退出都会导致全体退出。这样一种构造，到底有什么用呢？</p><p>Jeremy Rubin 根据其使用场景，将这种构造命名为 “拥堵控制（congestion control）”，其用途是：在手续费高涨的时候，将需要发生的许多支付 “存放” 在一个 UTXO 中，等待手续费降低到可接受的水平时，再将这些支付在链上展开。比如，在手续费高涨的时候，Alice 三人希望从托管式交易所取款，那么交易所可以协调三方初始化一个共享的 UTXO，将三人的资金先打到这个共享的 UTXO；等手续费退潮的时候，三人再合作或使用手中的承诺交易取出其中的资金。</p><p>如果能保证三人始终在线，那么这种构造的有用性会大大提高：三人可以进一步协调手续费；也可以不使用自己在承诺交易中使用的收款地址，而是直接向另一个人支付。但在用户随机的情况下，这是无法保证的。而在非合作退出的情形中，由于承诺交易已预先锁定了手续费，希望加速确认的用户只能使用子交易来追加手续费（即 “CPFP” <sup><a href="#note6" id="jump-6">[6]</a></sup>），而不能使用 “手续费替换（RBF）”。 </p><p>与此相关的，另一个可能受到批评的地方在于其全体退出机制：在非合作情形下，如果某个用户比其他人更急着退出，而承诺交易预设的手续费率无法做到，那么 TA 将需要独自承担让所有这些 UTXO 都得到链上确认的额外手续费。这意味着，如果拥堵控制 UTXO 中的用户并不都具有相同的时间偏好和使用模式，其用户体验就会打折扣甚至变成灾难。</p><p>有没有办法，能够只弹出一个 vTXO，而不是让所有的 vTXO 都展开呢？显然是有的 —— 仅仅 “只是” 更深度地利用拥堵控制这种构造而已。</p><h3 id="改进的拥堵控制"><a href="#改进的拥堵控制" class="headerlink" title="改进的拥堵控制"></a>改进的拥堵控制</h3><p>如下图所示，我们可以这样初始化一个拥堵控制 UTXO：当 Alice 想要单方取款时，她能够动用的承诺交易只会弹出属于她的 vTXO，而将剩余的资金交回给属于剩余参与者的另一个拥堵控制 UTXO（比如下图中的 “拥堵控制 UTXO-2”），该拥堵控制 UTXO 也被预先签名了承诺交易，能让 Bob 和 Carol 可以单方退出。其余情形也是同理，因此下图中的 “承诺交易 B” 和 “承诺交易 C” 没有进一步细化。</p><p><img src="/../images/on-sharing-utxo-forms-and-features/high-congestion-control.svg" alt="high-congestion-control"></p><p>这种构造可以大大缓解前面提到的额外手续费问题，因为，用户无论什么时候取款，都只需多确认一个 UTXO 而已。</p><p>而且，假设 Alice 也会给大家分享自己对承诺交易 A 的签名，那么该交易也可被其他用户用作 “排除交易” —— 在 Alice 长时间无响应的时候，将她弹出这个共享的 UTXO，让剩余的用户能享受正常的共享 UTXO 可以给他们带来的好处。这也可以限制 Alice 的离线给其他用户带来的影响。</p><p>美中不足的是，这种构造只允许用户一个一个排队退出；如果有多个用户尝试同时退出，就会发生所谓的 “<strong>状态争用&#x2F;竞争进入</strong>（race condition）” 问题：这些用户将发起手续费竞赛，以争夺排队的次序（优先退出的资格）。因为我们并未安排允许多个用户同时退出的承诺交易 —— 如果有这样的承诺交易，就无需争用。例如，当观察到 Alice 要退出时，Bob 可以使用准备好的让三人同时退出的承诺交易，以 RBF 方法让这笔交易获得比 Alice 的交易更高的确认优先级（从经济性上来说可以做到比 Bob 单发一笔交易更好，但这需要在签名承诺交易时设计好）；当 Bob 的交易获得确认时，三人可以同步退出。</p><p>乍看起来，似乎毫无疑问应该增设这种允许多人同时退出的承诺交易。但与此同时，“共享 UTXO” 这个概念也将开始向我们展现它的峥嵘之处：与上述简单拥堵控制构造相比，改进后的构造在初始化时需要用户签名的承诺交易数量大大增加，也即用户间交互的需求大量增加；而且，它不是随用户的数量而线性增加的，而是会出现所谓的 “组合爆炸”；如果再增设这样的允许多人同时退出的承诺交易，退出的可能性会进一步爆炸（如果因为 3 人的数量太少而使这一点不明显，读者可以尝试画一个 5 人的共享 UTXO）。</p><p>用户要用哪种通信手段完成这么多的交互？（当然是互联网，问题是这些用户如何找寻彼此呢？）给定一个用户在初始化过程中失联就会导致初始化完全失败、必须从头再来的可能性，是否应使用某种抗女巫机制？这些都是需要考虑的问题。</p><p>那么，是否有某种中庸之道？</p><h3 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h3><p>考虑下图这样的共享 UTXO：当 Alice 想要退出（或其他人想要排除 Alice）时，Alice 无法直接从共享 UTXO 中弹出，而需要先广播 “承诺交易 01”，该交易会将原本的共享 UTXO 对半分拆成两个共享的 UTXO；然后，Alice 广播下一笔承诺交易，继续分拆自身所在的共享 UTXO；…… 如此，直至其 vTXO 完全退出。</p><p>（熟悉这个领域的读者想必会脱口而出：“这是一种树形结构！”没错，正是如此。）</p><p><img src="/../images/on-sharing-utxo-forms-and-features/tree-sharing.svg" alt="tree-sharing"></p><p>在退出的公平性上，这种构造不如上一节所述的构造：视乎 Alice 退出的先后，她几乎总是需要额外确认多于 1 个 UTXO。在我们这个例子中，如果她最先退出的话，她需要额外确认 2 个 UTXO。如果是一个 8 人的共享 UTXO，则她需要额外确认 3 个 UTXO。</p><p>然而，只要仔细观察上图，就可以发现其巨大优点，尤其在参数者数量较多的时候：</p><p>（1）需要签名的承诺交易的数量大大减少（本构造在多出 1 位用户的前提下，需要签名的承诺交易数量还比上一种构造少）；这是因为，多个用户可以共用相同的承诺交易来退出；</p><p>（2）它也部分缓解了前述的状态争用问题，因为共享的 UTXO 每分裂一次，就多出一个允许访问的 UTXO，也即允许多一个原来位于不同分支的用户操作；假设 Alice 和 Carol 都要退出，那么，在让 “承诺交易 01” 得到确认之后，他们就可以互不影响地并行操作；</p><p>（3）它也让链下更新机制更容易运行（如果有的话）。假设 Alice 离线，在我们前面所述的简单拥堵控制构造中，链下更新机制也会停摆；而在上述改进型构造中，尽管其他人可以更新原本就不包含 Alice 的承诺交易，但需要更新的数量很大，也会给设计带来难度、增加分析的复杂性；而在本构造中，由于承诺交易的数量大大减少，且不包含 Alice 的承诺交易易于定位和分析，自然就更容易设计出链下更新机制。</p><p>综上所述，在这几节中，我们分析了共享 UTXO 内部的状态表达方式对其实用性和用户体验造成的影响。这三种表达方式可姑且称之为 “串珠结构”、“星月结构” 和 “树形结构”。这三种结构最初如何提出已不可考，但我想，肯定有许多开发者思考过这些结构。</p><p>我们也在这些分析中了解了共享的 UTXO 在其生命周期中可能遇到的诸多挑战。</p><p>接下来，我们进一步分析 vTXO 的类型所带来的影响。</p><h3 id="Coin-vs-闪电通道"><a href="#Coin-vs-闪电通道" class="headerlink" title="Coin vs. 闪电通道"></a>Coin vs. 闪电通道</h3><p>看看以下这种形式的共享 UTXO，在特性上，它会跟 “拥堵控制” 构造有什么区别？</p><p><img src="/../images/on-sharing-utxo-forms-and-features/channel-factory-proto.svg" alt="channel-factory-proto"></p><p>没错，它跟拥堵控制使用了完全相同的状态表达结构，但正因为这些 vTXO 并不是排他式控制的 coin，而是闪电通道，那么，即使这种共享 UTXO 没有实现链下更新机制（不能允许资金在 vTXO 之间转移），也不影响这些用户可以相互支付，因为他们两两之间都开设了闪电通道！他们可以相互支付，也可以借助共享通道中的对手来发起闪电支付和接收闪电支付。唯一他们不能做的事情是调整他们位于这个共享 UTXO 中的通道的大小 —— 这需要发起链上交易，更新这个共享的 UTXO 才行。</p><p>这个例子说明了 vTXO 的类型对共享的 UTXO 的用户体验带来的影响；也说明了，即使不改变状态表达结构，也可能在其它方面改善用户的体验。当然，这也需要增加用户在初始化阶段需要签名的承诺交易的数量。</p><p>实际上，上图启发自一种著名的共享 UTXO 设计 —— 通道工厂。与通道工厂不同的是，我在这里假设了它不存在链下更新机制（而通道工厂有）。如果有这样的机制，那么，这三位用户就可以调整彼此之间的通道的大小而不需要发起链上交易 —— 有显而易见的用途。</p><h3 id="多方的链下更新机制"><a href="#多方的链下更新机制" class="headerlink" title="多方的链下更新机制"></a>多方的链下更新机制</h3><p>链下更新机制可以大大增加共享 UTXO 的实用性：当 vTXO 是排他性控制的资金时，链下更新机制允许这些用户相互支付；当 vTXO 是闪电通道时，链下更新机制允许这些通道调节大小。</p><p>不过，即使是链下更新，也需要让被更改的状态会影响到的参与者都在场，才能动用（否则就不安全）。因此，合适的状态表达结构会有便利与其运作。</p><p>最后，尽管链下更新机制在某些条件下可以发挥跟闪电通道型 vTXO 相同的效果，但这并不代表我们划分 vTXO 的类型是多余的，也不代表将链下更新机制作为一个独立的元素是多余的。从分析的便利和完整性出发，都要求我们将它们识别为两个独立的元素。</p><p>接下来，我们要介绍几种多方链下更新机制。（如果你对技术细节不感兴趣，可以直接跳到下一个章节。）</p><p>在闪电通道中，链下的状态更新机制是通过在承诺交易的输出中安装特殊的装置来实现的：每当要更新状态、交换新的承诺交易时，双方就将自己用在上一笔承诺交易中的一个秘密值交给对方。这等于是把上一笔承诺交易中归属于自身的输出交给对方，一旦自己广播了旧的承诺交易，就将失去所有。这就实现了一种惩罚机制，使双方都不敢广播过时的承诺交易。</p><p>这样一种机制，是极难延伸成一种多方链下更新机制的。具体来说，当某一方提交过时状态时，该方的确可被惩罚，但其他方也被回退到了一种旧状态，而无法马上按照最新状态来分割资金。解决办法是让每一笔表示旧状态的承诺交易都可以在一个窗口期内被表示更新状态的承诺交易花费，以保证总是可以按照最新状态分割资金并应用惩罚。问题是，这会让单次更新需要签名的承诺交易数量随已发生的状态更新次数而增长，且需要保存的承诺交易数量会呈阶梯式增长。如下图：</p><pre><code>在第 2 次更新状态时：共享 UTXO --&gt; 承诺交易#0 --&gt; 承诺交易 #01 --&gt; 承诺交易 #012共享 UTXO                --&gt; 承诺交易 #1 --&gt; 承诺交易 #12共享 UTXO  --&gt; 承诺交易 #2注 1：承诺交易 #0 表达的是初始状态。注 2：纵向同一位置的承诺交易表达的是相同的状态。</code></pre><p>这样一来，虽然状态更新的安全性得到了保证，但参与者的交互和存储负担都很大，而且，一旦某个用户将旧的承诺交易广播上链，为使用最新状态结算通道，可能就需要在链上确认整个交易链条（例如，Alice 将承诺交易 #0 上链，那么其他人要继续广播 #01 和 #012 上链），这就没什么可扩展性可言了。</p><p>这就是我们想要 “eltoo” 的原因。这一想法在 2018 年提出 <sup><a href="#note7" id="jump-7">[7]</a></sup>，它提出了一种新的 SIGHASH 标签（即 ANYPREVOUT，现已被 BIP-118  <sup><a href="#note8" id="jump-8">[8]</a></sup>定义）；使用这种标签，签名可以仅指定交易的输出，而不指定输入，因此总可以用来花费相同的脚本；再加上递增承诺交易 nLocktime 字段的数值，就可以实现这样一种效果  <sup><a href="#note9" id="jump-9">[9]</a></sup>：交易链条中排在后面的交易可以直接花费自己的任意一个祖先交易，而不论两者在被签名的时候中间隔着多少笔交易，同时反之不能成立。也即，当 Alice 将 #0 上链的时候，其他人可以直接广播 #012，跳过中间的 #01（实际上，这时候已经不需要 #012，而只需要 #2 了）。这就大大缓解了参与者的交互和存储负担、挽救了可扩展性。</p><p>但是，eltoo 需要我们以软分叉激活 SIGHASH_ANYPREVOUT，所以这种机制，当前是不可用的。</p><p>2022 年，John Law 提出了另一种叫做 “可调整惩罚协议（Tunable-Panelty Protocol）” <sup><a href="#note10" id="jump-10">[10]</a></sup> 的链下更新机制。</p><p><img src="/../images/on-sharing-utxo-forms-and-features/Tunable-Panelty.svg" alt="Tunable-Panelty"></p><p>在这种机制中，表示状态的承诺交易（CT）（带有相对时间锁）不仅以共享 UTXO 为输入，还有额外的一个小额的输入（Dust），来自某个参与者在共享 UTXO 之外的另一笔资金。当某一个参与者，比如 Alice，尝试发布一笔承诺交易的时候，必须先让这个小额输入先得到确认，也即需要发布 ST（“状态交易”）。而 ST 还有另一个输出，实际上是一份押金（Stake），因为在更新状态时，参与者必须给出这个押金的私钥。</p><p>最终的效果是，如果某个参与者尝试发布某个旧的承诺交易，必须先将一笔旧的 ST 上链，而这就会导致其押金被取走 —— 而此时，共享的 UTXO 还没有被花费，因此不影响所有用户使用最新状态的能力。相等于，TPP 为分割共享 UTXO 设计了一个准备阶段，使尝试欺诈（或者只是粗心）的用户无法直接操作共享 UTXO，因此避免了前面提到的需要重放交易链条的问题。</p><p>TPP 的一个重大优点是它无需变更比特币的底层，现在就可以实现。</p><p>实际上，还有一种相当相当简单的多方更新机制，是基于时间锁的承诺交易。它脱胎于对两方通道的研究  <sup><a href="#note11" id="jump-11">[11]</a></sup>。</p><p><img src="/../images/on-sharing-utxo-forms-and-features/timelock-ct.svg" alt="timelock-ct"></p><p>在这种机制中，承诺交易本身带有交易层面的时间锁，而每次更新状态，参与者都签名一笔时间锁更短（因此更快可被发布、得到确认）的承诺交易。时间锁自身就防止了承诺交易冲突的问题，因此也无需进一步设计应对这种冲突可能性（某个用户发布表示旧状态的承诺交易）的机制。</p><p>这种机制是如此简单，易于实现，让上面两种机制的探讨似乎没有意义。但并非如此。这种机制有个致命的缺陷是，它具有明确的寿命 —— 更新达到一定的次数之后，就只能结算并重新建立一个新的共享 UTXO。尽管可以缓解（比如，缓解办法之一是在共享 UTXO 与最终表达状态的承诺交易之间插入多笔中间交易，以倍乘相对时间锁），但无法从根本上解决。</p><h3 id="题外话：与共享-UTXO-相关的限制条款提议"><a href="#题外话：与共享-UTXO-相关的限制条款提议" class="headerlink" title="题外话：与共享 UTXO 相关的限制条款提议"></a>题外话：与共享 UTXO 相关的限制条款提议</h3><p>虽然共享 UTXO 常常被关联起各种可以实现限制条款的软分叉提议来讨论，但到目前为止，我几乎没有提到它们。原因在于，虽然这些限制条款提议可被用于协助共享 UTXO 的运行，但它们并不决定共享 UTXO 的根本特征 —— 而唯有理解了共享 UTXO 的根本特性，我们才能理解这些限制条款在这个场景中到底派什么用场。</p><p>我们在这里简单地分析三种提议：OP_TLUV <sup><a href="#note12" id="jump-12">[12]</a></sup>、OP_CTV <sup><a href="#note13" id="jump-13">[13]</a></sup> 和 OP_EVICT <sup><a href="#note14" id="jump-14">[14]</a></sup>。</p><p>如前所述，在建构共享 UTXO 时，需要进行大量交互（签名大量的承诺交易以保证安全性），会阻碍其实用性和用户体验。对此，OP_TLUV 的解决思路是，利用 Taproot 的默克尔脚本树结构，将用户的状态承诺到脚本树的叶子中。在用户需要单方面退出时，可揭晓这个叶子，并以其中记录的资金数量退出；TLUV 会验证资金数量、确保剩余资金被转移到了一个新的 taproot 输出中，且该输出已不再允许该退出用户参与 —— 其公钥已从 taproot 内部公钥中删除，其脚本也已经从默克尔树上摘除。</p><p>由于默克尔脚本树本身可以承诺用户的资金状态，用户也就无需签名承诺交易，在初始化和交互过程中，只需完全验证 taproot 输出的内部公钥和脚本树构成即可。这就极大地降低了交互需求。</p><p>熟悉本领域其他协议设计的读者可能会说：这不就是状态模型下常见的 “状态树” 设计吗？没错，正是如此。但从我们前面的结构分类法来看，<strong>这种设计</strong>应该被归类为星月结构，而不是树形结构 —— 它允许单用户直接退出，并让其他用户不受影响，而不是每次都对半分拆共享 UTXO。相应地，我们也可以想象一种使用 OP_TLUV 的树形结构 —— 被脚本树承诺的是一半参与者的资金和聚合公钥。</p><p>无独有偶，OP_CTV 也可以用来支持这种设计。因为，OP_CTV 使得我们可以让一个脚本仅可以被具备某些特征的交易花费，这些特征包括输出的数额和脚本。因此，我们也可以将用户的取款交易承诺到默克尔脚本树的叶子中，允许用户单方面动用 —— 反正，动用的结果是其资金退出，而剩余的资金进入一个 UTXO，该 UTXO 也已被我们用合适的内部公钥和默克尔脚本树锁定，允许剩余的用户单方面退出。</p><p>与 OP_TLUV 相比，在 OP_CTV 的这种用法中，用户需要验证的东西更多（需要验证每一个取款步骤都会将剩余资金交给正确的脚本树），但同样不需要再签名承诺交易（验证的数量跟仅使用承诺交易时相同）。</p><p>而 OP_EVICT 的想法则是另辟蹊径。OP_EVICT 的作者 ZmnSCPxj 注意到，在使用 OP_TLUV 的星月结构中，退出交易需要揭晓自身叶子的默克尔树路径；而使用树形结构也需要揭晓类似于默克尔树路径的多笔交易。有无办法避免这种开销？</p><p>OP_EVICT 想法是，让用户直接签名一个输出（公钥与数额），并让这样的签名可被 OP_EVICT 操作码理解、用于验证当前的某个交易输出是否与被签名输出一致。在验证完这个签名和对应的输出之后，OP_EVICT 会从 taproot 内部公钥中减去这个签名公钥，并要求剩余公钥对交易的签名。如此一来，等于是 taproot 的内部公钥自身就承诺了参与者的构成，而参与者的资金也无需得到默克尔树的承诺，只需要公钥自身的签名（以及其他用户的输出签名）保护。</p><p>OP_EVICT 还有一个重大的优点：它允许多个用户同时退出。因此，它可以实现一种没有竞争进入问题的星月结构。（更准确来说，OP_EVICT 的思维模式有所不同，它假设了用户很少需要单方面退出，相反，难以处理的问题是某个（些）用户离线造成其他用户无法正常使用共享 UTXO 的功能。因此，需要的是一种能够高效将离线用户排除出去的工具，排除掉离线用户，剩余用户就可以通过合作来更新状态了。所以，用户自己退出，并不是这个操作码的 “正常” 用法。）</p><p>与前面两者相比，由于没有显式承诺状态的方法，它所要求的用户间交互也将更多，但也显著少于只使用承诺交易的情形。</p><p>综上，限制条款操作码在共享 UTXO 场景中的主要用处是减少交互需求，它可以降低某些状态表达结构的运行开销，但并不决定我们可以使用哪种结构。对结构的研究也不会因为限制条款的出现而失去意义。</p><h2 id="共享-UTXO-设计案例"><a href="#共享-UTXO-设计案例" class="headerlink" title="共享 UTXO 设计案例"></a>共享 UTXO 设计案例</h2><h3 id="多方通道"><a href="#多方通道" class="headerlink" title="多方通道"></a>多方通道</h3><p><img src="/../images/on-sharing-utxo-forms-and-features/multi-user-channel-1.svg" alt="multi-user-channel-1"></p><p>如上图所示，这是一种具备链下更新机制的拥堵控制 UTXO（vTXO 为 coin、具备链下更新机制的串珠结构）。</p><p>有时候，下图这种结构也会被当成一种多方通道。</p><p><img src="/../images/on-sharing-utxo-forms-and-features/multi-user-channel-2.svg" alt="multi-user-channel-1"></p><p>与分散的闪电通道（以及下文要介绍的分层通道）相比，多方通道的好处在于更少面临 “收款额度（入账流动性）” 的困扰。缺点在于，更难抵抗离线用户带来的影响。</p><h3 id="分层通道"><a href="#分层通道" class="headerlink" title="分层通道"></a>分层通道</h3><p>“分层通道（hierarchical channel）” 是 John Law 在 2023 年提出的想法 <sup><a href="#note15" id="jump-15">[15]</a></sup>。它使用树形结构，vTXO 是闪电通道。同时，作者提议使用 TPP 作为其链下更新机制。</p><p><img src="/../images/on-sharing-utxo-forms-and-features/hierarchical-channel.svg" alt="hierarchical-channel"></p><h3 id="通道工厂"><a href="#通道工厂" class="headerlink" title="通道工厂"></a>通道工厂</h3><p>通道工厂使用串珠结构，vTXO 为闪电通道（共享 UTXO 的每两个用户之间都有闪电通道），使用时间锁递减承诺交易作为链下更新机制。</p><h3 id="Statechain"><a href="#Statechain" class="headerlink" title="Statechain"></a>Statechain</h3><p>“Statechain”<sup><a href="#note16" id="jump-16">[16]</a></sup> 的基本想法是，通过转移控制一个 UTXO 的私钥，就可以将这个 UTXO 完全转移，而不需要发生链上交易。为了协助这样的转移，两方（用户以及服务商）需要共同构造一个公钥（两方都只有该公钥背后的私钥的一半），并将资金存入这个公钥（为了保证免信任取款，还需要预先签名一笔带有时间锁的承诺交易）；在支付时，支付者 和&#x2F;或 服务商先给接收者展示该 UTXO 链下所有权的流转历史，证明资金的真实性；然后，支付者交出自己的签名，表示支付的意愿；接收者跟服务商合作生成新的私钥碎片，并签名新的一笔带有更短时间锁的承诺交易，支付完成。</p><p>如果用共享 UTXO 的术语来表述，它是一种使用时间锁递减承诺交易来更新状态的串珠结构；只不过，这个共享 UTXO 只有一个 vTXO，而且 vTXO 的持有者不能分割自己的 vTXO，一旦支付，就必须把整个 vTXO 都转移过去 —— 任何时刻，vTXO 的合法持有者都只有一个；此外，为了能够引入新的用户而不使用链上交易，用户必须信任服务商不会与该 vTXO 的任何一个前任用户勾结（他们勾结，就可以生成共享 UTXO 私钥的有效签名，从而把钱转走） —— 这是它最大的缺点，也是为什么在接收支付时，用户需要执行额外的验证。</p><p>如果用户想启用更细粒度的支付，而不是只能一次性转移全部资金，那么可以将 vTXO 转移给一条闪电通道，在闪电通道内发送支付，这是可以做到的 <sup><a href="#note17" id="jump-17">[17]</a></sup>。</p><h3 id="ARK-和-ARK-v2"><a href="#ARK-和-ARK-v2" class="headerlink" title="ARK 和 ARK v2"></a>ARK 和 ARK v2</h3><p>“ARK”<sup><a href="#note18" id="jump-18">[18]</a></sup> 是一种没有链下更新机制的扁平结构。那么，它跟 “拥堵控制” 的区别在哪里？在于其 vTXO 并不是纯粹的 coin（但也不是闪电通道）。从脚本内容上来说，更像一种 “单向通道”。这种单向通道有两种花费路径，一是两个参与者的多签名；二是带有时间锁的某一用户单签名。后者可以用来表明这条单向通道的最终资金归属，也可以用来催促某一参与者行动。而前者，则可以在时间锁还未到期时，启用多签名装置可以支持的功能。在下文描述单向通道时，我会将可以使用时间锁分支的参与者写在前面。</p><p>用户在 ARK 中的 vTXO 为 ARK 服务商与用户的单向通道。 而用户的 vTXO 又通过一笔特殊的承诺交易（Redeem TX），为用户与 ARK 服务商的单向通道注入资金。</p><p><img src="/../images/on-sharing-utxo-forms-and-features/ARK.svg" alt="ARK"></p><p>这套设计被用来支持一种 “非交互的原子化 coinjoin 支付”：当 Alice 尝试给 David 支付时，她可以用自己跟服务商的单向通道（Alice-Server Coin）表达一种可信承诺：当且仅当你给 David 支付，我这笔钱就属于你；但如果你没有在一定时间内做到，我就取走我这笔钱。这确实是可以做到的，因为，作为共享 UTXO，ARK 无法在 Alice 不同意的时候被花费。因此，如果服务商不提供服务，Alice 总可以发布 the CT 和 Redeem TX#A，然后将 Alice-Server coin 中的钱取走。</p><p>相应地，服务商也不担心 Alice 会赖账，因为一旦 TA 给 David 支付了，就总是可以让 Alice-Server coin 确认，然后用 Alice 给出的承诺交易将钱取走。</p><p>最终，理想情形是，双方会合作：服务商给 David 合作，Alice 同意跟服务商一起在链上变更 ARK 的状态。而在这个过程中，Alice 并没有直接给 David 支付；如果 David 在链上接收支付，那么对于外部观察者来说，也不知道是这个 ARK 中的谁给他支付的（只有 Alice 的同伴知道）；而如果 David 也使用另一个 ARK 来接收支付，那么，甚至连 Alice 在这个 ARK 中的同伴，也不知道钱交给了谁（只要这些同伴不是在两个 ARK 中都有参与）。</p><p>此外，这里的单向通道虽然理论上支持细粒度的支付，但 ARK 并不支持这个特性。跟 statechain 一样，资金是整个转移的。</p><p>ARK v2 基本上沿用了相同的构造 <sup><a href="#note19" id="jump-19">[19]</a></sup>，只是启用了一些让服务商能够更高效地回收资金的设计（也同样依托于 taproot 的默克尔脚本树）。但从共享 UTXO 的构造上来说，两个版本基本上是一样的。此外，ARK 可以不依赖于限制条款，但 ARK v2 明确依赖于限制条款。</p><h2 id="对共享-UTXO-的赞赏和批评"><a href="#对共享-UTXO-的赞赏和批评" class="headerlink" title="对共享 UTXO 的赞赏和批评"></a>对共享 UTXO 的赞赏和批评</h2><p><em>CoinPool</em> 一文很好地勾勒了研究共享 UTXO 的两个动机，也正是共享 UTXO 有望为人们带来的好处：</p><ul><li>隐私性。当许多人共享一个 UTXO，就可以在链上隐匿支付的发起人；而如果接收者也使用共享的 UTXO，还可以隐匿接收者。ARK 就是拥抱这个方向的代表。</li><li>可扩展性。可以缩减链上 UTXO（链上状态）的数量、减少对区块空间的需求（比如，可以在共享 UTXO 内使用链下更新机制来相互支付）。这方面的代表应属通道工厂。</li></ul><p>而对这个概念的批评主要从实用性角度出发，认为在用户数量增多时，全体用户都在线是非常罕见的，这意味着其状态可能经常卡住而无法更新，因此它是一种脆弱、可用性差的机制。还有一种批评则更加尖锐，来自 Peter Todd：我们假设了要使用这种机制来拓展比特币的处理能力，即用它来容纳经济条件差、无法负担得起在链上拥有属于自己的 UTXO 并加以使用的用户；然而，我们又假设了真的发生什么事的时候，用户会主动退出或者被动弹出到链上 —— 他们怎么又突然负担得起了呢？</p><p>这种批评显然需要更深入的分析，才能找出合理的回应。至少，在目前，出于一些好处，人们不会停止对共享 UTXO 的研究。并且，这些研究已经产生了价值，无论是理论上的（比如 TPP），还是实际上的（比如 statechain 的实现）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文分析了共享 UTXO 的基本元素，并以此解释了当前多种共享 UTXO 的具体设计，将它们的特性归因到对特定基本元素的使用。</p><p>本文主要着眼于结构上的特点，对许多技术细节（例如相关脚本的设计以及配套的用户交互流程）则多有省略。该方向上的进一步研究可以帮助我们进一步评价不同设计的短长。</p><p>（正文完）</p><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>1.<a id="note1"> </a><a href="https://tik-old.ee.ethz.ch/file/a20a865ce40d40c8f942cf206a7cba96/Scalable_Funding_Of_Blockchain_Micropayment_Networks.pdf">https://tik-old.ee.ethz.ch/file/a20a865ce40d40c8f942cf206a7cba96/Scalable_Funding_Of_Blockchain_Micropayment_Networks.pdf</a> <a href="#jump-1">↩</a></p><p>2.<a id="note2"> </a><a href="https://www.btcstudy.org/2022/06/15/coinpool-exploring-generic-payment-pools-for-fun-and-privacy/">https://www.btcstudy.org/2022/06/15/coinpool-exploring-generic-payment-pools-for-fun-and-privacy/</a> <a href="#jump-2">↩</a></p><p>3.<a id="note3"> </a><a href="https://utxos.org/uses/scaling/">https://utxos.org/uses/scaling/</a> <a href="#jump-3">↩</a></p><p>4.<a id="note4"> </a><a href="https://www.btcstudy.org/2023/11/28/op-evict-an-alternative-to-op-tapleafupdateverify-by-zmnscpxj/">https://www.btcstudy.org/2023/11/28/op-evict-an-alternative-to-op-tapleafupdateverify-by-zmnscpxj/</a> <a href="#jump-4">↩</a></p><p>5.<a id="note5"> </a><a href="https://bitcoinops.org/en/topics/joinpools/">https://bitcoinops.org/en/topics/joinpools/</a> <a href="#jump-5">↩</a></p><p>6.<a id="note6"> </a><a href="https://www.btcstudy.org/2022/03/17/introduction-to-fee-bumping-by-Bitcoin-Optech/#CPFP-%E7%AE%80%E4%BB%8B">https://www.btcstudy.org/2022/03/17/introduction-to-fee-bumping-by-Bitcoin-Optech/#CPFP-%E7%AE%80%E4%BB%8B</a> <a href="#jump-6">↩</a></p><p>7.<a id="note7"> </a><a href="https://blockstream.com/eltoo.pdf">https://blockstream.com/eltoo.pdf</a> <a href="#jump-7">↩</a></p><p>8.<a id="note8"> </a><a href="https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki</a> <a href="#jump-8">↩</a></p><p>9.<a id="note9"> </a><a href="https://www.btcstudy.org/2020/09/01/en-eltoo-next-lightning/">https://www.btcstudy.org/2020/09/01/en-eltoo-next-lightning/</a> <a href="#jump-9">↩</a></p><p>10.<a id="note10"> </a><a href="https://bitcoinops.org/zh/newsletters/2023/03/29/#preventing-stranded-capital-with-multiparty-channels-and-channel-factories">https://bitcoinops.org/zh/newsletters/2023/03/29/#preventing-stranded-capital-with-multiparty-channels-and-channel-factories</a> <a href="#jump-10">↩</a></p><p>11.<a id="note11"> </a><a href="https://www.btcstudy.org/2022/11/14/understanding-payment-channels/">https://www.btcstudy.org/2022/11/14/understanding-payment-channels/</a> <a href="#jump-11">↩</a></p><p>12.<a id="note12"> </a><a href="https://www.btcstudy.org/2023/06/29/tapleaf-update-verify-covenant-opcode-introduction/">https://www.btcstudy.org/2023/06/29/tapleaf-update-verify-covenant-opcode-introduction/</a> <a href="#jump-12">↩</a></p><p>13.<a id="note13"> </a><a href="https://www.btcstudy.org/2022/02/07/what-is-bitcoin-checktemplateverify/">https://www.btcstudy.org/2022/02/07/what-is-bitcoin-checktemplateverify/</a> <a href="#jump-13">↩</a></p><p>14.<a id="note14"> </a><a href="https://www.btcstudy.org/2023/11/28/op-evict-an-alternative-to-op-tapleafupdateverify-by-zmnscpxj/">https://www.btcstudy.org/2023/11/28/op-evict-an-alternative-to-op-tapleafupdateverify-by-zmnscpxj/</a> <a href="#jump-14">↩</a></p><p>15.<a id="note15"> </a><a href="https://www.btcstudy.org/2023/04/17/resizing-lightning-channels-off-chain-with-hierarchical-channels/">https://www.btcstudy.org/2023/04/17/resizing-lightning-channels-off-chain-with-hierarchical-channels/</a> <a href="#jump-15">↩</a></p><p>16.<a id="note16"> </a><a href="https://www.btcstudy.org/2021/10/12/statechains-non-custodial-off-chain-bitcoin-transfer/">https://www.btcstudy.org/2021/10/12/statechains-non-custodial-off-chain-bitcoin-transfer/</a> <a href="#jump-16">↩</a></p><p>17.<a id="note17"> </a><a href="https://www.btcstudy.org/2023/01/12/statechain-lightning-combined-in-bitcoin/">https://www.btcstudy.org/2023/01/12/statechain-lightning-combined-in-bitcoin/</a> <a href="#jump-17">↩</a></p><p>18.<a id="note18"> </a><a href="https://www.btcstudy.org/2023/07/21/simplest-ark-explanation-by-ruben-somsen/">https://www.btcstudy.org/2023/07/21/simplest-ark-explanation-by-ruben-somsen/</a> <a href="#jump-18">↩</a></p><p>19.<a id="note19"> </a><a href="https://www.btcstudy.org/2024/06/12/introducing-ark-v2/">https://www.btcstudy.org/2024/06/12/introducing-ark-v2/</a> <a href="#jump-19">↩</a></p>]]></content>
    
    
    <summary type="html">共享 UTXO 概念的基本元素及其应用效果</summary>
    
    
    
    
    <category term="joinpool" scheme="https://www.btcstudy.org/tags/joinpool/"/>
    
  </entry>
  
  <entry>
    <title>使用 ESP32 开发板自制 Jade 签名器</title>
    <link href="https://www.btcstudy.org/2024/08/20/produce-a-esp-32-board-based-jade-diy-without-camera/"/>
    <id>https://www.btcstudy.org/2024/08/20/produce-a-esp-32-board-based-jade-diy-without-camera/</id>
    <published>2024-08-20T15:15:00.000Z</published>
    <updated>2024-09-02T04:30:25.041Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Anony</em></p></blockquote><p>本文介绍了一种在 Windows 电脑上给 ESP32 开发板烧录固件、从而制作出 Jade-DIY 硬件签名器的方法。</p><p><img src="/../images/produce-a-esp-32-board-based-jade-diy-without-camera/Jade-DIY-T-Display.jpg" alt="Jade-DIY-T-Display"></p><h2 id="简介：DIY-的-Jade"><a href="#简介：DIY-的-Jade" class="headerlink" title="简介：DIY 的 Jade"></a>简介：DIY 的 Jade</h2><p>关于 Blockstream 公司推出的 Jade 硬件签名器，Mi Zeng 提供了一份<a href="https://www.btcstudy.org/2023/03/14/review-blockstream-jade-signer-by-mi-zeng/">详尽的评测</a>。该评测介绍了 Jade 硬件签名器的安全模型，以及一些具有特色的安全功能。</p><p>因为 Jade 的固件是完全开源的，我们只需基于与正式版 Jade 相同的硬件，就可以制作出功能相同的硬件签名器（在下文中，我们将分别称为 “正式版 Jade” 和 “Jade-DIY”）。</p><p>经过测试，我们发现，尽管某一些 Jade-DIY 在功能上无法做到与正式版 Jade 完全相同（下文就会讲到其中一个原因：硬件基础），但在安全特性上，Jade-DIY 跟正式版 Jade 是一样的。正式版 Jade 所具备的安全特性（如：“虚拟安全芯片”、自我擦除 PIN 码），Jade-DIY 都具有。这为 Jade-DIY 赋予了巨大的吸引力，因为可以使用相当便宜的硬件来制作签名器。</p><p>而且，Jade-DIY 在基本功能上非常扎实，绝不逊色于现在市场上主流的签名器。</p><h2 id="硬件挑选"><a href="#硬件挑选" class="headerlink" title="硬件挑选"></a>硬件挑选</h2><p>在 Jade 的 <a href="https://github.com/Blockstream/Jade">GitHub 库</a>中，有一个<a href="https://github.com/Blockstream/Jade/tree/master/diy">专门的页面</a>，介绍了可以制作成 Jade-DIY 签名器的硬件。读者需要关注的有两个方面：（1）是否配备摄像头，这也是该页面分类的依据；（2）硬件本身的 USB VendorID 和 ProductID 与正式版的 Jade 是否一致。</p><p>后者决定了当我们使用 USB 连接制作好的 Jade-DIY 时，软件钱包会不会将它识别成 Jade。如果不会，则使用起来会更麻烦。不过，这些硬件基本上都支持蓝牙，因此总可以使用蓝牙来连接签名器（如果软件签名器支持的话，比如移动端的 <a href="https://blockstream.com/green/">Green Bitcoin Wallet</a>）。此外，如果你选择使用配有摄像头的硬件，则总是可以使用 Air-gapped（隔空交互）的交互方式（主要就是扫码），因此不必再介意这个问题。</p><p><strong>本教程只针对没有摄像头的硬件</strong>。在这些硬件中，USB VendorID 和 ProductID 与零售正式版 Jade 一致的有（空格前是品牌名，空格后是型号）：</p><ul><li>LILYGO T-Display</li><li>M5Stack Basic Core</li><li>M5Stack FIRE</li></ul><p>出于经济性的考虑，笔者选择了 T-Display。在笔者购买之时，其本身的价格只需 65 元。读者在采购时，应注意不要与 T-Display S3 相混淆。笔者购买的是编号为 Q125 的版本，为使用便利，可以单独购买一个外壳（12 元）。<a href="https://github.com/epiccurious/jade-diy?tab=readme-ov-file#ttgo-t-display">据说</a>自带外壳的 K164 版本也可以制作成功。</p><p>下文就将以 T-Display 为示范。另外两款硬件与 T-Display 使用相同的芯片，因此其刷机流程的相似的。</p><h2 id="连接硬件"><a href="#连接硬件" class="headerlink" title="连接硬件"></a>连接硬件</h2><p>T-Display 的 USB 连接口是 Type-C 型的，读者应另外准备好 Type-C 的 USB 连接线。连接 T-Display 之后，观察其能否正常启动。正常情况下，它会先显示 “LILYGO” 的图标，然后出现 “SD card mount failed” 的警示语。</p><p>然后，打开 Windows 的 “设备管理器”，查看 “端口（COM 和 LPT）” 项下是否有 “USB-Enhanced SERIAL CH9102 (COM3)” 一项。如无，则说明未正常连接，应该安装<a href="https://www.wch.cn/downloads/CH343SER_EXE.html">驱动</a>。下载并安装驱动后，尝试再次连接。</p><p>如果你安装驱动后依然无法连接，请尝试换一根 USB 连接线（有一些连接线只有供电功能，而没有数据传输功能）。</p><p><img src="/../images/produce-a-esp-32-board-based-jade-diy-without-camera/Jade-DIY-1.png" alt="Jade-DIY-1"></p><blockquote><p>上面提到的两款 M5Stack 硬件与 T-Display 使用相同的 USBT 芯片，因此可以用相同的方式检验连接。</p></blockquote><h2 id="安装开发工具"><a href="#安装开发工具" class="headerlink" title="安装开发工具"></a>安装开发工具</h2><p>在<a href="https://dl.espressif.com/dl/esp-idf/">ESP-IDF 的网站</a>下载开发工具，请下载 “ESP-IDF v5.2.2 - Offline Installer”。打开安装程序后，在选择安装内容的页面，应该：（1）安装 “Powershell 支持”；（2）在 “Chip Targets” 中，至少安装 “ESP32” 和 “ESP32-S3”。（第一项 “Framework” 和第二项 “ESP-IDF 5.2” 一定不能省去）。</p><p><img src="/../images/produce-a-esp-32-board-based-jade-diy-without-camera/Jade-DIY-2.png" alt="Jade-DIY-2"></p><p>安装好之后，尝试在新的 PowerShell 窗口的菜单栏中，点击 “+” 号，选择 “ESP-IDF 5.2”，打开一个 ESP-IDF 环境。如果你的 PowerShell 窗口并不如图所示，则请尝试使用别的方式（比如 “开始” 菜单</p><p><img src="/../images/produce-a-esp-32-board-based-jade-diy-without-camera/Jade-DIY-3.png" alt="Jade-DIY-3"></p><h2 id="下载-Jade-源代码"><a href="#下载-Jade-源代码" class="headerlink" title="下载 Jade 源代码"></a>下载 Jade 源代码</h2><p>首先，请确保自己安装了 <a href="https://git-scm.com/download/win">Git 软件</a>。这是一种版本控制工具，可用于下载开源软件的源代码。</p><p>在一个你喜欢的文件夹中，打开 PowerShell 窗口，输入以下命令并运行：</p><pre><code>git clone --recursive https://github.com/Blockstream/Jade.git</code></pre><p>这行命令会新建一个 “Jade” 文件夹，并下载 Jade 源代码。</p><p>接下来是本教程最重要的章节。</p><h2 id="编译烧录固件"><a href="#编译烧录固件" class="headerlink" title="编译烧录固件"></a>编译烧录固件</h2><p>在烧录固件时，可以选择启用或不启用 “Secure Boot”。Secure Boot 的功能是给设备注入一个公钥，并要求烧入的固件具备该公钥的签名。如果烧入的固件不具备有效的签名，则设备会拒绝启动。这是一种有用的安全措施，可以防止自己的设备被他人注入带有恶意代码的固件。Jade 源代码库中的 DIY 指南也推荐启用 Secure Boot 功能。因此，本教程也强烈建议启用 Secure Boot 功能。</p><p>下文的 “实验性烧录” 章节将介绍不启用 Secure Boot 的烧录流程；顾名思义，这主要是为了让读者熟悉刷机的流程。而 “安全烧录” 将介绍启用 Secure Boot 的烧录流程。</p><p>注意，此处介绍的启用 Secure Boot 的操作是不可逆的，一旦启用，就无法取消。也即此后如果想要更新设备的固件，也必须使用相同的私钥、签名新的固件，才能刷入。弄丢这个签名固件的私钥将无法再给这个设备更新固件。</p><h3 id="提前准备"><a href="#提前准备" class="headerlink" title="提前准备"></a>提前准备</h3><p><strong>CMD 中的 Python3</strong></p><p>在开始烧录之前，请先打开电脑的 “命令提示符（CMD）”，输入 <code>python3</code> 并回车执行。如果它正确识别及执行，应该能在窗口中看到这样的信息：</p><pre><code>Python 3.12.3 (tags/v3.12.3:f6650f9, Apr  9 2024, 14:05:25) [MSC v.1938 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt;</code></pre><p>如果程序的反应是打开 Windows 商店，说明 CMD 在得到命令 “python3” 时无法正确识别并执行 python 的对应版本，这会导致后续编译中出现一个错误。必须修复这个错误。一种奇怪但有效的办法是在你的 Python 文件夹中复制 “python.exe”，并粘贴到同一文件夹，然后将副本重命名为 “python3.exe”。</p><blockquote><p>给出这个提醒是因为在笔者使用的两台 Windows 电脑（系统分别是 Win10 和 Win11）上，都出现了由此引发的编译错误。</p></blockquote><p><strong>ESP-IDF 运行环境的运行文件夹</strong></p><p>在任意文件夹中打开 “ESP-IDF 5.2” 运行环境；打开之后，它会自动运行一系列环境设置，以保证我们可以使用 ESP-IDF 的功能。运行成功后，它会输出一系列信息，末尾是这样的：</p><pre><code>Go to the project directory and run:    idf.py build</code></pre><p>ESP-IDF 的初始运行环境是其安装文件夹，比如说： <code>~\Espressif\frameworks\esp-idf-v5.2.2</code> ，我们需要使用 <code>cd</code> 命令，切换到 “Jade” 文件夹。假设你的 “Jade” 文件夹的地址是 <code>D:\esp\Jade</code>，那么就在 ESP-IDF 运行环境中输入：</p><pre><code>cd D:\esp\Jade</code></pre><p>最终，你的运行环境的开头应该是这样的：<code>PS D:\esp\Jade&gt;</code> 。</p><p><strong>OpenSSL</strong></p><p>为了生成足够安全的用于签名固件的私钥，请安装 <a href="https://slproweb.com/products/Win32OpenSSL.html">OpenSSL 软件</a>。</p><h3 id="实验性烧录"><a href="#实验性烧录" class="headerlink" title="实验性烧录"></a>实验性烧录</h3><p>在位于 “Jade” 文件夹的 ESP-IDF 运行环境中输入以下命令：</p><pre><code>cp configs/sdkconfig_display_ttgo_tdisplay.defaults sdkconfig.defaults</code></pre><p>这行命令的作用是从 “configs”文件夹中复制一个配置文件，到 “Jade” 文件夹中。需要复制的配置文件当然是因设备而定的，这里提供的是 T-Display 的配置文件。</p><blockquote><p>如果你使用的硬件是 “M5Stack Basic Core”，则命令要改成:</p><pre><code>cp configs/sdkconfig_display_m5blackgray.defaults sdkconfig.defaults</code></pre></blockquote><p>然后，运行以下命令：</p><pre><code>idf.py buildidf.py flash monitor</code></pre><p>第一行命令会将文件夹内的源代码编译成可以烧录进入 T-Display 的固件，第二行则实际写入，并在刷机成功后让 T-Display 重启。</p><p>以上就是实验性刷入的过程。你可以把玩一下，看看 Jade-DIY 的功能。</p><blockquote><p>如果你在刷机过程中出错，导致 T-Display 无法正常开机、也无法连接电脑，那么可以尝试<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32/get-started/flashing-troubleshooting.html">这个页面</a>介绍的操作：尝试先断开连接线，然后同时按住机身的三个按钮，然后重新连接电脑。</p></blockquote><h3 id="安全烧录"><a href="#安全烧录" class="headerlink" title="安全烧录"></a>安全烧录</h3><p><strong>生成配置文件</strong></p><p>在位于 “Jade” 文件夹的 ESP-IDF 运行环境中输入以下命令：</p><pre><code>./tools/mkdefaults.py ./configs/sdkconfig_display_ttgo_tdisplay.defaults NDEBUG SECURE</code></pre><p>运行后，在 “Jade” 文件夹里检查是否有 <code>sdkconfig</code>、<code>sdkconfig.defaults</code> 和 <code>sdkconfig.defaults.orig</code> 三个文件。</p><p>使用 “记事本” 打开 <code>sdkconfig.defaults</code> 文件，寻找其中是否有这几行：</p><pre><code>CONFIG_SECURE_BOOT=yCONFIG_ESP32_REV_MIN_3=y</code></pre><p>如果没有这几行内容，或者没有上述三个文件，请重复运行上述命令。</p><p><strong>生成签名固件的私钥</strong></p><p>然后，在 ESP-IDF 运行环境中运行以下命令、使用 OpenSSL 软件生成用于签名固件的私钥：</p><pre><code>openssl genrsa -out ../jade-diy-v2.pem 3072</code></pre><p>该行会在 “Jade” 文件夹的上级文件夹中生成一个名为 <code>jade-diy-v2.pem</code> 的私钥，该私钥将用在固件的签名中。</p><p>你可以使用别的文件名称，也可以指定另一个文件夹。但这就需要你回过头修改 <code>sdkconfig.defaults</code> 文件中 <code>CONFIG_SECURE_BOOT_SIGNING_KEY=</code> 一行中的相对地址。从便利和安全的角度出发，可以按上述命令生成私钥；在完成烧录后，将该私钥移动到其它相对隐蔽的地方；当以后需要升级固件时，再将私钥放回原位、签名固件并烧录。</p><p><strong>生成引导加载程序和固件</strong></p><p> 在 ESP-IDF 运行环境中运行以下命令：</p><pre><code>idf.py bootloaderidf.py build</code></pre><p>第一行会生成引导加载程序。该程序负责执行 Secure Boot 的功能。第二行则生成执行实际功能的固件。</p><p>在运行第一行命令时，程序可能无法成功运行，因为 <code>SDKCONFIG_DEFAULTS &#39;~/Jade/sdkconfig.defaults.tmp&#39; does not exist</code> 。这时候，往往只需再次运行上文 “<a href="#%E7%94%9F%E6%88%90%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">生成配置文件</a>” 一节中的命令，就可以生成所需的 <code>sdkconfig.defaults.tmp</code> 文件。 </p><p><strong>写入引导加载程序</strong></p><p>在启用 Secure Boot 之后，ESP-IDF 不会再自动刷入引导加载程序，因此，我们需要手动刷入。</p><p>在 ESP-IDF 运行环境中运行这条命令：</p><pre><code>esptool.py write_flash --erase-all 0x1000 ./build/bootloader/bootloader.bin</code></pre><p>在这里，<code>--erase-all</code> 的意思是清空闪存中的全部内容（如果你在此前尝试过实验性烧录，可能需要这个标签）；而后面的 <code>0x1000</code> 则代表写入闪存的位置，后面则是待写入的 引导程序的文件位置。</p><p>合理的写入位置可能因设备而不同，如果你并不使用 T-Display，请仔细阅读 <code>idf.py bootloader</code> 命令运行过程中出现在屏幕上的内容，它将提示你： <code>Secure boot enabled...</code>（启用了 Secure boot，因此引导程序不会自动烧录）；再下面就是一行能够执行的命令，包含 <code>python.exe</code>、<code>esptool.py</code> 字样。可以复制该行命令来代替上面这行命令，也可以在该行命令中找出 <code>0x</code> 开头的、表示闪存地址的字符，替换掉上文命令的 <code>0x1000</code> 然后执行。  </p><p>如果你无法运行这行命令，则你可能是未正确安装 <code>esptool</code>，可以尝试运行 <code>pip install esptool</code> 来解决。</p><p><strong>写入固件</strong></p><p>在 ESP-IDF 运行环境中运行以下命令：</p><pre><code>idf.py flashidf.py monitor</code></pre><p>在运行第二行时，如果长时间运行不结束，可以同时按下键盘上的 “Ctrl” 和 “]” 键主动结束。看看 T-Display（现在应该叫 “Jade-DIY” 了）能否正常启动。可尝试按下设备顶部的重启按钮。</p><p>安全烧录，完成！</p><h2 id="更新固件"><a href="#更新固件" class="headerlink" title="更新固件"></a>更新固件</h2><p>连接 Jade-DIY，在 “Jade” 文件夹下的 ESP-IDF 运行环境中，运行 <code>python jade_ota.py --noagent</code> 来更新固件。该过程可能需要安装一些 python 的依赖，使用 <code>pip install</code> 来解决。</p><p>目前，T-Display 可用的最新固件版本是 <code>1.0.31</code>，相对于正式版 Jade 的固件是落后的。</p><h2 id="操作指南"><a href="#操作指南" class="headerlink" title="操作指南"></a>操作指南</h2><ul><li>T-Display 机身一共有三个按键。在操作 Jade-DIY 时，机身顶部的按钮是 “重启” 键；单独按下机身的两个按钮，可以移动屏幕上的光标；确认选择时，则要同时按下这两个按钮。</li><li>在初始化 Jade-DIY（“Setup Jade”）时，Jade-DIY  会要求你设置一个 6 位数的数字 PIN 码。该 PIN 码在安全上极为关键。但是，要解锁、使用 Jade-DIY 时，必须先使用一款适配的软件钱包唤起 Jade-DIY，才能输入 PIN 码、解锁。<ul><li>这样的软件钱包有：桌面端：<a href="https://sparrowwallet.com/">Sparrow Wallet</a>、<a href="https://electrum.org/">Electrum Wallet</a>；移动端：<a href="https://blockstream.com/green/">Green Wallet</a>。Jade-DIY 可用 USB 连接电脑，用蓝牙连接手机。Jade-DIY 的蓝牙功能默认关闭，需要手动开启。</li></ul></li><li>连接到软件钱包后，使用体验就跟主流的硬件签名器没有多大区别。当需要签名交易时，交易的详细信息将在屏幕上显示。</li><li>解锁 Jade-DIY 之后，可以在 “Duerase PIN” 中设置 “自我擦除 PIN 码”。设置好之后，一旦在解锁时输入这个 PIN 码，将删除设备内的所有内容（包括加密的种子词）。</li><li>Jade-DIY 具备绝大多数 bitcoin-only 签名器的功能，单签、多签都不在话下。</li></ul><h2 id="安全分析"><a href="#安全分析" class="headerlink" title="安全分析"></a>安全分析</h2><p>Jade-DIY 的安全模型是什么样的？</p><p>在本教程中，笔者介绍了启用 Secure Boot 的刷机流程；Secure Boot 是一项非常重要的安全措施，可以应对 Jade-DIY 被注入恶意固件的风险。这种风险是真实的，目前，几乎所有的硬件签名器都提供了这一方面的防护（比如 Keystone，在升级固件的时候也会校验固件有无签名）。</p><p>应用 Secure Boot 之后，经过测试，我们认为 Jade-DIY 的安全性跟正式版 Jade 是一样的。那么正式版 Jade 的安全性又如何？</p><p>如本文开头提到的 <a href="https://www.btcstudy.org/2023/03/14/review-blockstream-jade-signer-by-mi-zeng/">Mi Zeng 的评测</a>所说的，Jade 以 “虚拟安全芯片” 的设计，来处理 “<a href="https://twitter.com/zengmi2140/status/1616069454772994049">安全芯片 vs. 开源</a>” 的取舍：在加密保存种子词的过程中，Jade 使用了来自一个远程服务器的密钥（与本地的 PIN 码共同加密种子词）。而在解锁 Jade 的过程中，只有提供设置好的 PIN 码，才能让适配的软件钱包跟远程服务器通信、获得这个密钥。（这也是为什么在使用其本身保存的种子词时，必须跟适配的软件钱包一起工作）。</p><p>因此，这种模式的安全性，是大于完全不使用安全芯片、也没有额外设计的硬件签名器的（比如较早版本的 Trezor 签名器）。</p><p>不过，与使用了安全芯片并附加了自毁机制（拆机自毁、无效 PIN 码输入达一定次数后自毁）的签名器相比，Jade 在应对设备被劫持之后的物理攻击时稍显不如。</p><p>总的来说，Jade-DIY 以较低的成本，提供了相当不错的安全性，也提供了足够强大的功能。</p><p>开源运动万岁！</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢 Mi Zeng 在本文撰写阶段给出的有益指引和探讨，当然，文中一切错误由我自己负责。</p>]]></content>
    
    
    <summary type="html">在 Windows 系统上为 ESP32 开发板刷入 Jade 固件</summary>
    
    
    
    
    <category term="实践" scheme="https://www.btcstudy.org/tags/%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>影响 0.21.0 以前版本 Bitcoin Core 软件的漏洞披露</title>
    <link href="https://www.btcstudy.org/2024/08/15/disclosure-of-vulnerabilities-affecting-bitcoin-core-versions-before-0210-0-21-0-bitcoin-core/"/>
    <id>https://www.btcstudy.org/2024/08/15/disclosure-of-vulnerabilities-affecting-bitcoin-core-versions-before-0210-0-21-0-bitcoin-core/</id>
    <published>2024-08-15T03:06:55.000Z</published>
    <updated>2024-09-02T04:30:25.021Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Optech</em></p><p><em>来源：<a href="https://bitcoinops.org/zh/newsletters/2024/07/05/">https://bitcoinops.org/zh/newsletters/2024/07/05/</a></em></p><p>本文来自 Bitcoin Optech Newsletter #310 的新闻部分。译本由 “Optech 中文翻译小组（<a href="https://github.com/PrimitivesLane/BitcoinOptechCN">BitcoinOptechCN</a>）” 提供。</p></blockquote><blockquote><p>原文总结了最近披露的影响 0.21.0 以前版本的 Bitcoin Core 软件的安全漏洞。为方便读者判定自己正在使用的软件版本的安全性，按照修复的时间倒序重新排列了漏洞的叙述。使用越新版本的用户需要严肃阅读的部分越少越靠前。</p><p>我们深知，软分叉哲学是比特币开发哲学的核心部分，它赋予了用户选择自己喜爱的共识规则的自由，因此，旧版本软件的安全性是所有人都应该捍卫的东西，如果没有它，软分叉哲学及其相应的自由就是一种空谈。但是，软件也像别的产品一样，有设计的使用周期，指望一款软件产品可以得到永续的安全维护是不现实的。因此，最终来说，全节点的运营者必须承担起判断的责任：在使用一款软件之前，评估其安全性，并随着信息的披露，更新自己的评估。</p></blockquote><p><strong>影响 0.21.0 以前版本 Bitcoin Core 的漏洞披露</strong>：Antoine Poinsot 在 Bitcoin-Dev 邮件组中<a href="https://mailing-list.bitcoindevs.xyz/bitcoindev/xsylfaVvODFtrvkaPyXh0mIc64DWMCchxiVdTApFqJ_0Q5v0bOoDpS_36HwDKmzdDO9U2RKMzESEiVaq47FTamegi2kCNtVZeDAjSR4G7Ic=@protonmail.com/">贴出</a>了一个链接，<a href="https://bitcoincore.org/en/security-advisories/">公布</a>了 10 个影响已经退役接近两年的 Bitcoin Core 软件版本的漏洞。我们将披露总结如下：</p><ul><li><p><a href="https://bitcoincore.org/en/2024/07/03/disclose-timestamp-overflow/">源自过量时间调整的网络分裂</a>：旧版本的 Bitcoin Core 允许自身的时钟被它连接到的前 200 个对等节点所报告的时间扭曲。这些代码本意是允许不超过 70 分钟的扭曲。所有版本的 Bitcoin Core 软件都会暂时无视带有超过本地时间 2 个小时以上的时间戳的区块。两个 bug 的组合，让攻击者可以让受害者的时钟倒拨两个小时以上，使之忽略掉带有准确时间戳的区块。该漏洞由开发者 practicalswift 尽责披露，并在 Bitcoin Core 0.21.0 中得到了修复。</p></li><li><p><a href="https://bitcoincore.org/en/2024/07/03/disclose_already_asked_for/">审查未确认的交易</a>：对等节点一般会通过交易的 txid 或 wtxid 来宣布新交易。在节点第一次看到一个 txid 或者 wtxid 时，它会从第一个宣布这笔交易的对等节点处请求完整的交易。在等待这个对等节点回复的时间里，节点也会跟踪其它宣布了相同 txid 或 wtxid 的对等节点。如果第一个对等节点不回复、直至超时，节点会从第二个节点处请求完整交易（如果再次超时，则转向第三个节点，以此类推）。</p><p>在 Bitcoin Core 0.21.0 之前，节点最多只会跟踪 50000 个请求。所以，第一个对等节点在宣布一个 txid 之后，可以推迟回复节点对完整交易的请求，等待该节点的其它对等节点都宣布该笔交易，然后发送 50000 条关于其它 txid 的宣布（可以都是假的 txid）。如此一来，当节点对第一个对等节点的完整交易请求超时后，它将不会再向其它任何对等节点请求完整交易。攻击者（第一个对等节点）可以无限重复这种攻击，从而永久阻止节点受到这比交易。请注意，这种对未确认交易的审查可以阻止交易迅速得到确认，这可能导致合约式协议（比如闪电通道）中的资金损失。John Newbery 引用了来自 Amiti Uttarwar 的共同发现，负责地披露了这个漏洞。修复措施在 Bitcoin Core 0.21.0 中放出。</p></li><li><p><a href="https://bitcoincore.org/en/2024/07/03/disclose-unbounded-banlist/">无限大小的禁止连接列表所带来的 CPU&#x2F;内存 DoS</a>：Bitcoin Core <a href="https://github.com/bitcoin/bitcoin/issues/15617">PR #15617</a>（首次包含在 0.19.0 中）添加了代码，使得在收到一条 P2P <code>getaddr</code> 消息时，检查被本地禁止连接的 IP 地址，最高可达 2500 次。节点的禁止连接列表的长度时不受限制的，如果一个攻击者控制了大量的 IP 地址（例如，易于获得的 IPv6 地址），这份列表会膨胀成巨大的规模。当这个列表变得很长的时候，每一次 <code>getaddr</code> 请求都可能消耗超量的 CPU 和内存，可能让节点不可用甚至崩溃。这个漏洞被编号为 <a href="https://nvd.nist.gov/vuln/detail/CVE-2020-14198">CVE-2020-14198</a>，在 Bitcoin Core 0.20.1 中得到了修复。</p></li><li><p><a href="https://bitcoincore.org/en/2024/07/03/disclose-bip70-crash/">尝试解析 BIP72 URI 而导致的内存崩溃</a>：0.20.0 以前的 Bitcoin Core 支持延伸了 <a href="https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki">BIP21</a> <code>bitcoin:</code> URI 的 <a href="https://bitcoinops.org/en/topics/bip70-payment-protocol/">BIP70 支付协议</a>、使用由 <a href="https://github.com/bitcoin/bips/blob/master/bip-0072.mediawiki">BIP72</a> 定义的参与 <code>r</code> 来引用一个 HTTP(S) URL。Bitcoin Core 会尝试从这个 URL 上下载文件，并存储在内存中等待解析，但是，如果这个文件大于可用的内存，Bitcoin Core 最终就会终止。当尝试下载在后台发生时，用户可能会走开，因此没有注意到节点的崩溃、也没有重启关键的服务。这个漏洞由 Michael Ford 尽责披露，并由 Bitcoin Core 0.20.0 通过移除 BIP70 支持的方式修复（见周报 <a href="https://bitcoinops.org/en/newsletters/2019/10/30/#bitcoin-core-17165">周报 #70</a>）。</p></li><li><p><a href="https://bitcoincore.org/en/2024/07/03/disclose-inv-buffer-blowup/">来自大体积 <code>inv</code> 消息的内存 DoS </a>：一条 P2P <code>inv</code> 消息可以包含一个高达 50000 个区块头哈希值的列表。在 0.20.0 版本以前，新式 Bitcoin Core 节点会为自己不理解的每一个哈希值回复一条单独的 P2P <code>getheaders</code> 消息，而这样的消息的体积将是约 1 kB。这导致节点会在内存中存储大约 50 MB 的消息，等待对等节点接收它们。每一个对等节点都可以这样做（而对等节点的数量默认可达大约 130 个），这就会在节点的常规内存要求之上额外使用超过 6.5 GB 的内存 —— 足以让许多节点崩溃。崩溃的节点可能无法处理为合约式协议的用户处理时间敏感的交易，可能导致用户损失资金。John Newbery 负责地披露了这个漏洞，并提供了一种修复措施：仅用一条 <code>getheaders</code> 消息来回复一条 <code>inv</code> 消息，无论后者包含了多少哈希值；此修复进入了 Bitcoin Core 0.20.0。</p></li><li><p><a href="https://bitcoincore.org/en/2024/07/03/disclose-getdata-cpu/">通过格式错乱的请求浪费 CPU 的 DoS</a>：在 Bitcoin Core 0.20.0 以前，攻击者或出故障的对等节点可以发送一种格式错乱的 P2P <code>getdata</code> 消息，导致处理消息的线程消耗 100% 的 CPU。（攻击发生后）在连接持续时间内，节点将不再能从攻击者处接收消息，虽然还能从诚实对等节点处收取消息。对于拥有少数 CPU 核心的节点来说，这可能只会造成一些小问题；在别处就会变成一种麻烦。John Newbery 负责地披露了这个漏洞并提供了一种修复措施；该措施进入了 Bitcoin Core 0.20.0。</p></li><li><p><a href="https://bitcoincore.org/en/2024/07/03/disclose-orphan-dos/">因处理孤儿交易而产生的 CPU DoS 以及节点卡顿</a>：Bitcoin Core 节点会跟踪 “<em>孤儿交易</em>” 的一个不超过 100 笔交易的缓存，对于这些交易，节点在交易池和 UTXO 集中还没有必要的父交易信息。在验证完一笔新交易之后，节点会检查孤儿交易中是否有某一个变得可以处理。在 Bitcoin Core 0.18.0 之前，每次检查孤儿交易缓存的时候，节点都会尝试使用最新的交易池和 UTXO 状态、验证每一笔孤儿交易。如果这 100 笔缓存的孤儿交易都被构造成需要大量的 CPU 来验证，节点可能会浪费超量的 CPU，可能因此无法处理新区块和新交易长达数小时。这种攻击基本上时免费的：孤儿交易时可以免费创建的，因为它们可以引用根本不存在的父交易。一个停滞的节点将无法生成区块模板，因此这种攻击可能会被用来阻止一个矿工获得收益，而且可以用来阻止交易得到确认、可能会导致合约式协议（例如闪电通道）的用户失去资金。开发者 sec.eine 尽责披露了这个漏洞；该漏洞在 Bitcoin Core 0.18.0 中修复了。</p></li><li><p><a href="https://bitcoincore.org/en/2024/07/03/disclose-header-spam/">使用低难度区块头的内存 DoS</a>：自 Bitcoin Core 0.10 以来，节点会请求其每一个对等节点来发它们所知的 <em>最佳区块链</em>（累积最多工作量证明的有效区块链）的区块头。这种方法的一个已知问题是，一个恶意的对等节点可以用大量低难度（例如，难度 1）的假冒区块头来轰炸节点，这样的区块头用先进的 ASIC 挖矿设备是很容易创建的。Bitcoin Core 最初的解决方法是仅接受与代码内硬编码的 <em>检查点</em> 相匹配的区块链上的区块头。最后一个检查点，虽然来自 2014 年，但以现在的标准来说也具有一个相对高的难度，所以它会要求大量地做功来创建假冒的区块头。但是，Bitcoin Core 0.12 加入的一项代码变更开始允许节点接受低难度的区块头进入内存，潜在地让攻击者可以用假冒区块头填满内存。这可以会导致节点宕机，并进一步导致合约式协议（比如闪电通道）的用户损失资金。Cory Fields 负责地披露了这个漏洞；该漏洞在 0.15.0 中修复。</p></li><li><p><a href="https://bitcoincore.org/en/2024/07/03/disclose_upnp_rce/">因 miniupnpc 而出现的远程代码执行漏洞</a>：在 Bitcoin Core 0.11.1（发布于 2015 年 10 月）以前的版本中，节点会默认启用 <a href="https://zh.wikipedia.org/wiki/UPnP">UPnP</a> 以允许通过 <a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">NAT</a> 的入站连接。这是使用 <a href="https://miniupnp.tuxfamily.org/">miniupnpc 库</a> 来实现的，而后者已被 Aleksandar Nikolic 发现具有多个可被远程攻击的漏洞（<a href="https://nvd.nist.gov/vuln/detail/CVE-2015-6031">CVE-2015-6031</a>）。这些流动在上游库中修复了，修复也进入了 Bitcoin Core，并且开发者们采取了一项更新：默认禁用 UPnP。在研究这个 bug 的过程中，Bitcoin 开发者 Wladimir J. Van Der Laan 发现了同一库中的另一个远程代码执行漏洞。该漏洞已得到<a href="https://bitcoinops.org/en/topics/responsible-disclosures/">尽责披露</a>，并已在上游库中修复，也进入到了 Bitcoin Core 0.12 中（发行于 2016 年 2 月）。</p></li><li><p><a href="https://bitcoincore.org/en/2024/07/03/disclose_receive_buffer_oom/">来自多个对等节点的大体积消息可造成节点崩溃</a>：在 Bitcoin Core 0.10.1 之前，节点对 P2P 消息的体积要求是不能超过（约）32 MB。并且，一直以来（直到现在），节点默认允许高达 130 个连接。如果每个对等节点都在几乎同一时间发送最大体积的消息，这会让节点需要在其它内存要求之上额外划出 4 GB 的内存空间，已经超过了许多节点能够提供的大小。这个漏洞是由 BitcoinTalk.org 论坛的用户 Evil-Knievel 尽责披露的，获得了编号 <a href="https://nvd.nist.gov/vuln/detail/CVE-2015-3641">CVE-2015-3641</a>，并且在 Bitcoin Core 0.10.1 中修复了，修复方法是将消息的体积限制在 2 MB 之下（后续又为了隔离见证升级而提高到约 4 MB）。</p></li></ul>]]></content>
    
    
    <summary type="html">运用你的判断力</summary>
    
    
    
    <category term="比特币主网" scheme="https://www.btcstudy.org/categories/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%BB%E7%BD%91/"/>
    
    
    <category term="尽责披露" scheme="https://www.btcstudy.org/tags/%E5%B0%BD%E8%B4%A3%E6%8A%AB%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>理解 Taproot Assets 协议</title>
    <link href="https://www.btcstudy.org/2024/08/08/understanding-taproot-assets-protocol-by-nayuta/"/>
    <id>https://www.btcstudy.org/2024/08/08/understanding-taproot-assets-protocol-by-nayuta/</id>
    <published>2024-08-08T10:16:05.000Z</published>
    <updated>2024-09-02T04:30:25.057Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Hiroki Gondo</em></p><p><em>来源：<a href="https://medium.com/nayuta-engineering-blog-en/understanding-taproot-assets-protocol-e2dfe3fc1e07">https://medium.com/nayuta-engineering-blog-en/understanding-taproot-assets-protocol-e2dfe3fc1e07</a></em></p></blockquote><p>Taproot Assets 协议（曾用名 “Taro”，下文缩写为 “TAP”）是一种在比特币上表示基于 UTXO 的资产的协议。本文致力于解释 TAP 是如何创建和转移资产的。</p><p>完整的协议分成许多部分。本文主要解释的是 bip-tap 和 bit-tap-ms-smt 。</p><ul><li><a href="https://github.com/Roasbeef/bips/blob/bip-tap/bip-tap-addr.mediawiki">bip-tap-addr</a></li><li><a href="https://github.com/Roasbeef/bips/blob/bip-tap/bip-tap-ms-smt.mediawiki">bip-tap-ms-smt</a></li><li><a href="https://github.com/Roasbeef/bips/blob/bip-tap/bip-tap-proof-file.mediawiki">bip-tap-proof-file</a></li><li><a href="https://github.com/Roasbeef/bips/blob/bip-tap/bip-tap-psbt.mediawiki">bip-tap-psbt</a></li><li><a href="https://github.com/Roasbeef/bips/blob/bip-tap/bip-tap-universe.mediawiki">bip-tap-universe</a></li><li><a href="https://github.com/Roasbeef/bips/blob/bip-tap/bip-tap-vm.mediawiki">bip-tap-vm</a></li><li><a href="https://github.com/Roasbeef/bips/blob/bip-tap/bip-tap.mediawiki">bip-tap</a></li></ul><p>Lightning Labs 作出的实现可见<a href="https://github.com/lightninglabs/taproot-assets">此处</a>。</p><h2 id="什么是-Taproot？"><a href="#什么是-Taproot？" class="headerlink" title="什么是 Taproot？"></a>什么是 Taproot？</h2><p>“<a href="https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki">Taproot</a>” 是一种新型的比特币输出，允许同时指定两种类型的花费条件：密钥花费（<code>Key Path</code>）和脚本花费（<code>Script Path</code>）。</p><p><img src="/../images/understanding-taproot-assets-protocol-by-nayuta/1_3ZjfJfqZlG3Sr8zCRpDO6g.png" alt="1_3ZjfJfqZlG3Sr8zCRpDO6g"></p><p><code>Key Path</code>，就像传统的 P2PKH 输出一样，使用一个公钥的签名来花费。在 Taproot 这里也可以使用 Schnorr 签名的密钥聚合（多签名）。</p><p><code>Script Path</code>，则像传统的 P2SH 一样，允许用一种脚本语言编程复杂的花费条件。并且 Taproot 还允许同时指定多个脚本。这些脚本不会直接序列化在 Taproot 输出中，而是会构造成一棵默克尔树、压缩成为一个根哈希值。当输出使用某个脚本来花费时，只需要暴露这一个脚本（而不需要曝光其它脚本）。</p><p>TAP 在 <code>Script Pat</code> 中嵌入数据（“资产树（Asset Tree）”）。这些数据在比特币节点看来是无法解读的，也检测不出来，因为经过了哈希。</p><p><img src="/../images/understanding-taproot-assets-protocol-by-nayuta/1_vHAqoqHoLHQ6DMZ-nFu5Og.png" alt="1_vHAqoqHoLHQ6DMZ-nFu5Og"></p><h2 id="Taproot-Assets-中的资产表示"><a href="#Taproot-Assets-中的资产表示" class="headerlink" title="Taproot Assets 中的资产表示"></a>Taproot Assets 中的资产表示</h2><h3 id="资产树"><a href="#资产树" class="headerlink" title="资产树"></a>资产树</h3><p>资产树是一种两级的 “稀疏默克尔总和树” 结构，表达 Taproot Assets 协议。底下的一级表示一种资产（由 “资产 id（<code>asset_id</code>）”  标识）的 UTXO。上一级则聚合来自下一级的树。</p><p><img src="/../images/understanding-taproot-assets-protocol-by-nayuta/1_ykcsSYt_mGNy8uhutO7K7g.png" alt="1_ykcsSYt_mGNy8uhutO7K7g"></p><p>上一级默克尔树的根哈希值（<code>asset_tree_root)</code>）的值会嵌入一个 Taproot 输出的 <code>Script Path</code> 中，从而承诺这棵树的状态。</p><p>资产的转移还创建一棵新的资产树，并且旧的那一棵也会更新。这可以通过发起新的一笔比特币交易、花费旧的资产树所在的 Taproot 输出来实现；没有满足规范的转移（例如，通胀、重复话费）会被认为是无效的。*</p><p>* 这里用到的方法是一种叫做 “<a href="https://scalingbitcoin.org/transcript/milan2016/client-side-validation">客户端验证</a>” 的概念；熟悉比特币的显著共识的读者可能会对这里的规范的正确性的基础感到好奇，但我会暂时忽略这个问题。</p><h3 id="稀疏默克尔总和树"><a href="#稀疏默克尔总和树" class="headerlink" title="稀疏默克尔总和树"></a>稀疏默克尔总和树</h3><p>“稀疏默克尔总和树”（以下将缩写为 “MS-SMT”）是默克尔树的一个变种，由 <a href="https://github.com/Roasbeef/bips/blob/bip-tap/bip-tap-ms-smt.mediawiki">bip-tap-ms-smt</a> 定义。因为其关键字是 256 比特的，所以它有 2^256 个叶子。绝大部分叶子是空的。</p><p>每个叶子都包含一个数量，而每个分支节点都承诺其子树上的叶子所表示的数量之和。即使一棵子树的内容不可知，只需检查分支节点，就可以知道该子树所包含的总数量。树根则承诺所有叶子所表示的总数量。</p><p>就像通用的默克尔树，只需一棵修剪过的、包含目标叶子的树，就可以提供这些目标叶子在树上的证明（默克尔证明）。但 MS-SMT 还支持 “不包含证明”。这是通过一种限制来实现的：表示不存在的关键字的叶子所包含的数量必须显式设定为一个表明其不存在（None）的值（因此，证明 “None” 的存在就构成了一种不包含证明）。因此，默认的 MS-SMT 会由 2^256 个表示 “None” 的叶子。</p><h3 id="资产叶子（资产-UTXO）"><a href="#资产叶子（资产-UTXO）" class="headerlink" title="资产叶子（资产 UTXO）"></a>资产叶子（资产 UTXO）</h3><p>资产树的低层 MS-MST 以 <code>asset_script_key</code> 作为关键字，以资产叶子作为值。每一个资产叶子都代表着该资产的一个 UTXO（为简洁，下文就直接表述为 “UTXO”*），并且，下列属性（包括可选的一个）会被序列化为 <a href="https://github.com/lightning/bolts/blob/master/01-messaging.md#type-length-value-format">“类型-长度-数值” 格式</a>。</p><p>* 不是比特币的 UTXO 哈。</p><ul><li><code>taproot_asset_version</code></li><li><code>asset_genesis</code></li><li><code>asset_id</code></li><li><code>asset_type</code></li><li><code>amt</code></li><li><code>lock_time</code></li><li><code>relative_lock_time</code></li><li><code>prev_asset_witnesses</code><br>- <code>prev_asset_id</code><br>- <code>asset_witness</code><br>- <code>split_commitment_proof</code></li><li><code>split_commitment</code></li><li><code>asset_script_version</code></li><li><code>asset_script_key</code></li><li><code>asset_group_key</code></li><li><code>canonical_universe</code></li></ul><p><code>asset_genesis</code> 就是推导出 <code>asset_id</code> 的原像。</p><p><code>asset_script_key</code> 既是资产叶子的关键字，也是一个 Taproot 形式的公钥（以一个独立于比特币的 <a href="https://github.com/Roasbeef/bips/blob/bip-tap/bip-tap-vm.mediawiki">tap-vm</a> 定义），并且是花费由该资产叶子表示的 UTXO 的条件。</p><p>在花费一个 UTXO 时，首先要满足（外部的）比特币花费条件，然后是（内部的）TAP 花费条件，由 <code>asset_script_key</code>指定，并且 <code>asset_script_key</code> 应该被 <code>prev_asset_id</code> 和 <code>asset_witness</code> 满足。举个例子，<code>asset_witness</code> 是被花费的 UTXO 的 <code>asset_script_key</code> 的签名。</p><p><img src="/../images/understanding-taproot-assets-protocol-by-nayuta/1_8yCJofequ55HYKSPG1Gb-Q.png" alt="1_8yCJofequ55HYKSPG1Gb-Q"></p><p>如果在一次资产转移中分割了 UTXO，也需要 <code>split_commitment</code> 和 <code>split_commitment_proof</code>。</p><p><code>split_commitment</code> 是一棵 MS-SMT，指代分割之后的所有 UTXO（在这个意义上，资产树其实有三层），而根中的和值是被转移的所有数量。</p><p><code>split_commitment_proof</code> 是 <code>split_commitment</code> 的一个默克尔证据，证明一次分割的存在。</p><p>在所有分割中，只有一个会有 <code>prev_asset_id</code>、<code>asset_witness</code> 和 <code>split_commitment</code>。所有其它分割只有 <code>split_commitment_proof</code>。所有的分割共享 <code>prev_asset_id</code> 和 <code>asset_witness</code>。</p><h2 id="资产创建"><a href="#资产创建" class="headerlink" title="资产创建"></a>资产创建</h2><p><img src="/../images/understanding-taproot-assets-protocol-by-nayuta/1_6Tu6LHxuI1gTzOIKHf04zg.png" alt="1_6Tu6LHxuI1gTzOIKHf04zg"></p><p>创建一种资产需要在一笔比特币交易的一个 Taproot 输出中嵌入一棵包含新资产的 UTXO 的新的资产树（该交易也就成为这种资产的创世交易）。资产的 ID（<code>asset_id</code>）以下列公式确定。</p><pre><code>asset_id := sha256(genesis_outpoint || sha256(asset_tag) || asset_meta_hash || output_index || asset_type)</code></pre><p><code>genesis_outpoint</code> 就是被这笔交易花费的前序交易输出，而 <code>output_index</code> 就是包含这棵资产树的输出的索引号。这保证了 <code>asset_id</code> 是全局唯一的。</p><p>新创建的资产 UTXO 省去了 <code>prev_asset_id</code> 和 <code>asset_witness</code>。 </p><h2 id="资产转移"><a href="#资产转移" class="headerlink" title="资产转移"></a>资产转移</h2><p>就像比特币 UTXO，资产转移时可能会合并或分割资产 UTXO。但我们先从一个简单的例子 —— 既没有分割，也没有合并 —— 说起 *。</p><p>* 下文的解释作了一些简化。比如，比特币交易的找零输出，就省去了。</p><p><img src="/../images/understanding-taproot-assets-protocol-by-nayuta/1_k9uQ2Brglnx-HOPaqVTupg.png" alt="1_k9uQ2Brglnx-HOPaqVTupg"></p><p>Alice 有 10 个某资产，全部转移给 Bob。</p><p>Alice 创建并广播一笔比特币交易，花费自己的资产 UTXO 所在的 Taproot 输出。这笔交易有两个 Taproot 输出。一个输出包含了一棵新的资产树，包含了一个新的拥有 10 个某资产、且 Bob 可以控制（比如使用 Bob 的比特币公钥）的 UTXO。另一个输出包含了一棵资产树，是由 Alice 控制的原版资产树移除对应的资产叶子后形成的。</p><p>属于 Bob 的新 UTXO 用 <code>prev_asset_id</code> 来索引 Alice 的前序 UTXO。在 <code>asset_witness</code> 中，放着前序 <code>asset_script_key</code> 的签名。而在这个新 UTXO 的 <code>asset_script_key</code> 中，放着一个新的、由 Bob 提前给出的公钥。</p><p>Bob 需要验证花费条件得到了满足，而且资产在转移后没有通胀，以确认接收这笔支付。</p><ul><li>Bob 新创建的资产树是否包含了一个满足花费条件的新的 UTXO ？</li><li>输入 UXTO 是否已经在 Alice 更新后的资产树上移除了？</li><li>交易中是否有别的 Taproot 输出？它们是否包含另一棵资产树？*</li><li>等等。</li></ul><p>这都是通过 证明&#x2F;验证 MS-SMT 的 包含&#x2F;非包含证据 以及 Taproot 输出的证据和原像来实现的。</p><p>* 如果另一个 UTXO 被添加到了另一棵资产树（而不是 Bob 的资产树）上，并且也花费了输入 UTXO，那就构成了重复花费。</p><h3 id="合并-UTXO"><a href="#合并-UTXO" class="headerlink" title="合并 UTXO"></a>合并 UTXO</h3><p><img src="/../images/understanding-taproot-assets-protocol-by-nayuta/1_2vwC4q_3DOb0R8fs7RXxJQ.png" alt="1_2vwC4q_3DOb0R8fs7RXxJQ"></p><p>Alice 有在两个叶子中分别有 3 个、7 个某资产，要全部转移给 Bob。</p><p>各个输入 UTXO 可以属于不同的资产树，或同一资产树上的不同关键字（<code>asset_script_key</code>）。Bob 的新 UTXO 应该为这两个花费掉的 UTXO 包含 <code>prev_asset_id</code> 和 <code>asset_witness</code>。</p><h3 id="分割-UTXO"><a href="#分割-UTXO" class="headerlink" title="分割 UTXO"></a>分割 UTXO</h3><p><img src="/../images/understanding-taproot-assets-protocol-by-nayuta/1_mmoYchmgOBsa_MUKPOlbwg.png" alt="1_mmoYchmgOBsa_MUKPOlbwg"></p><p>Alice 有 7 个某资产，准备转 3 个给 Bob。因此，Alice 会留下 3 个，Bob 会得到 7 个。</p><p>Alice 的找零 UTXO 将有 <code>prev_asset_id</code>、<code>asset_witness</code> 和 <code>split_commitment</code>；Bot 的新 UTXO 将仅有 <code>split_commitment_proof</code> *。</p><p>我不会再解释如何同时合并及分割 UTXO。</p><p>* 这跟<a href="https://github.com/Roasbeef/bips/blob/bip-tap/bip-tap.mediawiki">规范</a>的表述稍有区别，但似乎最新的<a href="https://github.com/lightninglabs/taproot-assets">实现</a>就是这么做的。</p><h3 id="资产流转"><a href="#资产流转" class="headerlink" title="资产流转"></a>资产流转</h3><p>虽然前面没有体积，但在资产转移可被验证之前，必须先验证每一个输入 UTXO 都是合法的。对于每一个输入 UTXO，必须 证明&#x2F;验证 从该资产的创世交易到如今这个输入、整个流转路径上的每一笔交易，都是正确执行的。</p><p><img src="/../images/understanding-taproot-assets-protocol-by-nayuta/1_6Z-NG7a7zjf1H7hGekaU6g.png" alt="1_6Z-NG7a7zjf1H7hGekaU6g"></p><p>这条路径是从创世交易到最新交易的一个复杂的图。在上图中，对 <code>Tx A</code>，需要验证所有蓝色的交易（其祖先交易）；而对 <code>Tx B</code>，需要验证所有蓝色和红色交易。这是重大的可扩展性挑战，因为历史会呈准指数级增长。</p><p>此外，因为验证所需的原像和证据是没有发布在区块链上的，如何在资产的发送者和接收者之间传递它们，也是一个问题。</p><h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><p>逐渐增加的历史是一个重大的可扩展性挑战。已经提出了多种解决方案，但支持闪电网络是最有希望的一个。链下的交易不会使历史增加。</p><p>这套协议是新的，规范也不完整。举个例子，我此前就指出了<a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021047.html">这个问题</a>。</p>]]></content>
    
    
    <summary type="html">本文致力于解释 TAP 是如何创建和转移资产的</summary>
    
    
    
    
    <category term="Taro" scheme="https://www.btcstudy.org/tags/Taro/"/>
    
  </entry>
  
  <entry>
    <title>Taproot Assets：协议、闪电网络兼容性</title>
    <link href="https://www.btcstudy.org/2024/08/07/taproot-assets-protocol-lightning-by-lightning-labs/"/>
    <id>https://www.btcstudy.org/2024/08/07/taproot-assets-protocol-lightning-by-lightning-labs/</id>
    <published>2024-08-07T04:06:40.000Z</published>
    <updated>2024-09-02T04:30:25.049Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Lightning Labs</em></p><p><em>来源：<a href="https://docs.lightning.engineering/the-lightning-network/taproot-assets">https://docs.lightning.engineering/the-lightning-network/taproot-assets</a></em></p></blockquote><p>“Taproot Assets”（曾用名 “Taro”）是一种新的协议，由 Taproot 赋能，用于在比特币系统内发行资产，且资产可在闪电网络内传输，实现及时、高容量、低手续费的交易。就其核心而言，Taproot Assets 利用了比特币网络的安全性和稳定性，以及闪电网络的速度、可扩展性和低手续费。</p><p>Taproot Assets 依赖于比特币最近的一次升级 Taproot；该升级引入了一种新的树型结构，允许开发者在一个比特币交易输出内嵌入任意的资产元数据。Taproot 还使用 Schnorr 签名来提升简洁性和可扩展性；而且，重要的是，它还能跟闪电网络中的多跳交易相结合。</p><p>纵观比特币的历史，许多提议致力于将资产带到比特币区块链上。Taproot Assets 依靠 Taproot 带来的力量，推进了这些提议背后的想法。在一种以 Taproot 为核心的设计中，Taproot Assets 可以在比特币和闪电网络上发行资产，而且更加隐私和可扩展。利用 Taproot Assets 协议发行的资产可以存入闪电通道中，让节点可以提供从比特币到资产的原子化互换。这让 Taproot Assets 可以跟广大的闪电网络互操作，从闪电网络的采用中受益并强化闪电网络的网络效应。</p><p>Taproot Assets 使用一种 “稀疏默克尔树（Sparse-Merkle Tree）” 结构来启用 见证&#x2F;交易数据 的快速、高效、隐私的检索和更新；并使用一种 “默克尔总和树（Merkle-Sum Tree）” 来证明 有效状态转换&#x2F;无通胀。资产可以通过链上交易来转移，也可以在存入闪电通道后通过闪电网络来转移。</p><p> Taproot Assets 交易的参与者承担验证和存储的成本（需要在本地（链下）存储空间内存储相关资产的见证数据），或者，可以使用名为 “Universes” 的信息仓库（类似于一个 git 仓库）。为检查一项资产的有效性，需要验证该资产自创世输出（状态）以来的流转。这是通过在 Taproot Assets gossip 层中接收交易数据的一个验证文件来实现的。客户端可以交叉检查自己的区块链副本，并在需要转移相关资产时修改自己的证据。</p><p>总结：</p><ol><li>允许在比特币区块链上发行资产</li><li>利用 taproot 来获得隐私性和可扩展性</li><li>资产可以存入闪电通道</li><li>资产可以在现有的闪电网络中转移</li></ol><p><a href="https://docs.google.com/presentation/d/1YgMG4MOjs5dHhlf77Zh0WOENXqB0JTV8ZarVjS8slyk">阅读更多：2022 年 4 月 Taproot Assets 的宣布演讲幻灯片</a></p><p><a href="https://www.youtube.com/watch?v=-yiTtO_p3Cw">观看：Taproot Assets: A new protocol for multi-asset Bitcoin and Lightning</a></p><h2 id="特性与局限性"><a href="#特性与局限性" class="headerlink" title="特性与局限性"></a>特性与局限性</h2><p>Taproot Assets 支持许多特性，让协议可扩展、健壮，并且对带宽和性能有限的移动设备友好。</p><ul><li>Taproot Assets 是轻客户端友好的：验证成本低，而且只需访问不必信任的比特币交易。Taproot Assets 并不需要对整条区块链的知识。</li><li>Taproot Assets 允许资产与比特币的原子化互换。</li><li>Taproot Assets 可以发行唯一资产、不唯一的资产以及收藏品。</li><li>Taproot Assets 允许创造性的多签名和联合签名安排。</li><li>Taproot Assets 通道可以跟 BTC 通道并存在同一个 UTXO 中，这使得 Taproot Assets 可以存在于闪电网络中，而不需要消耗额外的资源。举个例子，Alice 和 Bot 可以在一笔比特币交易中创建两条通道，一条是某种资产的通道，另一条是 BTC 通道。</li><li>未来可能引入的特性包括机密交易以及作为 Taproot Assets 转移的一部分的零知识证据。</li></ul><h2 id="Taproot-Assets-协议"><a href="#Taproot-Assets-协议" class="headerlink" title="Taproot Assets 协议"></a>Taproot Assets 协议</h2><p>Taproot Assets 主要是一种链上协议，资产会使用 taproot 交易发行在比特币区块链上。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>为理解 Taproot Assets，我们需要熟悉几个概念；有一些概念是比较新颖的，即使在比特币区块链的语境下。</p><p><a href="https://github.com/Roasbeef/bips/blob/bip-tap/bip-tap.mediawiki">阅读 BIP：Taproot Assets 协议</a></p><p>在这里学习基本概念：</p><ul><li><a href="https://www.cloudflare.com/en-ca/learning/ssl/how-does-public-key-encryption-work/">公钥密码学</a></li><li><a href="https://resources.infosecinstitute.com/topic/introduction-to-hash-functions/">密码哈希函数</a></li><li><a href="https://nakamoto.com/merkle-trees/">默克尔树</a></li><li><a href="https://mirror.xyz/0xaFaBa30769374EA0F971300dE79c62Bf94B464d5/Yetu-6pZkbQCOpsBxswn_7dGUZDxoBU8NrOQIZScwpg">比特币 UTXO</a></li></ul><p><strong>Taproot 交易</strong></p><p>Taproot 是由 <a href="https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki">BIP 341</a> 定义的一种新的比特币交易类型；从 2021 年 11 月开始， Taproot 在比特币区块链上完全激活。Taproot 交易相比传统的比特币交易，主要区别在于控制资金的脚本被包含在一个叫做 “tapScript 分支” 的树状结构中，而该结构是隐秘地承诺的。如果相关的 “密钥花费路径”（脚本）没有被用来移动资金，其内容就不必暴露。</p><p>传统的交易要求暴露整个脚本（不论用到的是脚本中的哪一部分），而 Taproot 交易则可以通过暴露一个公钥（及其有效签名）来避免暴露脚本；如果密钥花费路径不可用，也只需要揭晓被执行的脚本片段。所有其它没有用到的脚本路径都依然是私密的，或者也可以在链下选择性揭晓。</p><p>这使我们可以创建更加复杂的脚本；在密钥花费中，不需要付出在区块链上提交额外数据的额外成本；而且我们还可以高效验证一个修剪过后的脚本片段。在 Taproot Assets 的语境下，这让我们可以为一笔比特币交易可证地附加任意数据，且不需要在链上揭晓这些数据。</p><p><strong>承担到一个哈希值：Taptweak</strong></p><p>我们将这样包含了任意数据的交易叫做 “承诺”。一旦这样的交易被包含在某个区块中，我们就在其中承诺了一些数据，而且再也不能改变这些数据。</p><p>在承诺数据的时候，我们要使用一个叫做 “Taptweak” 的调整因子来扭曲我们的 Taproot 花费密钥的公钥。这让我们可以选择性揭晓被承诺的数据，而无需揭晓我们的私钥；或者，我们可以花费这个 taproot 输出而无需揭晓承诺。</p><p>在 Taproot 交易中，这种技术用来承诺脚本树（用树状结构组织起来的多段脚本）；实际上，这可以用来承诺任意数据。</p><ul><li><code>Q = P + H(P|c)G</code></li><li>Q 就是 Taproot 输出的最终的公钥</li><li>P 就是 Taproot 输出的 “内部公钥”</li><li>H(P|c) 是内部公钥以及数据承诺的哈希值</li></ul><p>在使用我们的私钥来签名 Taproot 输出的花费交易时，这个私钥（内部公钥的私钥）也需要用公钥和数据承诺的哈希值（H(P|c)）来扭曲。</p><p><a href="https://bitcoinmagazine.com/technical/taproot-coming-what-it-and-how-it-will-benefit-bitcoin">阅读：Taproot 即将到来：它是什么，如何有益于比特币</a></p><p><a href="https://bitcoinops.org/en/schorr-taproot-workshop/">观看：Bitcoin Optech Schnorr Taproot 研讨会</a></p><p><strong>稀疏默克尔树</strong></p><p>“稀疏默克尔树（SMT）” 是一种数据结构；使用它的时候，可以证明特定数据并不存在于一棵默克尔树中（“稀疏” 在此处意味着 “稀稀落落”）。SMT 是一种经过认证的 键-值对 存储（authenticated key-value store），意思是，树上叶子的关键字（key）（或者说其位置）与其内容是相互绑定的。</p><p>为了实现这种属性，叶子的内容会被哈希、创建出一棵默克尔树，并且叶子的位置正对应着其哈希摘要的位图（bitmap）。必然地，这会需要一棵 256 层的树，它会有 2^256 个叶子。生成这样的树是高效的，尽管看起来体积很大，因为绝大部分的分支包含的都是空的叶子，可以用 nil 哈希值来代表。</p><p><img src="/../images/taproot-assets-protocol-lightning-by-lightning-labs/constructing-a-sparse-merkle-tree.png" alt="constructing-a-sparse-merkle-tree"></p><p style="text-align:center">- 构造一棵稀疏默克尔树 -</p><p>举个例子，我们可以使用一种虚构的哈希函数 sha002 来创建一棵稀疏默克尔树；sha002 的输出是 0 跟 3 之间的数字。于是，我们创建出的稀疏默克尔树就有 4 个叶子：0、1、2 和 3。只有叶子 2 是有内容的，所有其它叶子都是空的。为了找到叶子 2（其二进制表示是 “10”），我们只需在第一步中选择右边的分支（1），然后在第二步中选择左边的分支（0）。</p><p><img src="/../images/taproot-assets-protocol-lightning-by-lightning-labs/identifying-leaves-in-a-sparse-merkle-tree.png" alt="identifying-leaves-in-a-sparse-merkle-tree"></p><p style="text-align:center">- 定位一棵稀疏默克尔树中的一个叶子 -</p><p>要验证叶子 2 的内容，我们只需要揭晓这个叶子中的数值、叶子 3 的哈希值，以及分支 0 的哈希值，即可。</p><p>在稀疏默克尔树中，每一个叶子都可以描述成一个指南，可以通过一张表示成二进制形式的地图找到自己。这张地图就是这棵稀疏默克尔树本身，而这个指南可以表示成在每一个分叉路口应该转左还是转右的指令。举个例子，在一棵 2^4 大的稀疏默克尔树上，第 10 个叶子可以用二进制表示成 1001，意味着我们只需先走右边、然后走左边、再走左边，最后走右边，就可以找到对的那个叶子。</p><p>这种属性，在构造和重构稀疏默克尔树的时候是极为有用的，因为它准确描述了我们要重新构造稀疏默克尔树的哪一部分。更重要的是，每个叶子中的数据，都可以用叶子在树上的位置来描述。</p><p>使用稀疏默克尔树，我们可以将数据与公开的关键字关联起来，并以易于验证的方式证明我们已经删除了这个数据，而无需揭晓整棵树。</p><p><img src="/../images/taproot-assets-protocol-lightning-by-lightning-labs/inserting-an-item-into-a-spare-merkle-tree.png" alt="inserting-an-item-into-a-spare-merkle-tree"></p><p>因为每一个数据都有自己预先确定的位置，所以树的根哈希值独立于这些数据插入树的顺序。</p><p><a href="https://ethresear.ch/t/plasma-cash-plasma-with-much-less-per-user-data-checking/1298">亦见：Plasma Cash</a></p><p><strong>默克尔总和树</strong></p><p>“默克尔总和树” 是一种默克尔树，其每个叶子都包含了一个数字值，并且树上每个节点都包含其下面的叶子的数字值之和。所以，默克尔总和树的根就是所有叶子的数字值之和。</p><p>因为承诺了跟叶子相关联的数量，默克尔总和树允许状态转换（无通胀）的高效验证。</p><p><a href="https://blog.bitmex.com/addressing-the-privacy-gap-in-proof-of-liability-protocols/">亦见：使用默克尔总和树生成债务证明</a></p><p><strong>结合 taproot、taptweak、稀疏默克尔树和默克尔总和树</strong></p><p>Taproot Assets 协议使用了上述概念的结合，以支持发行原生于比特币区块链的资产。稀疏默克尔树和默克尔总和树会结合成稀疏默克尔总和树。</p><p>这棵树的根值会被添加到一个 taproot tapscript 中，然后参与一个 taproot 地址的创建。</p><p>Taproot Assets 没有自己的区块链，资产的发行者会在链下存储稀疏默克尔总和树，然后以协议外的通信方式为资产持有者发放资产证明。这样的资产的持有者可以独立验证自己的账户被包含在了树中，并且携带了正确的数量；对应的一笔 taproot 交易存在，并已经被比特币区块链确认。</p><p><a href="https://github.com/Roasbeef/bips/blob/bip-tap/bip-tap-ms-smt.mediawiki">阅读 BIP：稀疏默克尔总和树</a></p><h3 id="发行资产"><a href="#发行资产" class="headerlink" title="发行资产"></a>发行资产</h3><p><strong>资产 ID</strong></p><p>要发行一种 Taproot Assets 资产的时候，我们先要创建该资产的标识符。我们创建一个 32 字节的资产 ID，这是用三个元素哈希出来的：即将被花费以铸造这种资产的输出点（outpoint）（译者注：可以理解为 UTXO 的编号）、铸造者选定的一种资产标签（例如，其品牌名的哈希值），以及跟这种资产相关的元数据，例如网站、图片和文档。</p><pre><code>asset_id = sha256(genesis_outpoint || asset_tag || asset_meta)</code></pre><p><strong>资产脚本（Asset Script）</strong></p><p>资产脚本可以有输入和输出，类似于比特币交易。新创建的资产不包含任何 Taproot Assets 输入，但资产的转移会有。</p><p>资产脚本的输出定义了新创建的资产会被发放给谁。更准确地说，这是通过一棵稀疏默克尔总和树来实现的：在树上，每个账户都用其 256 比特的关键字来辨识，跟这个关键字对应的叶子包含了关于这个账户拥有的数量的信息。</p><p>可以在一笔比特币交易中发行多项资产，但每一种资产都有自己单独的资产脚本以及其中的稀疏默克尔树。资产可以是唯一的，也可以是不唯一的。</p><p><a href="https://github.com/Roasbeef/bips/blob/bip-tap/bip-tap-vm.mediawiki">阅读 BIP：Taproot Asset 脚本</a></p><p><strong>资产叶子</strong></p><p>每一个叶子都包含一个 TLV（类型、长度、数值）数据，类似于用在闪电网络中的 TLV。它包含了一些信息（例如版本、资产 id、数量），还有与这项资产的以往流转有关的数据（例如签名）。</p><p><strong>承诺到树根</strong></p><p>生成了稀疏默克尔总和树和资产脚本之后，我们就可以扭曲我们的内部公钥、获得这个合约的地址并敲定这笔交易。</p><p><strong>发布交易</strong></p><p>发布这笔交易并让它得到比特币区块链的确认之后，我们就不可逆地创造了一种资产。对其他人来说，这笔交易看起来跟其它标准的 taproot 交易没有区别。</p><p><strong>资产证明</strong></p><p>资产发行者现在可以选择性地揭晓自己创建了什么资产，以及这些资产被分配给了谁。最重要的是，发行者可以向接收者证明一项资产已经转移给了他们，办法是揭晓一个具体的资产证明，包括资产的脚本，以及接收者账户作为关键字的叶子的稀疏默克尔总和树的路径。</p><p><img src="/../images/taproot-assets-protocol-lightning-by-lightning-labs/proving-non-inclusion-in-a-sparse-merkle-tree.png" alt="proving-non-inclusion-in-a-sparse-merkle-tree"></p><p style="text-align:center">- 证明稀疏默克尔树上不包含某个状态 -</p><h3 id="转移资产"><a href="#转移资产" class="headerlink" title="转移资产"></a>转移资产</h3><p>Taproot Assets 资产可以在链上转移，也可以用来开启闪电网络通道。在这一节，我们只讨论以链上交易转移。</p><p>Taproot Assets 协议并不规定各资产账户的持有者之间如何交互，这件事交给各个应用。发行者在定义资产的性质或者说约束资产的意图上享有灵活性。</p><p>资产根承诺（Asset Root Commitment）承诺了树上持有的所有资产以及它们的总和。资产 id 是全局唯一的，因为它取决于其创世输出的标识符。整个树根可以包含多个资产 id，资金的保护是通过验证资产树根（asset_tree_root）来实现的。</p><pre><code>asset_tree_root = sha256(asset_id || left_hash || right_hash || sum_value)</code></pre><p><strong>Taproot Assets 地址</strong></p><p>Taproot Assets 地址是 bech32m 编码的标识符，编码了资产 ID、资产脚本的哈希值、稀疏默克尔总和树的内部公钥、数量，以 “Taproot Assets” 或 <code>taptb1</code>（测试网）为前缀。</p><pre><code>bech32(hrp=TapHrp, asset_id || asset_script_hash || internal_key || amt)</code></pre><p>资产的发行者，或者资产的持有者，可以使用 Taproot Assets 地址中的这些信息，来创建或修改对应的稀疏默克尔总和树（下文讲述）。这种地址格式也可以用来请求对某地址持有某数量的一个具体证明。</p><p><a href="https://github.com/Roasbeef/bips/blob/bip-tap/bip-tap-addr.mediawiki">阅读 BIP：Taproot Assets 链上地址</a></p><p><strong>在树内转移资产</strong></p><p>为转移 Taproot Assets 资产，接收者将自己的地址发给自己的交易对象：可以发起转移的资产当前持有人。资产持有者跟发行者之间的具体交互现在还没有严格定义。可以留给各应用甚至资产的发行者来指定。</p><p>资金的发送者需要创建一棵新的稀疏默克尔总和树，反映新的余额。这是通过减少特定叶子的余额、增加另一个叶子的余额来实现的。稀疏默克尔总和树保证了在这样一笔交易中，不会创建新的资产（不会通胀），并且发送者对这项资产的索取权已被完全放弃。</p><p><img src="/../images/taproot-assets-protocol-lightning-by-lightning-labs/identifying-accounts.png" alt="identifying-accounts"></p><p style="text-align:center">- 定位账户 -</p><p>创建资产需要一笔链上的 taproot 交易，但可以铸造多少资产以及多少账户可以持有这些资产则并没有限制。为转移资产，如上所述，需要重组默克尔树并发布新的一笔链上交易。一笔链上交易可以反映多少内部 Taproot Assets 交易也没有限制。</p><p>使用这种方法，资金被分配给账户持有者，表示成稀疏默克尔总和树上的叶子，但发起这样的内部转移的能力限制在 taproot 内部私钥的所有者手上。</p><p><img src="/../images/taproot-assets-protocol-lightning-by-lightning-labs/taproot-asset-trees.png" alt="taproot-asset-trees"></p><p style="text-align:center">- 用在 Taproot Assets 协议中的多种树结构的概览 -</p><p><strong>Universe</strong></p><p>“Universe” 是一项服务，提供关于资产的信息以及给资产持有者的证据。它就像比特币的区块浏览器，但展示的是 Taproot Assets 交易数据，这些数据本身是 Taproot Assets 协议客户端在链下存储的。主要区别在于，因为与 Taproot Assets 相关的绝大部分信息都是链下的，所以更容易隐藏。</p><p>Universe 可以由资产的发行者自己运行，也可以由发行者另外指定。自发运行聚合了由资产持有者提交的信息的的 Universe 也是便利的。</p><p>举个例子，给定一个资产 ID，Universe 可以提供关于其创世输出的信息，以及当前的元信息（例如文档、资产脚本以及流通中的总数）。服务端可以知道多项资产（Multiverse），也可以仅知道一个输出（Pocket Universe）。</p><p>Universe 在 Taproot Assets 协议中没有特权。它提供可用比特币区块链验证的教育处数据。恶意的 Universe 只能拒绝返回客户端请求的数据。Taproot Assets 交易数据跟 Universe 不是绑定的。Universe 提供的数据可得性产品是由希望快速、便宜地验证自己的资产的用户激励的。</p><p><a href="https://github.com/Roasbeef/bips/blob/bip-tap/bip-tap-universe.mediawiki">阅读 BIP：Taproot Asset Universes</a></p><p><strong>资产的合并与分割</strong></p><p>资产可以在其自身的稀疏默克尔树上内部转移（如上所述），也可以发送给另一个 taproot 密钥持有者。这叫做资产的分割。</p><p>在资产分各种，发送者也需要更新自己的 taproot 输出的稀疏默克尔总和树：调整余额并重新计算默克尔根。在资产合并的情形中，树根中的和也会改变。</p><p>此外，这会产生另一棵稀疏默克尔总和树、承诺到一个新的 taproot 输出中。这棵默克尔树由资产的接受者计算，过程跟上面案例中的发行者类似，区别在于，这种资产不是凭空创建出来的，而是从一个前序输出（比如这种资产的创世输出）中分割出来的。</p><p><strong>资产证明</strong></p><p>为验证资产分割已经发生，新的 Universer 的操作者需要下列证据：</p><ul><li>资产在交易 t0 中创建</li><li>资产存在于 t0 中的原版默克尔树中的某个叶子中</li><li>该叶子的余额在交易 t1 中设为 0</li><li>资产存在于 t1 中的新默克尔树的一个叶子中</li></ul><p>资产分割完成后，资产的所有人就可以像发行者一样，执行内部交易。而在分割之前，总是需要包含发行证明，用作流转验证。</p><p>资产证明的规模会随着用到的链上交易的增加而线性增长。每一种资产交易都需要追溯到创世输出以完成审计。一个资产证明仅在其索引到的链上输出是为花费输出时，才是有效的。</p><p><strong>无效资产</strong></p><p>如果一项资产所在的 taproot 输出被花费掉了，而这项资产有没有承诺到一棵新的稀疏默克尔总和树中，那么就认为它已经成了一项无效的资产的。这对第三方观察者来说是不明显的，而且在一些情境中，可能更好的做法是将资产承诺到一棵新的、空的默克尔树上，以证明这项资产已经毁掉了、作废掉了，或者说 “烧掉” 了。</p><p><a href="https://github.com/Roasbeef/bips/blob/bip-tap/bip-tap-proof-file.mediawiki">阅读 BIP：Taproot Assets Flat File Proof Format</a></p><h2 id="Taproot-Assets-进入闪电网络"><a href="#Taproot-Assets-进入闪电网络" class="headerlink" title="Taproot Assets 进入闪电网络"></a>Taproot Assets 进入闪电网络</h2><p>Taproot Assets 协议描述了如何在比特币区块链上发行资产。这些资产可以存入 “<a href="https://docs.lightning.engineering/the-lightning-network/payment-channels/lifecycle-of-a-payment-channel">闪电网络支付通道</a>” 中，实现即时转移。</p><p>这一原理让闪电网络的用户可以在自己的钱包中持有不同于 BTC 的资产：比如说，稳定币。它们可以接收以稳定币计价的支付，并通过闪电网络使用稳定币来为商品和服务支付。</p><p>比特币依然是闪电网络的骨架，而 Taproot Assets 资产的支付可以通过现有的比特币闪电网络来路由，无需升级、切换。当比特币为这些以其它资产计价的支付提供流动性时，路由节点的运营者就可以收到以聪支付的更多路由费。 </p><h3 id="启用-Taproot-Assets-的通道"><a href="#启用-Taproot-Assets-的通道" class="headerlink" title="启用 Taproot Assets 的通道"></a>启用 Taproot Assets 的通道</h3><p>Taproot Assets 通道的创建方式跟当前比特币通道的创建方式是相似的。在这些可以觉察 Taproot Assets 支付的通道中，可以构造 <a href="https://docs.lightning.engineering/the-lightning-network/multihop-payments/hash-time-lock-contract-htlc">HTLC</a> 来协助支付，就像转移比特币一样。</p><p>资产会通过创建在通道承诺交易中嵌套的 HTLC 来转移；在需要的时候，HTLC 中的价值可以被接收者通过揭晓一个<a href="https://docs.lightning.engineering/community-resources/glossary#preimage">原像</a>来申领，也可以由发送者在超时之后取回。这些交易是闪电通道中的比特币交易的 Taproot Assets 等价物。</p><p><strong>多跳的 Taproot Assets 资产转移</strong></p><p>历史上，支付网络都挣扎于冷启动问题 —— 只要创建一种新的资产，就需要建立一个全新的支付网络，以服务于这种资产的支付需求。Taproot Assets 支持一种支付路由模式，让闪电网络可以处理带有任何资产的通道，同时具有跨不同资产发现支付路径的能力。闪电通道中的 Taproot Assets 资产可以通过广大的闪电网络来转移。举个例子，在整条支付转发路径上所有参与者都具有流动性的情形中，它们可以选择用比特币还是被转移的 Taproot Assets 资产来收取路由费。</p><p>即使没有这样全面支持 Taproot Assets 的路径，比特币路径也可以担当起来，只要第一个节点愿意用聪来转发相关 Taproot Assets 资产的价值。这也可以让闪电网络可以协助比特币与 Taproot Assets 资产的交换。这也允许支付的接受者自选使用 Taproot Assets 资产（而不是比特币）来接收支付。在下面的例子中，Bob 和 Carol 都可以作为这样的边缘节点，将支付过来的 L-USD 换成 BTC 。</p><p><img src="/../images/taproot-assets-protocol-lightning-by-lightning-labs/an-example-of-a-taproot-assets-payment-made-to-the-wider-lightning-network.png" alt="an-example-of-a-taproot-assets-payment-made-to-the-wider-lightning-network"></p><p style="text-align:center">- 通过广大的闪电网络来发起 Taproot Assets 支付的一个例子 -</p><p>这也使得我们可以接收 Taproot Assets 资产但把对应的发票交给其它任何闪电钱包 —— 即使它们并没有集成 Taproot Assets 协议 —— 它们可以用 BTC 来支付发票。</p><p>这让闪电发票保持作为标准方案的地位。一个最终用 Taproot Assets 结算的发票可以用 BTC 或任何其它资产来支付；并且，任何拥有 Taproot Assets 余额的人都可以支付任何闪电发票。</p><p><img src="/../images/taproot-assets-protocol-lightning-by-lightning-labs/an-example-of-a-taproot-assets-payment-in-which-the-receiver-opts-to-receive-the-same-asset-type.png" alt="an-example-of-a-taproot-assets-payment-in-which-the-receiver-opts-to-receive-the-same-asset-type"></p><p style="text-align:center">- 接收者选择用同一种资产接收一笔 Taproot Assets 支付的案例 -</p><h3 id="汇率"><a href="#汇率" class="headerlink" title="汇率"></a>汇率</h3><p>Taproot Assets 协议自身为集成节点提供了处理汇率的选择。在通道中处理互换的两个对等节点自主决定汇率。他们可能使用来自高流动性交易所的参考汇率，或者自己决定。重要的是，在接收支付时，发票是由接受者自己生成的，这就保证了它能收到合适数量的想要资产。</p><p>任何能够感知 Taproot Assets 通道的闪电网络节点都可以作为这样的 “边缘节点（Edge node）”。他们在转发和互换的手续费上相互竞争。这些手续费包括路由费和互换手续费（也可以说是差价）。</p><p>在创建发票时，接受者（例如下面这个例子中的 Zane）和自己的对等节点（例如 Yana）先对汇率达成一致。他们使用这个双方同意的价格来生成一张常规的闪电网络发票，并将发票交给支付者；发票就包含了转发提示和通道的条款。</p><p>当支付这通过自己构造的支付路径传递支付时，支付会抵达 Yana，而 Yana 会转发 L-EUR 给 Zane。在释放原像之前，Zane 的钱包会检查自己是否收到了预期数量的 L-EUR。</p><p>在通过 L-USD 来支付以聪标价的发票时，Alice 必须跟 Bob 对最新的汇率和手续费达成一致。她可以确认支付、将对方要求的 L-USD 加上手续费转递给对方，而接受者只会在收到了自己想要数量的聪时才会释放原像。</p><p><img src="/../images/taproot-assets-protocol-lightning-by-lightning-labs/sender-and-recipient-do-not-need-to-transact-in-the-same-asset-type.png" alt="sender-and-recipient-do-not-need-to-transact-in-the-same-asset-type"></p><p style="text-align:center">- 发送者和接受者无需使用同一种资产 -</p><p>如果边缘节点担心自己的流动性被滥用，可以使用其它工具，例如关闭某一条通道、减低发票的有效性或提高差价。</p><p>Taproot Assets 协议不会管制或设定汇率，只会提供有用市场所需的机制，保证进入的低技术门槛，支持自动化、原子化并且即时的转发。</p>]]></content>
    
    
    <summary type="html">一种由 Taproot 赋能的协议，用于在比特币系统内发行资产，且资产可在闪电网络内传输，实现及时、高容量、低手续费的交易。</summary>
    
    
    
    
    <category term="Taro" scheme="https://www.btcstudy.org/tags/Taro/"/>
    
  </entry>
  
  <entry>
    <title>关于我创建的一笔奇怪的交易</title>
    <link href="https://www.btcstudy.org/2024/07/31/definitive-explanation-of-my-weird-bitcoin-transaction/"/>
    <id>https://www.btcstudy.org/2024/07/31/definitive-explanation-of-my-weird-bitcoin-transaction/</id>
    <published>2024-07-31T15:10:18.000Z</published>
    <updated>2024-09-02T04:30:25.021Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Vojtěch Strnad</em></p><p><em>来源：<a href="https://stacker.news/items/600187">https://stacker.news/items/600187</a></em></p></blockquote><blockquote><p>译者注：本文介绍的是一笔特意制作的奇怪交易，展现了比特币协议自身的复杂性和灵活性。</p></blockquote><p>如果你经常逛 Twitter 或 Stacker News，那么你可能会留意到，人们讨论了主网上出现的一笔奇怪的比特币交易：</p><p><a href="https://mempool.space/tx/b10c0000004da5a9d1d9b4ae32e09f0b3e62d21a5cce5428d4ad714fb444eb5d">https://mempool.space/tx/b10c0000004da5a9d1d9b4ae32e09f0b3e62d21a5cce5428d4ad714fb444eb5d</a></p><p><img src="/../images/definitive-explanation-of-my-weird-bitcoin-transaction/38308.png" alt="38308"></p><p>它吸引了很多人的关注，人们迫切想知道：是谁制作了这笔奇怪的交易？它隐藏着什么秘密？</p><p>让我来揭晓这两个问题的答案。</p><p>消息：</p><pre><code>Transaction b10c0000004da5a9d1d9b4ae32e09f0b3e62d21a5cce5428d4ad714fb444eb5d was created by Vojtěch Strnad.</code></pre><p>地址：</p><pre><code>1J7SZJry7CX4zWdH3P8E8UJjZrhcLEjJ39</code></pre><p>签名：</p><pre><code>H6WHgwnYtggJH5yqVpeL9NRxWJ+8hqUW31Mc1J9e9Q3cZGEdDjixYT6jnPpIHM2FVHDbeEstP8KzDsj5U01BNSo=</code></pre><p>如果你想自己验证一下这个签名（我非常建议这么做哦），请不用在酒店 Wi-Fi 下使用 Bitcoin Core 或 Electrum 哦。</p><p>搞定这个事情之后，我们就要揭晓这笔交易中的每一个彩蛋了。其中最后两个，就我所知，到我写这篇文章的时候也还没有任何人注意到：</p><ul><li>该交易被区块 850000 首次确认。</li><li>该交易的 locktime 是比特币创世区块的时间戳。（译者注：locktime 是交易层面的绝对时间锁的实现方法；在此处，其含义是该笔交易仅在创世区块出现后才能被确认。）</li><li>这笔交易有一个浮夸的 TXID 和 WTXID。TXID 的开头是 <code>b10c0000004da5...</code> ，是比特币开发者 0xB10C 的个人主页，他曾经制作过一笔有类似 TXID 的交易（见：<a href="https://b10c.me/7">https://b10c.me/7</a> ）。而 WTXID 的开头是 <code>0000000001d54...</code> ，也就是一系列的零，就像区块哈希值一样。</li><li>这笔交易使用了每一种可能的标准输入和输出类型：P2PK、P2PKH、P2MS（裸的多签名）、P2SH、P2WPKH、P2WSH、P2TR、OP_RETURN 以及一个 2 字节的 SegWit v1 输出（使用的是从 “临时锚点” 协议借用来的脚本）。一部分类型在输入中多次使用：P2SH 就分成了传统的 P2SH、封装的 P2WPKH 以及封装的 P2WSH，而 P2TR 则分成了密钥路径花费和脚本路径花费两种情形。（译者注：在比特币网络中，节点会默认传播具有某一些特征的交易；而 “标准输入&#x2F;输出” 就是这样的特征之一。输入&#x2F;输出 的类型指的是用来锁定该笔资金的脚本的 “模板”；由于不同资金本身是相互独立的，我们就可以为使用不同模板的脚本适用略微不同的验证规则，这就是比特币软分叉升级可能性的由来。这里所谓的 “封装的 P2WPKH&#x2F;P2WSH”，则是在隔离见证时，为了方便尚不支持隔离见证特性的旧钱包向隔离见证脚本发送资金，而特地设计的、让隔离见证脚本表现为 P2SH 脚本的类型。）</li><li>输入中有多个多签名脚本和闪电通道相关脚本：裸多签名输入用的是 2-of-3 多签名装置，传统的 P2SH 是 3-of-5 多签名，封装的 P2WSH 是一个撤销的闪电通道 HTLC，P2WSH 是一笔撤销的闪电通道强制关闭（通常叫做 “惩罚交易”），且具备一个不常用的短 CSV 延迟（42 个区块），而 P2TR 脚本路径使用的是一个 5-of-7 多签名（既是为了延续质数模式，也是为了引用 “5&#x2F;7” 梗）。（译者注：CSV 即是脚本层面的相对时间锁）。</li><li>输入的数额都有特殊的含义：6102 指的是美国 6102 号行政令（译者注：禁止私人储蓄黄金）、1913 是美联储（Fed）成立的时间，1971 是美国废止金本位的时间，2010 是比特币预计最后一次减半的时间（届时区块补贴将下降到 0），5139 指的是 CVE-2010-5139（比特币数值溢出漏洞），3220 指的是 CVE-2013-3220（2013 年的意外分叉），17144 指的是 CVE-2018-17144（未被利用的通胀漏洞），8149 指的是 Bitcoin 实现隔离见证的 PR 号，9001 指的是 “超过 9000 了！” 表情包，19953 指的是 Bitcoin Core 实现 Taproot 的 PR 号。</li><li>输出的数额展示了每一种输出类型的粉尘门槛：使用压缩公钥的 P2PK 输出是 576 聪，P2PKH 是 546 聪，使用压缩公钥的 1-of-1 裸多签名输出是 582 聪，P2SH 是 540 聪，20 字节的隔离见证输出（P2WPKH）是 294 聪、32 字节的隔离见证输出（P2WSH 和 P2TR）是 330 聪，2 字节的隔离见证输出是 240 聪，OP_RETURN 是 0 聪。</li><li>输入的 sequence 数字有特殊的含义：20090103 指的是创世区块产生的日期，20081031 指的是白皮书的出版时间，19750504 指的是中本聪自曝的出生日期，16 指的是 BIP-16（P2SH 升级），141 指的是 BIP-141（隔离见证升级），0xdeadbeef 是一个众所周知的魔法数字（在这里用作对封装的 P2WSH 的 80 比特安全性的评论），21000000 是我们所有人都知道并且喜爱的数字，0xf9beb4d9 是用在比特币 P2P 协议中的魔法数字，341 指的是 BIP-341（Taproot 升级），而 342 指的是 BIP-342（Tapscript）。</li><li>这笔交易使用了不同长度的 DER 编码的 ECDSA 签名：71 字节、70、69、68、67、66、65、59、58 和 57。签名一般长 71 或 72 字节，但可以通过重复尝试来获得较短的签名；这叫做 “签名研磨”。后面三个尤其短，因为它们<a href="https://crypto.stackexchange.com/a/76010">使用了 secp256k1 曲线上一个已知的短 r 值</a>。</li><li>这笔交易使用了所有种类的 sighash 标签：SIGHASH_DEFAULT、SIGHASH_ALL、SIGHASH_NONE、SIGHASH_SINGLE、SIGHASH_ALL | SIGHASH_ANYONECANPAY、SIGHASH_NONE | SIGHASH_ANYONECANPAY 和 SIGHASH_SINGLE | SIGHASH_ANYONECANPAY。（译者注：sighash 标签可以让一个签名跟交易的特定部分绑定；改动被绑定的部分会使签名失效，而改动没有被绑定的部分则不会影响签名的有效性。例如，SIGHASH_ALL 表示该签名与一笔交易的所有部分绑定，改动任何 输入&#x2F;输出 都会使该签名失效。反过来说，sighash 让我们可以辨别一笔交易是不是签名者愿意签署的那笔交易。）</li><li>OP_RETURN 输出在初始文本推入之后，包含了数字 0 到 16 的推入（puch）操作码。多次推入不会打破任何标准型规则，只要输出的体积在不超出限制。</li><li>在多个输入中使用了未压缩的公钥，并且在多签名脚本中混合使用压缩的和未压缩的公钥。（译者注：公钥是椭圆曲线上的一个点，因此有两种表示形式，一种是 x 坐标及 y 坐标，另一种是只给出 x 坐标，加上 y 值的奇偶性（或对 y 值的奇偶性作另外的强制安排）；前者称为未压缩形式，后者称为压缩形式。早期的比特币曾使用未压缩形式，后来则逐渐强制要求压缩形式（可节约链上空间）。）</li><li>在 P2MS 以及传统的 P2SH 输入中，未使用的多签名公钥是创世区块的 coinbase 公钥、区块 9 的 coinbase key 以及 Hal Finney 用在<a href="https://mempool.space/tx/f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16#vin=0">有史以来第一笔比特币交易</a>中的公钥。P2TR 脚本花费多签名装置中的两个未使用的公钥是来自<a href="https://mempool.space/tx/37777defed8717c581b4c0509329550e344bdc14ac38f71fc050096887e535c8">有史以来第一笔 P2TR 脚本花费交易</a>中的两个公钥。P2TR 脚本花费中的内部公钥是白皮书的 SHA-256 哈希值。最后，HTLC 脚本中的 20 字节的哈希值对应于地址 17TASsYPbdLrJo3UDxFfCMu5GXmxFwVZSW，该地址被用在 2010 年的数值溢出漏洞中，其用在攻击中的 0.5 BTC 一直到现在也没有再移动过。</li><li>P2TR 脚本花费输入有一棵深度为 21 的的默克尔树，比之前曾经出现过的都要深（此前的最高记录是 7 层）。控制块中揭晓的默克尔分支数值并不是随机的哈希值，而是对比特币历史有重大影响的 21 笔交易的 TXID：<ul><li>2009-01-03 创世区块的 coinbase 交易：<br>4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b</li><li>2009-01-12 第一笔非 coinbase 交易（由中本聪发送给 Hal）：<br>f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16</li><li>2009-01-16 第一笔发送到 P2PKH 脚本的交易：<br>6f7cf9580f1c2dfb3c4d5d043cdbb128c640e3f20161245aa7372e9666168516</li><li>2010-05-22 Laszlo Hanyecz 的披萨交易（价值 10000 BTC）：<br>a1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d</li><li>2010-11-14 第一笔具有重合 TXID 的交易（BIP-30 的第一个例外）：<br>d5d27987d2a3dfc724e359870c6644b40e497bdc0589a033220fe15429d88599</li><li>2010-11-15 第一笔具有重合 TXID 的交易（BIP-30 的第二个例外）：<br>e3bf3d07d4b0375638d5f1db5255fe07ba2c4cb067cd81b84ee974b6585fb468</li><li>2011-11-16 迄今面额最大的比特币交易（550,000 BTC）：<br>29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf</li><li>2013-04-06 包含了完整比特币白皮书的交易：<br>54e48e5f5c656b26c3bca14a8c95aa583d07ebe84dde3b7dd4a78f4e4186e713</li><li>2013-11-05 Rickroll 交易：<br>d29c9c0e8e4d2a9790922af73f0b8d51f0bd4bb19940d9cf910ead8fbe85bc9b</li><li>2015-07-07 F2Pool 的 “巨型交易（Megatransaction）” 需要花 25 秒来验证（详见 <a href="http://rusty.ozlabs.org/2015/07/08/the-megatransaction-why-does-it-take-25-seconds.html">Rusty Russell 撰写的博客</a>）：<br>bb41a757f405890fb0f5856228e23b715702d714d59bf2b1feb70d8b2b4e3e08</li><li>2015-07-11 F2Pool 与 Greg Maxwell 合作制造的另一笔相似交易，使用了 SIGHASH_SINGLE bug 因此易于验证，还使用短 r 值技巧获得更小的签名：<br>9fdbcf0ef9d8d00f66e47917f67cc5d78aec1ac786e2abb8d2facb4e4790aad6</li><li>2016-04-26 迄今支付最高手续费的单体交易（291 BTC）：<br>cc455ae816e6cdafdb58d54e35d4f46d860047458eacf1c7405dc634631c570d</li><li>2017-02-23 领取 SHA-1 碰撞奖金的交易：<br>8d31992805518fd62daa3bdd2a5c4fd2cd3054c9b3dca1d78055e9528cff6adc</li><li>2017-08-24 第一笔隔离见证花费交易：<br>8f907925d2ebe48765103e6845c06f1f2bb77c6adc1cc002865865eb5cfd5c1c</li><li>2021-07-23 0xB10C 的任何人都可花费的 P2TR 交易（详见：<a href="https://b10c.me/7">https://b10c.me/7</a> ）：<br>b10c007c60e14f9d087e0291d4d0c7869697c6681d979c6639dbd960792b4d41</li><li>2021-11-14 第一笔 Taproot 花费交易：<br>33e794d097969002ee05d336686fc03c9e15a597c1b9827669460fac98799036</li><li>2021-11-14 第一笔 Taproot 脚本花费交易：<br>37777defed8717c581b4c0509329550e344bdc14ac38f71fc050096887e535c8</li><li>2021-12-07 王纯给 Luke Dashjr 捐赠的 1 BTC（找零为 8999 BTC）：<br>fd456524104a6674693c29946543f8a0befccce5a352bda55ec8559fc630f5f3</li><li>2022-10-09 Burak 的 998-of-999 多签名花费，打破了 LND：<br>7393096d97bfee8660f4100ffd61874d62f9a65de9fb6acf740c4c386990ef73</li><li>2022-11-01 Burak 再次打破 LND 的交易：<br>73be398c4bdc43709db7398106609eea2a7841aaf3a4fa2000dc18184faa2a7e</li><li>2023-11-23 以法币计手续费最高的交易（86 BTC 或 313 万美元）：<br>b5a2af5845a8d3796308ff9840e567b14cf6bb158ff26c999e6f9a1f5448f9aa</li></ul></li></ul><p>整个项目花费了超过 1 年的时间才完成。最初我只是想制作一笔包含每一种可能输入和输出类型的交易，作为比较各区块浏览器特性的参考交易，但随着我产生越来越多的想法，复杂性也逐渐爆炸，最终变成了你们看到的样子。我学到了很多，不仅关于比特币协议，也关于比特币的历史。我用 TypeScript 语言和 BitcoinJS 编写了生成这笔交易的代码；少量性能敏感的部分是后来用 Rust 写的，我为了这个目的而专门学习了这种语言。</p><p>感谢 mononaut <a href="https://x.com/mononautical/status/1807189726501499268">最先注意到我的交易</a>，就在我创建它的几个小时之后，并且也是第一个注意到其 TXID 的重要性的人。然后，Super Testnet 写了一篇 <a href="https://stacker.news/items/593226">Stacker News 帖子</a>，列出了当时知道的每一个彩蛋（也是许多彩蛋的第一发现人）。最后，感谢另一些也发现了彩蛋的人：Sebastian Falbesoner、Rob Hamilton、Tom Honzik、iWarp、Jiří Jakeš、Portland.HODL、pycan、Gregory Sanders、Tomer Strolight 和 Peter Todd 。</p><p>非常感谢比特币的开发者社区、比特币的技术作者，以及在 Bitcoin Stack Exchange 上回答问题的人。没有大家，这个项目是不可能完成的。我也非常感谢对这笔交易表示赞赏的人，这对我来说意义非凡。</p><p>如果你还有问题，我非常乐意回答。如果问题是其他人也能够回答的，请考虑发到 Bitcoin Stack Exchange，这样更有可能帮到其他读者。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">整个项目花费了超过 1 年的时间才完成</summary>
    
    
    
    
    <category term="文化" scheme="https://www.btcstudy.org/tags/%E6%96%87%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>中本聪如何推理比特币：用健全货币解决重复花费</title>
    <link href="https://www.btcstudy.org/2024/07/25/how-did-satoshi-think-of-bitcoin/"/>
    <id>https://www.btcstudy.org/2024/07/25/how-did-satoshi-think-of-bitcoin/</id>
    <published>2024-07-25T16:36:21.000Z</published>
    <updated>2024-09-02T04:30:25.025Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：UNCHAINED &amp; Dhruv Bansal</em></p><p><em>来源：<a href="https://bitcoinmagazine.com/technical/how-did-satoshi-think-of-bitcoin">https://bitcoinmagazine.com/technical/how-did-satoshi-think-of-bitcoin</a></em></p></blockquote><blockquote><p><em>本文的核心观点是，比特币可以认为是 Dai 的 b-money 项目的一个修改版，消除了创建货币自由的版本。在本文初次出版的几周之后，人们发掘出新的中本聪邮件，在其中，中本聪自称并不了解 b-money 项目，但承认比特币是 “从完全相同的点” 开始的。有了这个新证据，我们更加坚信本文的核心观点；虽然它从历史事实上来说不是绝对精确，但依然是理解比特币起源的一个有意义、有好处的视角。</em></p><p>—— 二次出版卷首语</p></blockquote><p>人们常常拿比特币与 1990 年代的互联网比较，但我认为，更合适的类比对象是 1840 年代的电报。<sup><a href="#note1" id="jump-1">[1]</a></sup></p><p>电报是第一种能以接近光速的速度长距离传播经过编码的数据的技术。电报的发明标志着通信行业的诞生。互联网虽然在规模上比电报更大、在内容上更加丰富、可以做到多对多（而不是只能一对一），但从根本上来说，依然是一种通信技术。</p><p>电报和互联网都依赖于一种商业模式：公司投入资本来建设一个物理网络，然后向使用这个网络发送消息的用户收费。AT&amp;T（通信公司） 的网络曾被用来传输电报、电话、TCP&#x2F;IP 包、文字消息，以及最新的 TickTok 视频。</p><p>社会的电信化带来了极大的自由，但也产生了极大的中心化。互联网矿大了几百万内容创作者和小企业的触达范围，但也加强了一些公司、政府和其它占据优势地位的机构监控和操纵线上活动的权力。</p><p>但比特币不是任何社会变革的尽头 —— 它是一场变更的开始。就像电信，比特币会改变人类社会和每个人的日常生活。在今天，要预测这场变更的范围，无异于在电报时代想象互联网。</p><p>本文想做的是通过弄清过去来想象未来。最开始，我们会追踪比特币以前的电子货币的历史。只有理解这些项目失败的原因，我们才能理解让比特币成功的原因 —— 以及它如何给未来的去中心化系统开发确立了方法论。</p><h2 id="中本聪如何推理比特币？"><a href="#中本聪如何推理比特币？" class="headerlink" title="中本聪如何推理比特币？"></a>中本聪如何推理比特币？</h2><p>中本聪是天才，但比特币不是无源之水。</p><p>比特币融合了密码学、分布式系统、经济学和政治哲学领域已有的工作。“工作量证明（PoW）” 的概念早在用于电子货币之前就已经存在；先于中本聪的密码朋克，比如 Nick Szabo、Wei Dai 和 Hal Finney 都分别通过 bit gold、b-money 和 PROW 项目参与并影响了比特币的设计。想一想，在 2008 年中本聪写出比特币白皮书 <sup><a href="#note2" id="jump-2">[2]</a></sup> 的时候，许多对比特币重要的观念都已经被提出 以及&#x2F;或者 实现了：</p><ul><li>电子货币应该使用点对点网络</li><li>工作量证明是货币创造的基础</li><li>货币要通过拍卖来创造</li><li>公钥密码学可用来定义所有权以及钱币的转移</li><li>交易可以打包成区块</li><li>区块可通过工作量证明来前后链接</li><li>每一个参与者都保存所有区块</li></ul><p>比特币利用了这些概念，而中本聪不是以上任何一个想法的原创作者。为了更好地理解中本聪的贡献，我们应该确定，比特币的哪些原理是不在上述列表中的。</p><p>一些明显的候选答案包括：比特币的有限供给量、中本聪共识，还有难度调整算法。但在一开始，到底是什么，引导中本聪走向了这些想法？</p><p>本文研究了电子货币的历史，并认为，中本聪对健全货币政策的关注，帮助比特币克服了让先前的项目（比如 bit gold 和 b-money）铩羽而归的障碍。</p><h2 id="I-去中心化的系统就是市场"><a href="#I-去中心化的系统就是市场" class="headerlink" title="I. 去中心化的系统就是市场"></a>I. 去中心化的系统就是市场</h2><p>比特币常常被说成是一个去中心化的系统，或者分布式的系统。但是，不论 “去中心化（decentralized）” 还是 “分布式（distributed）”，都常常让人感到困惑。在电子系统领域，这两个词说的都是将单体式应用程序拆解为通讯部件所组成的网络的办法。</p><p><img src="/../images/how-did-satoshi-think-of-bitcoin/how-satoshi-think-of-bitcoin-1.png" alt="how-satoshi-think-of-bitcoin-1"></p><p>从我们的角度看，去中心化系统与分布式系统的主要区别并不在于<a href="https://medium.com/@VitalikButerin/the-meaning-of-decentralization-a0c92b76a274">网络的拓扑</a>，而在于它们强制执行规则的方式。在下文中，我们会花点时间来比较分布式系统和去中心化系统，然后引出 “健壮的去中心化系统就是市场” 的想法。</p><h3 id="分布式系统依然依赖于中心权威"><a href="#分布式系统依然依赖于中心权威" class="headerlink" title="分布式系统依然依赖于中心权威"></a>分布式系统依然依赖于中心权威</h3><p>在本文中，我们的 “分布式” 可以指称任何已经被打散成许多部分（通常叫做 “节点”）的系统，这些部分必须相互通信（才能让整个系统正常执行功能），一般来说是通过一个网络来通信。</p><p>软件工程师在开发全球化的分布式系统上已经越来越熟练。互联网本身就由分布式系统组成，总共包含了数十亿个节点。我们每个人口袋里都有一个节点（译者注：智能手机），它本身既参与又依赖于这些分布式系统。</p><p>但几乎所有我们日常使用的分布式系统都受一些中心权威管控，包括系统管理员、公司和政府，它们是系统中所有节点都信任的。</p><p>中心权威保证所有节点都遵守规则，并且踢出、修复和惩罚不能遵守规则的节点。人们信任权威以获得协调服务、解决冲突、分配共享的资源。在时间的流逝中，中心权威会管理系统的变更，升级系统或添加特性，并保证所有参与者都遵从这些变更。</p><p>分布式系统从依赖中心权威中获得了好处，但也不是没有付出代价。虽然整个系统可以应对一些节点的故障，但中心权威的故障就有可能导致整体系统停止工作。中心权威单方决策的能力也意味着只需颠覆或消灭这个中心权威就足以控制或摧毁整个系统。</p><p>尽管有这种取舍，但如果某一个参与者或者某一个联盟必须保持中心权威地位，或者如果一个系统内的参与者就是要依赖于一个中心权威，那么传统的分布式系统就是最佳的解决方案。不需要<a href="https://bitcoinmagazine.com/guides/what-is-blockchain">区块链</a>、token  和去中心化的包装。</p><p>尤其是在风险资本（VC）主导开发或由政府背书的密码货币中，由于需要一方可以监控和限制支付、冻结账户，是传统去中心化系统的完美应用场景。</p><h3 id="去中心化系统没有中心权威"><a href="#去中心化系统没有中心权威" class="headerlink" title="去中心化系统没有中心权威"></a>去中心化系统没有中心权威</h3><p>而 “去中心化”，在我们看来，其范围比 “分布式” 更狭窄：去中心化系统是分布式系统的子集，是没有任何中心权威的分布式系统。“去中心化” 的意思更接近的同义词是 “点对点”。</p><p>取消中心权威会带来几个好处。去中心化系统：</p><ul><li>生长迅速，因为没有准入门槛 —— 任何人都可以运行一个新的节点，这就壮大了系统；不需要注册，也不需要来自中心权威的许可。</li><li>稳固，因为不存在一出故障就可以瘫痪整个系统的中心权威。所有的节点都是一样的，所以故障都是局部的，网络会绕过遭到损坏的区域。</li><li>难以抓捕、规制、征税和监视，因为没有可供颠覆的中心控制点。</li></ul><p>这些优点，正是中本聪为比特币选择去中心化、点对点设计的原因：</p><blockquote><p><em>“政府很擅长砍掉 …… 有控制中心的网络的头，比如 Napster；但纯粹的 P2P 网络，不如 Gnutella 和 Tor，似乎可以维持。”</em> </p><p>—— 中本聪，2008</p></blockquote><p>但这些强项也伴随着相应的弱点。去中心化系统可能会更加低效，因为每一个节点，都必须额外承担原本假设要由中心权威来承担的协调责任。</p><p>去中心化系统也更容易受到来自欺诈和敌意行为的困扰。虽然中本聪肯定了 Gnutella，但任何使用点对点文件分享程序来下载文件，结果下载到粗俗内容、恶意程序的人，都知道为什么点对点文件分享从来无法成为线上数据传输的主流模式。</p><p>中本聪没有点名，但电子邮件是另一个逃脱了政府控制的去中心化系统。而电子邮件也类似，是垃圾信息轰炸的重灾区。</p><h2 id="去中心化的系统要通过经济激励来管理"><a href="#去中心化的系统要通过经济激励来管理" class="headerlink" title="去中心化的系统要通过经济激励来管理"></a>去中心化的系统要通过经济激励来管理</h2><p>在所有这些案例中，最根本的问题都在于，敌意行为（提供错误的文件、发送垃圾电邮）不会受到惩罚，而合作行为（发送对的文件、仅发送有用的邮件）也不会得到奖励。如果去中心化的系统依赖与其成员都是好人，那就无法扩大规模，因为没有办法阻止坏人参与进来。</p><p>在没有中央权威的情况下，解决这个问题的唯一办法就是使用经济激励。从字面上来说，好人，是出于内在的道德感而遵守规则的人。而从字面上来说，坏人，是指自私而且有敌意的人，但合理的经济激励可以让他们转变行为，为公共福祉贡献力量。去中心化的系统，要保证合作行为能够获得好处、敌意行为则代价高昂，才能扩大规模。</p><p>实现可靠去中心化服务的最佳方法就是创建一个市场，让所有参与者，无论好坏，都能在提供服务后获得好处。在去中心化的市场中，不为买方和卖方设置门槛，带来的是规模的扩大和效率的提升。只要市场的协议能保护参与者免受欺诈、盗窃和虐待，坏人也会发现，能够给自己带来最大好处的事情要么是遵守规则，要么是离开这个地方、去攻击另一个系统。</p><h2 id="II-去中心化的市场需要去中心化的商品"><a href="#II-去中心化的市场需要去中心化的商品" class="headerlink" title="II. 去中心化的市场需要去中心化的商品"></a>II. 去中心化的市场需要去中心化的商品</h2><p>但市场也是复杂的。市场必须给卖家和买家提供标价和讨价的能力，还有发现、匹配和结算订单的能力。市场必须公平，提供强大的一致性，在波动的周期中保持可用。</p><p>今天全球市场是非常大也非常复杂的，但在一个去中心化系统中，使用传统的商品和支付网络来实现经济激励，是行不通的。去中心化系统跟法币、传统资产、实物商品的任何关联，都会开倒车、依赖控制支付处理商、银行、交易所的中心权威。</p><p><img src="/../images/how-did-satoshi-think-of-bitcoin/how-satoshi-think-of-bitcoin-2.png" alt="how-satoshi-think-of-bitcoin-2"></p><p style="text-align:center">- 去中心化系统没法交付现金、检查经纪账户的余额以及确定不动产的所有权。传统的商品在一个去中心化系统中是完全无法辨认的。但反之不成立 —— 传统的系统可以跟比特币互动，就跟新的去中心化系统一样（只要他们真的想要）。传统系统与去中心化系统之间的障碍不是密不透风的高墙，而是半透膜。 -</p><p>这意味着，去中心化系统没法执行以任何传统商品标价的支付。它甚至没法确定一个法币账户的余额和房地产的所有权。整个传统经济，在去中心化系统中是完全模糊的。</p><p>创建去中心化的市场要求交易新型的去中心化商品，这样的商品在去中心化系统中必须是可以辨认、可以转移的。</p><h3 id="计算是第一种去中心化商品"><a href="#计算是第一种去中心化商品" class="headerlink" title="计算是第一种去中心化商品"></a>计算是第一种去中心化商品</h3><p>“去中心化商品”的第一个案例是一种特殊类型的计算，最早由 Cynthia Dwork 和 Moni Naor 在 1993 年提出 <sup><a href="#note3" id="jump-3">[3]</a></sup> 。</p><p>因为数学、物理学和计算机科学之间的深刻关联，这种计算必须消耗真实世界的能量以及已经资源 —— 也即不能造假。因为真实世界的资源是稀缺的，这种计算自然也是稀缺的。</p><p>这种计算的输入可以是任何数据。而最终的输出是一个电子化的 “证据”，证明在给定的输入数据上运行了这种计算。证据都包含一个特定的 “难度”，是发生了的计算工作的数量的（统计学）证据。最重要的是，输入数据、证据、最初花费的计算量，三者之间的关系，可以独立地验证，无需依附任何中心权威。</p><p>这种想法（将一些输入数据与其电子证据一起传递，作为在这个输入上执行了真实计算工作的证据）现在被称为 “工作量证明”<sup><a href="#note4" id="jump-4">[4]</a></sup> 。用 Nick Szabo 的话来说，工作量证明是 “不可伪造的奢侈浪费”。因为工作量证明是任何人都可以验证的，它变成了去中心化系统中所有人都可以辨识的经济资源。工作量证明将对数据的计算成为去中心化的商品。Dwrok 和 Naor 提议强迫参与者获取资源之前提供特定难度的工作量证明，以利用这种计算来限制对资源的滥用：</p><blockquote><p><em>“在这篇论文中，我们提出了一种基于计算的、对抗电子邮件轰炸的方法。更广义地说，我们设计出了一种访问控制机制，可以用在任何需要限制但不需要禁止访问资源的地方。”</em></p><p>—— Dwoak &amp; Naor，1993</p></blockquote><p>在 Dwoak 和 Naor 的提议中，一个电子邮件的系统管理员会为邮件的发送设定一个工作量证明的难度门槛。想要发送电子邮件的用户需要将电子邮件作为输入数据，执行相应次数的计算。算出的工作量证明将会跟电子邮件请求一起提交给电子邮件服务器。</p><p>Dwork 和 Naor 将难度称为工作量证明的 “定价函数”，因为，只需调整难度，“定价权威” 就可以确保共享的资源对诚实的普通用户来说依然便宜，但对尝试滥用它的用户来说变得很贵。在电邮交付市场上，服务器管理员就是这样的定价权威；他们必须为邮件的交付决定一个 “价格”，使得发送电子邮件对在常规用途中足够便宜，但对邮件轰炸来说所费不菲。</p><p>虽然 Daork 和 Naor 将工作量证明作为一种打击资源滥用的反激励措施，“定价函数” 和 “定价权威” 这样的术语暗示着另一种基于市场的解读：用户可以付出由资源控制者设好价格的计算，来购买资源。</p><p>在这种视角下，电子邮件的交付网络真正成为了一种去中心化的市场，用计算来购买电子邮件的交付。而工作量证明的难度门槛就是电子邮件服务器标出的价格，以计算这种货币作为单位。</p><h3 id="货币是第二种去中心化商品"><a href="#货币是第二种去中心化商品" class="headerlink" title="货币是第二种去中心化商品"></a>货币是第二种去中心化商品</h3><p>但计算本身并不是一种很好的货币。</p><p>一个证据仅对一个输入有效。这种不可打破的关联意味着一个输入的工作量证明不能复用在另一个输入中。</p><p><img src="/../images/how-did-satoshi-think-of-bitcoin/how-satoshi-think-of-bitcoin-3.png" alt="how-satoshi-think-of-bitcoin-3"></p><p style="text-align:center">- 工作量证明最初是作为一种限制邮件轰炸的访问控制机制而提出的。用户需要为发出的电子邮件提供附带的工作量证明。这种机制也可以认为是一种市场，用户使用计算来购买邮件的交付服务，而价格由电子邮件服务商决定。 -</p><p>这种现实是有用的 —— 可以用来防止一个买家付出的工作量被另一个买家重复花费。举个例子，电子邮件交付市场的第一个真正的实现 HashCash，就在工作量证明计算的输入数据中包含了元数据，比如当前的时间戳和发送者的邮件地址。一个用户为一封电子邮件制作的证明，不能用来发送另一封电子邮件。</p><p>但这也意味着工作量证明的计算是定制化的商品。不是同质的，也不能再次花出去 <sup><a href="#note5" id="jump-5">[5]</a></sup> ，而且它自身也不解决 “双方需求巧合” 问题。它所缺失的这些货币特性，阻止了它成为一种货币。别看名字这么好，电子邮件服务商其实并没有累积 HashCash 的意愿，但他们肯定愿意储蓄现金。</p><p>HashCash 的发明者 Adam Back 完全理解这些问题：</p><blockquote><p><em>“hashcash 无法直接转移，因为，为了让 hashcash 变成分布式的，每一个服务供应商都只接受专门为之创建的 cash 支付。也许你可以建立一种 digicash 式的铸币厂（发行 David Chaum 式的 ecash），并让铸币厂仅在收到专门给他的 hashcash 时才铸造 ecash。不过，这又意味着，你要信任铸币厂不会超量铸造货币。”</em></p><p>—— Adam Back，1997</p></blockquote><p>我们不希望为去中心化经济体中的每一个商品和服务交换定制化的计算。我们想要一种通用的电子货币，可以直接用来协调任何市场中的价值交换。</p><p>开发一种能用的电子货币，同时还能保持去中心化，是一个重大难题。货币需要可互换的价值单位，还要能够在用户之间直接转移。它需要设计货币发行的模式、用密码学定义的所有权和价值转移、交易的发现和结算机制，以及一个能够记录历史的账本。在仅仅把工作量证明理解成一种 “访问控制机制” 的时候，不需要上述任何一种基础设施。</p><p>而且，去中心化的系统是市场，因此，货币的所有基础功能，在由服务供应商提供的时候都必须在一定意义上得到支付 …… 以这样创建出来的货币标价！</p><p>就像编译第一个编译器、电网的黑启动乃至生命自身的演化一样，电子货币的创建者们也面临一个冷启动问题：如何定义出支撑一种有用货币的经济激励，而无需用另一种已经存在的货币来给这些激励标识价格和支付（how to define the economic incentives that underlie a functioning currency without having a functioning currency in which to denominate or pay those incentives）。</p><p><img src="/../images/how-did-satoshi-think-of-bitcoin/how-satoshi-think-of-bitcoin-4.png" alt="how-satoshi-think-of-bitcoin-4"></p><p style="text-align:center">- 计算和货币是去中心化市场中的第一种和第二种商品。工作量证明自身允许用计算来交换，但可用的货币需要更多的基础设施。密码朋克社区花了 15 年才开发出这样的基础设施。 -</p><h3 id="第一种去中心化市场必须用计算来交换货币"><a href="#第一种去中心化市场必须用计算来交换货币" class="headerlink" title="第一种去中心化市场必须用计算来交换货币"></a>第一种去中心化市场必须用计算来交换货币</h3><p>这个冷启动问题的进展来自于对问题边界的正确界定。</p><p>去中心化系统必须成为市场。市场由交换商品的买家和卖家组成。而在一种电子货币的去中心化市场中，能辨识出来的商品只有两种：</p><ol><li>具备工作量证明的计算</li><li>这个去中心化系统要构建的货币的基本单位</li></ol><p>因此，唯一可能的市场交易必然发生在两者之间。计算必须能够用货币单位来购买，或者说（完全等价的），货币单位必须能够用计算来购买。指出这一点是容易的 —— 难的地方在于构造出这样的市场，从而只需允许货币与计算相互交易，就能启动货币自身的所有功能！</p><p>整个电子货币的历史，以中本聪在 2008 年出版白皮书为顶点，就是一系列构造这样的的市场的越来越精巧的尝试。在下一章，我们会回顾一些项目，比如 Nick Szabo 的 big gold 和 Wei Dai 的 b-money。理解这些项目构造其市场的尝试，以及它们为何失败，可以帮助我们理解为什么中本聪和比特币取得了成功。</p><p><img src="/../images/how-did-satoshi-think-of-bitcoin/how-satoshi-think-of-bitcoin-5.png" alt="how-satoshi-think-of-bitcoin-5"></p><h3 id="III-去中心化的系统如何给计算定价？"><a href="#III-去中心化的系统如何给计算定价？" class="headerlink" title="III. 去中心化的系统如何给计算定价？"></a>III. 去中心化的系统如何给计算定价？</h3><p>市场的主要功能之一是价格发现。因此，交易计算与货币的市场必须找出计算自身的价格，并以货币单位标示。</p><p>通常我们不会直接给计算赋予货币价值。我们一般只给执行计算的资本估价，因为我们看重的是计算的结果，而不是计算本身。如果相同的输出可以更高效（使用更少的计算）地计算出来，通常这就叫做 “进步（progress）”。</p><p>工作量证明代表着一种特殊的计算，其唯一输出是一个证据，证明这些计算已经执行过。能够用更少的计算（和更少的能量）来产生相同的证据，就不能叫进步了 —— 应该叫 bug（缺陷）。因此与工作量证明相关计算是一种奇怪的商品，难以估价。</p><p>当工作量证明被理解成一种应对资源滥用的反激励措施时，准确且一致地评估它们的价值是不必要的。唯一重要的事情是电子邮件服务商要把难度设置得当，既低到不至于让普通用户察觉，又高到足以阻止滥发邮件的人。因此，可以接受的 “价格” 的范围很广，而且每一个参与者都可以成为自己的定价权威，应用一种局部的定价函数。</p><p>但货币单位就得是可以互换的，也就是每一单位都拥有相同的价值。而且，随着技术的进步，两个由相同工作量证明的难度 —— 由相应计算的数量度量 —— 创建的货币单位可能会有相差极大的生产成本 —— 以时间、能量 以及&#x2F;或者 执行这些计算的资本量来度量。如果用计算来交换货币，而且底层的生产成本是可变的，市场如何保证一个一致的价格？</p><p>Nick Szabo 在提出 bit gold 的时候，清楚地定位了这个定价问题：</p><blockquote><p><em>“主要问题……在于，工作量证明方案依赖于计算机架构，而不仅仅是一种基于抽象的 ‘计算循环’ 的抽象数学。…… 因此，可能会出现一个成本非常低的生产者（比其他人低几个数量级），然后让 bit gold 在市场中泛滥。”</em></p><p>—— Nick Szabo，2005</p></blockquote><p><img src="/../images/how-did-satoshi-think-of-bitcoin/how-satoshi-think-of-bitcoin-6.png" alt="how-satoshi-think-of-bitcoin-6"></p><p style="text-align:center">- 通过工作量证明创建的去中心化货币会在计算的供给量随时间增长的过程中出现过剩和崩溃。为了缓解这种波动，网络必须学会动态地给计算定价。 -</p><p>早期的电子货币尝试通过整体上度量 “计算的成本” 来给计算定价。举个例子，Wei Dai 就在 b-money 中提议了下面这种手动解决方案：</p><blockquote><p><em>“创造出来的货币单位的数量等于计算的成本，以一篮子标准商品的价值来衡量。举个例子，如果一个问题在最经济的计算机上需要 100 个小时来求解，而在公开的市场上，需要 3 份标准商品组合来购买这台计算机上的 100 小时计算时间，那么，在这个问题的解决方案被广播之后，每个人都给这个广播者的账簿增加 3 个单位的货币”。</em></p><p>—— Wei Dai，1998</p></blockquote><p>遗憾的是，Dai 并没有解释，在一个假设是去中心化的系统中，用户如何对 “标准商品篮子” 的定义达成一致意见、如何知晓哪一台计算机能 “最经济” 地解决一个给定问题、又如何知道 “公开市场” 上计算的成本。在所有用户之间，对一个会随时间变化的共享数据集达成共识，正是去中心化系统的本质问题！</p><p>公允地说，Wei Dai 自己也意识到了这一点：</p><blockquote><p><em>“b-money 协议中最成问题的一部分就是货币的创造。协议要求所有【用户】确定特定计算的成本并达成一致。然而，因为计算技术会快速进步，而且这种进步并不总是公开的，相关的信息可能无法取得，或得到的信息是不准确的或过期的，所有这些情形都会在这套协议中造成严重的问题。”</em></p><p>—— Wei Dai，1998</p></blockquote><p>Wei Dai 后来提出了一种更精巧的基于拍卖的定价机制，也被中本聪说是他的想法的起点。我们后面会回到这种拍卖方案，但现在，我们先转向 big gold，看看 Nick Szabo 在这个问题上的洞见。</p><h3 id="使用外部市场"><a href="#使用外部市场" class="headerlink" title="使用外部市场"></a>使用外部市场</h3><p>Szabo 认为，工作量证明应该 “安全地打上时间戳”：</p><blockquote><p><em>“这种工作量证明被安全地打上了时间戳。这是可以用分布式方式做到的，有多家时间戳服务，因此不需要实质上依赖于任何一家。”</em></p><p>—— Nick Szabo，2005</p></blockquote><p>Szabo 列出了一页关于安全时间戳协议的资源，但并没指定具体的一种算法。这里的用词 “安全地” 和 “分布式方式” 很强横，抛开了依赖于一个（或多个）“系统之外” 的时间戳服务的复杂性问题 <sup><a href="#note6" id="jump-6">[6]</a></sup> 。</p><p><img src="/../images/how-did-satoshi-think-of-bitcoin/how-satoshi-think-of-bitcoin-7.png" alt="how-satoshi-think-of-bitcoin-7"></p><p style="text-align:center">- 具体一单位的电子货币的创建时间是重要的，因为他关联着被执行的计算的真实世界成本。 -</p><p>撇开实现细节上的语焉不详，Szabo 是对的 —— 一个工作量证明被创造出来的时间点，是它的价格的重要因素，因为关联着其计算成本：</p><blockquote><p><em>“……然而，因为 bit gold 带有时间戳，创建它的时间以及工作量的数学难度可以自动证明。使用这些因素，通常可以推断出在那段时间，其生产成本几何……”</em></p><p>—— Nick Szabo，2005</p></blockquote><p>“推断” 生产成本很重要，因为 big gold 没有限制货币创造的机制。任何人都可以通过运行合适的计算来创造 bit gold。没有规制发行的能力， bit gold 就更像一种收藏品：</p><blockquote><p><em>“……不像同质化的金原子，而像收藏家们喜欢的东西，一段时间内出现大量的供给会使这种东西的价值降低。从这个角度上来说，bit gold 更像收藏品，而不是黄金……”</em></p><p>—— Nick Szabo，2005</p></blockquote><p>Bit gold 需要一个额外的、外部的程序来创建同质化的货币单位：</p><blockquote><p><em>“……Bit gold 没办法依靠一种简单的函数（比如说）字符串的长度变得同质化。相反，为了创建同质化的单位，经销商需要将不同价值的几个 bit gold 打包在一起，才能形成一个更大的、几乎等价值的单元。这就像现在的经销商让商品市场得以成型一样。信任依然是分布式的，因为评估这些套装的价值可以由许多不同参与者以大部分甚至完全自动化的方式运行。”</em></p><p>—— Nick Szabo，2005</p></blockquote><p>用 Szabo 的话来说，“为评估…… bit gold 的价值，经销商会检查和验证难度、输入和时间戳”。定义 “更大的几乎等价的单元” 的经销商，跟 Wei Dai 所谓的 “标准的一篮子商品” 提供的是相似的定价功能。在 bit gold 中，同质化的单元不是在工作量证明制作出来的时候诞生的，而是在稍后，这些证明被网络之外的市场经销商组合成一个更大的 “几乎等价值的单元” 的时候。</p><p>值得赞扬的是，Szabo 知道这个缺陷：</p><blockquote><p><em>“……因为机器架构的隐蔽创新而出现一开始隐藏的供给过剩的可能性，是 bit gold 协议的一个潜在漏洞，至少是 bit gold 的初始拍卖和后续交易必须解决的一个不完美之处。”</em></p><p>—— Nick Szabo，2005</p></blockquote><p>再说一次，虽然没有抵达（我们今天所知的）解决方案，Szabo 已经正确地指出：因为在时间的推移中计算的成本会改变，网络必须调整货币的价格，来应对计算供给量的变化。</p><h3 id="使用内部市场"><a href="#使用内部市场" class="headerlink" title="使用内部市场"></a>使用内部市场</h3><p>Szabo 意义上的经销商是一种外部市场，定义（一套）bit gold 的价格（在这些 bit gold 被创造出来之后）。有没有可能在系统内部（而不是在外部）实现出这样的市场？</p><p>让我们再次回到 Wei Dai 和 b-money。如前面提到的，Dai 提出另一种基于拍卖的 b-money 创造模式。中本聪对比特币的设计就是在此基础上改良的 <sup><a href="#note7" id="jump-7">[7]</a></sup> ：</p><blockquote><p><em>“所以，我提议使用另一种货币创造子协议，由【用户】…… 来决定一段时间要创造多少 b-money 出来，而创造这些货币的代价则由拍卖来发现，每一个创造货币的周期都可以分成以下四个阶段：</em></p><p><em>计划阶段。【用户们】计算并协商下一个周期的最优货币增量。无论【网络】是否能达成共识，每一个人都广播自己的货币创造额度，以及所有用于支持自己方案的宏观经济考量。</em></p><p><em>投标阶段。任何想要创造 b-money 的人都广播一个投标价，形式是：自己想要创造 x 单位的 b-money，愿意解决一类预先定义的问题中的未解问题 y 。这类问题中的每一个问题都应有一个公开达成一致意见的名义成本（假设以 MIPS（每秒百万条指令）-年 为单位）。</em></p><p><em>计算阶段。在看到投标之后，每个投标者都要解决自己标书中的问题，然后广播答案。货币就这样创造来。</em></p><p><em>货币创造阶段。每个【用户】都接受（在所有真正广播出来的答案中）最高的标价，以名义成本除以创造出来的 b-money 数量来衡量，然后给投标者的账户增加相应的 b-money 数额。”</em></p><p>—— Wei Dai，1998</p></blockquote><p>B-money 向电子货币的正确市场结构迈出了重大一步。它尝试消除 Szabo 的外部经销商，允许用户通过直接与其他人竞标参与到价格发现中来。</p><p>但要一五一十地实现 Dai 的提议，也不容易：</p><ul><li>在 “计划阶段”，用户承担着协商 “下一个周期的最优货币增量” 的责任。怎么定义这个 “最优”呢？用户应该如何跟其他人协商？协商的结果应该如何分享？都没有明说。</li><li>无论计划是什么样的，“投标” 阶段允许任何人提交创造 b-money 的投标。这种投标既包含了要创建的 b-money 的数量，又包含了承诺要提供的工作量证明，所以每一份投标都是一个价格，是投标者为购买一定数量的 b-money 而愿意付出的计算数量。</li><li>投标提交之后，就进入 “计算”  阶段，投标者要运行工作量证明，然后广播答案。没有机制来匹配投标者和答案。更大的问题是，不清楚用户要怎么知道所有投标都已经提交了 —— 什么时候意味着 “投标” 阶段的结束和 “计算” 阶段的开始呢？</li><li>这问题在 “货币创造” 阶段又出现了。因为工作量证明的本性，用户可以验证自己收到的答案是真的。但用户怎么集体同意 “最高的标价”？如果不同的用户选择了不同的组合（不管是因为机器性能还是网络延迟），那会怎么样？</li></ul><p>去中心化系统很难跟踪数据并作出一致的选择，而 b-money 正要求跟踪来自许多用户的投标，并对选择达成共识。这种复杂性甚至让 b-money 从未被实现过。</p><p>这种复杂性的根源在于 Wei Dai 对 “最优” 增长率的信念：b-money 的创造应该基于其用户的 “宏观经济考量” 而波动。跟 bit gold 一样，b-money 没有机制能够限制货币的创造。任何人都可以通过广播投标、运行相应的计算来创造 b-money。</p><h2 id="IV-中本聪的货币政策目标引出了比特币的设计"><a href="#IV-中本聪的货币政策目标引出了比特币的设计" class="headerlink" title="IV. 中本聪的货币政策目标引出了比特币的设计"></a>IV. 中本聪的货币政策目标引出了比特币的设计</h2><p>与他们相反的是，健全的货币政策，是中本聪在比特币中的首要目标之一。在最早的宣布比特币的邮件中，中本聪写道：</p><blockquote><p><em>“传统货币的根本问题在于它需要信任才能工作。人们必须信任中央银行不会贬值货币，但法币的历史充斥着这种信任遭到背叛的事件。”</em></p><p>—— 中本聪，2009</p></blockquote><p>然后，中本聪介绍了法币的其它问题，比如高风险的部分准备金银行系统、隐私缺位、猖獗的盗窃和诈骗，还有无法进行小额支付。但是中本聪是从中央银行贬值货币的问题开始的 —— 他关心的是货币政策。</p><p>中本聪希望比特币最终的流通供给量是有限的，不会随着时间推移而不断稀释。对中本聪来说，比特币的 “最优” 的货币增长率，最终应该是零。</p><p>这种货币政策目标，而不是中本聪表现出来的任何其它个人（或集体！）特质，才是中本聪 “发现” 比特币、区块链、中本聪共识，等等，的原因 —— 才是其他人没有发明比特币的原因。这就是本文标题中的问题的简短回答：中本聪能够推理出比特币，是因为他（们）专注于创造一种供给量有限的电子货币。</p><p>对比特币来说，有限的供给量不仅仅是一种货币政策，也不单纯是比特币人喜欢说的俏皮话。这是一种根本上的技术简化，让中本聪可以开发出一种能用的电子货币，而 Dai 的 b-money 只能停留在奇思妙想的阶段。</p><p>比特币是额外要求了一种预先定义的货币政策的 b-money。就像许多技术简化措施一样，受约束的货币政策通过缩减规模来推进。我们来看看，创造 b-money 的四个阶段是如何用这种约束来简化的。</p><h3 id="2100-万-BTC-全部都已问世"><a href="#2100-万-BTC-全部都已问世" class="headerlink" title="2100 万 BTC 全部都已问世"></a>2100 万 BTC 全部都已问世</h3><p>在 b-money 中，每一个 “货币创造周期” 都包含一个 “计划” 阶段，在其中，用户需要分享自己的 “宏观经济考量”，为自己的货币创造提议辩护。中本聪的货币政策目标是实现有限供给量，零长尾增发，这就跟 b-money 为个人用户赋予的货币创造自由不兼容。因此，从 b-money 走向比特币的第一步就是取消这种自由。比特币用户无法创造比特币。只有比特币网络能创造比特币，而且只创造一次，就在 2009 年中本聪推出比特币项目的时候。</p><p>中本聪可以将 b-money 中反复出现的 “计划” 阶段替换成一套预先确定的日程表，让在 2009 年创造的 2100 万 BTC 在未来进入流通。用户自愿通过下载和运行硬编码了这种货币政策的比特币软件来表示对中本聪货币政策的同意。</p><p>这就改变了比特币计算市场的语义。支付给矿工的比特币并不是新发行的；只是从已有供给量中解锁进入流通的。</p><p>这种思维框架与 “比特币矿工创造比特币” 的天真说辞完全不同。比特币矿工没有创造比特币，只是买到了比特币。比特币有价值不是因为 “它是用能量制造的” —— 人们愿意用能量购买比特币只是体现了比特币有价值。</p><p>让我们重复一遍：比特币不是通过工作量证明创造出来的，是通过共识创造出来的。</p><p><img src="/../images/how-did-satoshi-think-of-bitcoin/how-satoshi-think-of-bitcoin-9.png" alt="how-satoshi-think-of-bitcoin-9"></p><p style="text-align:center">- 中本聪的设计取消了 b-money 对重复运行的 “计划” 阶段的需要，因为提前做好了所有的计划。这让中本聪可以硬编码一种健全的货币政策，同时简化比特币的实现。 -</p><h3 id="比特币通过共识来定价"><a href="#比特币通过共识来定价" class="headerlink" title="比特币通过共识来定价"></a>比特币通过共识来定价</h3><p>在 b-money 网络中，用户获得了创造货币的自由的同时，也要承担相应的负担。在 “投标” 阶段，b-money 网络必须收集和分享来自许多用户的货币创造 “标书”。</p><p>取消了创造货币的自由，也使比特币网络免于这种负担。因为所有的比特币（2100 万 BTC）都已经存在，网络也不需要收集来自用户的创造货币的标书，只需要卖出中本聪预先决定的日程表中的比特币。</p><p>因此，比特币网络为每个区块卖出的比特币提供了一个得到共识的要价。这个价格是每个节点使用区块链的副本独立计算出来的。只要节点能对同一条区块链达成共识（我们后面再说这一点），那他们就能在每个区块给出同样的要价 <sup><a href="#note8" id="jump-8">[8]</a></sup> 。</p><p>共识价格计算的前一半是决定要卖多少比特币。这是用中本聪的预先确定的解锁日程表固定的。比特币网络中的所有比特币节点都可以按区块号得出相同的数额：</p><p><img src="/../images/how-did-satoshi-think-of-bitcoin/how-satoshi-think-of-bitcoin-10.png" alt="how-satoshi-think-of-bitcoin-10"></p><p>而共识价格计算的后一半是决定需要多少的计算量。再一次，网络中的所有节点都可以计算出相同的数值（我们回在下一章细说这种难度调整）：</p><p><img src="/../images/how-did-satoshi-think-of-bitcoin/how-satoshi-think-of-bitcoin-11.png" alt="how-satoshi-think-of-bitcoin-11"></p><p>两者结合，区块补贴和难度就定义了比特币当前的要价，以计算量为标价单位。因为区块链得到了共识，所以这个价格是经过共识的价格。</p><p>b-money 也假定用户拥有一个经过共识的 “区块链”，包含了所有交易的历史。但 Wei Dai 从未得出这样简单的解决方案：完全根据区块链中的数据，为 b-money 的创造定出一个共识要价。</p><p>相反，Wei Dai 假设货币创造必须一直持续下去。因此，用户个人需要拥有影响货币政策的权力 —— 就像在法币中一样。这种感觉让 Wei Dai 设计了一种复杂到让 b-money 无法实现的投标系统。</p><p>而在中本聪这里，预先定义的货币政策消除了额外的复杂性。</p><h3 id="时间消灭所有偏离（Time-closes-all-spreads）"><a href="#时间消灭所有偏离（Time-closes-all-spreads）" class="headerlink" title="时间消灭所有偏离（Time closes all spreads）"></a>时间消灭所有偏离（Time closes all spreads）</h3><p>在 b-money 的 “计算” 阶段，用户执行自己在先前的标书中承诺的计算。在比特币中，整个网络作为卖方 —— 那么买方在哪？</p><p>在电邮交付市场上，买方是想发送电邮的用户。作为定价权威，邮件服务商会设定他们觉得对普通用户足够便宜但对诈骗犯足够贵的价格。但如果普通用户的数量增加，这个价格可以保持不变，因为普通用户的计算力可能没有变化。</p><p>而在 b-money 中，每个提出了货币创建标书的用户都被预期自行执行相应数量的计算。每个用户都根据对自己计算力的知识，担当自己的定价权威。</p><p>比特币网络为最新的区块补贴提供了一个以计算标记的要价。但没有哪一个找出区块的矿工需要执行这么多次数的计算 <sup><a href="#note9" id="jump-9">[9]</a></sup> 。胜出的区块表明的是所有矿工集体执行了所要求的计算次数。因此，区块补贴的买家是全球的比特币挖矿产业。</p><p>得出一个共识要价之后，比特币网络不会改变价格，直到更多区块被生产出来。这些区块必须包含当前要价所要求的工作量证明。因此，挖矿产业没有选择，只要他们想 “成交生意”，就必须付出这么多计算量。</p><p>挖矿产业唯一能控制的变量就是自己要多长时间才能生产出下一个区块。就像比特币网络可以给出一个要价，挖矿产业也能给出一个投标 —— 生产符合网络当前要价的下一个区块所需花费的时间。</p><blockquote><p><em>“为了对冲不断增加的硬件速度和运行节点的兴趣变化，工作量证明的难度会用一个瞄准每小时出块数量的移动平均值来决定。如果产生区块的速度太快了，难度就提高。”</em></p><p>—— 中本聪，2009</p></blockquote><p>中本聪只是平实地介绍了难度调整算法；但这个算法常常被认为是比特币实现中最具原创性的观念之一。确实如此，但与其关注这个解决方案的创新性，我们不如先看看为什么解决这个问题对中本聪来说如此重要。</p><p>Bit gold 和 b-money 这样的项目不需要限制货币增发率，因为它们没有固定的供给量或者说预先决定的货币政策。货币增发的周期变得更快或更慢可以通过其它手段来抵消，例如，外部经销商，将 bit gold 合并成更大的的套装（或拆分成更小的）；或者，b-money 的用户可以改变自己的标书。</p><p>但中本聪的货币政策目标要求比特币有一个预先定义的 “增发”（解锁新比特币进入流通）率。约束区块制造的（统计学）速度对比特币来说是自然而然的，因为区块生成的速度就是卖出比特币初始供应量的速度。用 140 年时间卖出 2100 万 BTC，跟 3 个月卖光，是完全不同的。</p><p>而且，比特币能真正实现这种约束，是因为区块链是 Nick Szabo 所说的 “安全时间戳协议”。中本聪说比特币是一种 “点对点基础上的分布式时间戳服务端”，而且早期的比特币源代码使用 “时间链（timechain）” 而非 “区块链（blockchain）” 来指称这种实现比特币 PoW 市场的共享数据结构 <sup><a href="#note10" id="jump-10">[10]</a></sup> 。</p><p><img src="/../images/how-did-satoshi-think-of-bitcoin/how-satoshi-think-of-bitcoin-12.png" alt="how-satoshi-think-of-bitcoin-12"></p><p style="text-align:center">- 不像 bit gold 和 b-money，比特币中的钱币不会出现供给过剩。比特币网络使用难度调整算法来改变货币的价格，以应对计算的供给变化 -</p><p>比特币的难度调整算法利用了区块链的能力。经过共识的区块链被参与者用来枚举挖矿产业的历史投标以及重新调整难度，以趋向目标出块时间。</p><h3 id="长期秩序创造共识"><a href="#长期秩序创造共识" class="headerlink" title="长期秩序创造共识"></a>长期秩序创造共识</h3><p>对健全货币政策的渴求所产生的简化链条延伸到 b-money 的 “货币创造” 阶段。</p><p>在 b-money 中，用户提交的投标会有 “无利害关系（nothing at stake）” 问题。没有机制能阻止用户提交用非常少的工作量竞标大量的 b-money。这需要网络跟踪已经完成的投标并只接受 “最高的投标……以名义成本除以创造出来的 b-money 数量来衡量”，以避免这样的骚扰式竞标。B-money 的每一个参与者都必须跟踪完整的投标订单簿，但标书与他们后续的计算关联起来，并仅仅以结算以最高价格完成的订单。</p><p>这个问题是一个更广义的问题 —— 去中心化系统中的共识问题 —— 的一个例子。去中心化系统中的共识问题也叫做 “拜占庭将军” 问题，有时候，在电子货币语境下也被称作 “重复花费” 问题。在所有参与者之间分发相同的有序数据，在一个敌对的、去中心化的网络中是困难的。当时对这个问题又一个解决方案，叫做 “拜占庭容错（BFT）共识算法”，需要在参与者之间有一些预先协调，而且大多数参与者（&gt; 67%）不会采取恶意行动。</p><p>比特币并不需要管理投标的订单簿，因为比特币网络给出了一个单一的要价。这意味着比特币节点可以接受自己看到的第一个（有效的）满足网络当前要价的区块 —— 骚扰性的投标可以直接忽略掉，而且制作这样的骚扰性投标也会浪费某个矿工的资源。</p><p>共识的计算价格让比特币中买卖订单的匹配可以优雅地完成：先到先得。这样优雅的订单匹配，也意味着比特币的市场不像 b-money 那样需要划分阶段 —— 它可以不间断地运行，每当一个订单得到匹配（找到一个新区块），就可以计算出一个新的共识价格。为了避免因网络延迟和敌意行为导致的网络分叉，节点也必须遵循 “最重链规则”。这种贪婪的订单结算规则保证了只有最高的标价可以被网络接受。</p><p>这种结合了优雅和贪婪的算法 —— 节点接受看到的第一个有效的区块，然后总是跟随最重的区块链 —— 是一种新的拜占庭容错算法，可以让对区块序列的共识迅速收敛。中本聪在白皮书中用了 25% 的篇幅来证明这个论点 <sup><a href="#note11" id="jump-11">[11]</a></sup> 。</p><p>我们在上一章确立的理解是，比特币的共识要价依赖于得到共识的区块链。但事实证明，存在一个单一的共识要价，是这个计算市场能够优雅地匹配订单的原因；而计算市场能够优雅地匹配订单，又是能够达成共识的原因！</p><p>而且，这种新的 “中本聪共识” 只需要 50% 的参与者不采取恶意行动，是对原有技术的重大提升。是中本聪这样的密码朋克作出了这个计算机科学理论的突破，而不是传统的学术研究者或产业研究者，因为中本聪仅仅专注于实现健全货币，而不是分布式计算的通用共识算法。</p><h2 id="IV-结论"><a href="#IV-结论" class="headerlink" title="IV. 结论"></a>IV. 结论</h2><p>B-money 是开发电子货币的一个强大的框架，但并非完整的解决方案，因为它没有一种货币政策。用预先确定的解锁日程表约束货币发行，通过消除跟踪用户提交的货币创造标书并在其中选择的需要，减少了协议的范围并简化了实现。保护中本聪发行日程表的韵律引出了难度调整算法，并使中本聪共识成为可能；后者被广泛认为是比特币实现中最创新的一面。</p><p>比特币的完整设计比我们目前讨论的东西要多得多。我们这篇文章仅仅关注比特币中的 “首要” 市场，解锁比特币供给量进入流通的市场。</p><p>本系列的下一篇文章会探究比特币交易结算的市场，以及它跟分发比特币供给量的市场的关联。这种关联将为在比特币基础上建立去中心化服务的期货市场给出方法论。</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>多年来，我一直在谈论比特币和市场。我必须感谢许多人，他们倾听我的观点并帮助我理清思路。尤其是 <a href="https://twitter.com/RyanTheGentry">Ryan Gentry</a>、<a href="https://twitter.com/willcole">Will Cole</a> 和 <a href="https://twitter.com/stephenjhall">Stephen Hall</a>，他们每周都与我见面，讨论这些想法。如果没有他们的帮助和支持，我没法跨越不计其数的错误起点。Ryan 也帮助我在我们的 <a href="https://www.youtube.com/watch?v=qlV5_udJkC0">Bitcoin 2021 谈话</a>中公开讲述这些想法。<a href="https://twitter.com/arbedout">Afsheen Bigdeli</a>、<a href="https://twitter.com/allenf32">Allen Farrington</a>、<a href="https://twitter.com/josephkelly">Joe Kelly</a>、<a href="https://twitter.com/dergigi">Gigi</a>、<a href="https://twitter.com/TuurDemeester">Tuur Demeester</a> 和 <a href="https://twitter.com/MartyBent">Marty Bent</a>，都一直在鼓励我并给我有价值的反馈。我必须向 Allen 道歉，我是如此糟糕的一个合作者。最后，<a href="https://twitter.com/bitstein">Michael Goldstein</a> 可能因写作和表情包而出名，但我想感谢他在 <a href="https://nakamotoinstitute.org/">Nakamoto Institute</a> 的档案工作，让电子货币的历史得以保留。</p><blockquote><p><em>译者注：作者在 BitBlockBoom 2023 上发表了同名演讲。视频可见：<a href="https://www.youtube.com/watch?v=RH12p2G1G98">https://www.youtube.com/watch?v=RH12p2G1G98</a></em></p></blockquote><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>1.<a id="note1"> </a>本系列的标题取自历史上的第一条电报消息，由 Samuel Morse 在 1844 年发出：“上帝造了什么？” <a href="#jump-1">↩</a></p><p>2.<a id="note2"> </a><em>Bitcoin: A Peer-to-Peer Electronic Cash System</em> ，可见：<a href="https://bitcoin.org/bitcoin.pdf">https://bitcoin.org/bitcoin.pdf</a> <a href="#jump-2">↩</a></p><p>3.<a id="note3"> </a><em>Pricing via Processing or Combatting Junk Mail</em>，来自 Dwork &amp; Naor，可见：<a href="https://www.wisdom.weizmann.ac.il/~naor/PAPERS/pvp.pdf">https://www.wisdom.weizmann.ac.il/~naor/PAPERS/pvp.pdf</a> <a href="#jump-3">↩</a></p><p>4.<a id="note4"> </a>虽然发明了这种观念，但 Dwork 和 Naor 并没有发明 “工作量证明” 这个词 —— 这个绰号是 Markus Jakobsson 和 Ari Juels 在 1999 年提出的。 <a href="#jump-4">↩</a></p><p>5.<a id="note5"> </a>Hal Finney 的 RPOW 项目是一种创建可转移的工作量证明的尝试，但比特币并没有使用这个概念，因为比特币并不把计算当成货币。在下文讨论 bit gold 和 b-money 时，我们会看出，计算无法成为货币，因为不同时代的计算有不同的价值，但两个货币单位的价值必须是相等的。比特币不是计算，比特币是一种可以用计算买到的货币。 <a href="#jump-5">↩</a></p><p>6.<a id="note6"> </a>在这个当口，一些读者可能会认为我因为 Wei Dai 或 Nick Szabo 在一些问题上语焉不详或闭口不谈而轻视他们的贡献。我的感受正好相反：Wei Dai 和 Nick Szabo 在根本上都是对的，他们没有像中本聪日后做的那样勾勒所有细节，并不能抹杀他们的贡献。相反，这应该引起我们的敬佩，因为这表明了电子货币是多么困难的一件事，即使对这个领域最好的实践者来说也是如此。 <a href="#jump-6">↩</a></p><p>7.<a id="note7"> </a>Wei Dai 的 b-money 文章位列中本聪白皮书参考文献的第一位，可见：<a href="http://www.weidai.com/bmoney.txt">http://www.weidai.com/bmoney.txt</a> <a href="#jump-7">↩</a></p><p>8.<a id="note8"> </a>这里作了两部分简化：（a）每个区块卖出的比特币的数量也受到交易费市场的影响，但这超出了本文的范围，留待我们后续的工作；（b）比特币所报告的难度并不确切等于预期计算的次数；你还必须乘以一个比例因子。 <a href="#jump-8">↩</a></p><p>9.<a id="note9"> </a>至少从中本聪是网络上唯一矿工的黑暗时代结束之后，就不再如此了。 <a href="#jump-9">↩</a></p><p>10.<a id="note10"> </a>Gigi 的经典作品 <em>比特币就是时钟</em> 是对比特币与时间的深刻关系的绝佳介绍，可见：<a href="https://dergigi.com/2021/01/14/bitcoin-is-time/">https://dergigi.com/2021/01/14/bitcoin-is-time/</a> （<a href="https://dergigi.com/2021/01/14/bitcoin-is-time/">中文译本</a>） <a href="#jump-10">↩</a></p><p>11.<a id="note11"> </a>中本聪在白皮书的分析和后续的比特币初步实现中都犯了错误，使用了 “最长链” 规则而不是 “最重链” 规则。 <a href="#jump-11">↩</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;作者：UNCHAINED &amp;amp; Dhruv Bansal&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;来源：&lt;a href=&quot;https://bitcoinmagazine.com/technical/how-did-satoshi-think-</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>建立你的比特币 “用户名”</title>
    <link href="https://www.btcstudy.org/2024/07/24/setting-up-a-bitcoin-username/"/>
    <id>https://www.btcstudy.org/2024/07/24/setting-up-a-bitcoin-username/</id>
    <published>2024-07-24T04:11:03.000Z</published>
    <updated>2024-09-02T04:30:25.049Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：sethforprivacy</em></p><p><em>来源：<a href="https://sethforprivacy.com/guides/setting-up-a-bitcoin-username/">https://sethforprivacy.com/guides/setting-up-a-bitcoin-username/</a></em></p></blockquote><p>在密码货币世界里，最困难的事情之一就是找出能够重复给同一人支付、<em>无需劳烦他们每次都给出新地址</em> 的办法。这一用户体验障碍背后的核心技术难题，在 Monero 中从一开始就使用 “隐身地址（stealth address）” 解决掉了；而在比特币中，最近得到越来越多采用的 “静默支付（<a href="https://silentpayments.xyz/">Silent Payments</a>）”（本质上就是为比特币设计的隐身地址）以及 <a href="https://bolt12.org/">BOLT 12</a> offer（为闪电网络设计的可复用且保护隐私的发票）也在技术上解决了问题。</p><p>但是，即使你有了一种又可以保持隐私、又可以重复使用的支付方法，别人怎么找到你呢？他们是给你发信息，让你给他们一串又长又乱的字符？还是你应该把它粘贴到你的推特个人简介里呢？还是说，你应该发到 nostr 网络中？<a href="https://bips.dev/353/">BIP 353</a> 就尝试解决这个问题，让支付信息更容易获得 <em>且无需信息发布者运行一个服务器</em>。直接把你的支付信息添加为一个 DNS 条目（准确来说是一个 “文本（TXT）” 记录，我们下文会详细说），然后任何支持 BIP353 的钱包就可以安全地解析和验证支付细节，无需任何人工参与。</p><p>本质上，BIP 353 给了每个拥有域名的人设置自定义比特币用户名的能力（而且只需点几下鼠标）。</p><h2 id="我应该使用哪种支付信息？"><a href="#我应该使用哪种支付信息？" class="headerlink" title="我应该使用哪种支付信息？"></a>我应该使用哪种支付信息？</h2><p>关于比特币用户名，一个至关重要的意识是：你 <em>绝不应该</em> 在用户名中使用标准的比特币地址或一次性的 BOLT11 发票。将一个标准的比特币地址作为你的用户名（公开暴露），将使所有人都能轻易看到 送到这个地址的交易 以及 从这个地址发出的交易，因为你也在迫使给你支付的人都重复使用这个地址（作为你的收款地址）。不应使用 BOLT11 发票的理由则恰好完全相反，BOLT11 发票都是一次性使用的，所以把它设为你的用户名，你就需要不断轮换：每当有人给你成功支付一次，你就要换上一个新的发票；这个痛苦的过程需要某种形式的自动化。（译者注：出于隐私保护的理由，也不应公开暴露 BOLT11 发票，因为它会暴露你用于收款的闪电节点的身份。在隐私性上不如下文要提到的 BOLT12 offer。）</p><p>感谢日益得到更多支持的静默支付和 BOLT12，现如今，在 <a href="https://cakewallet.com/">Cake Wallet</a>、<a href="https://phoenix.acinq.co/">Phoenix Wallet</a> 和 <a href="https://zeusln.com/">Zeus</a> 这些集成了两者的钱包中，用户可以容易生成这两种分别为链上收款和闪电支付设计的可复用支付码，你只需设置一个静态的 DNS 记录，就可以重复获得支付，没有人能把你收到的两笔交易关联起来。</p><h2 id="隐私与安全顾虑"><a href="#隐私与安全顾虑" class="headerlink" title="隐私与安全顾虑"></a>隐私与安全顾虑</h2><p>我认为，虽然 DNS 本身不是十全十美，它为用户体验带来的力量可以胜过其缺点。匿名地注册一个域名、使用保持隐私的支付码，然后使用 BIP 353 中的 DNSSEC 来保护你免遭最简单的攻击，还是非常容易的。话虽这么说，在建立和使用比特币用户名的过程中，还是有一些简单的提醒，你要牢记：</p><ol><li>确保使用一个著名且可信任的域名供应商！<ol><li>恶意的域名运营商（或哪怕仅仅是被攻击的无能服务商）可能会将你的收款细节替换成他们自己的。虽然这是极为罕见的情况，但也是有可能的，而最简单的解决方案就是只使用著名的、经过考验的域名供应商。最著名、可信任且接受比特币支付的两个域名供应商是 Njalla（本教程就使用它们）以及 Namecheap 。</li></ol></li><li>理想情况下，使用可以提供域名隐私性的域名供应商，以及不要求提供真实身份信息的供应商。<ol><li>绝大部分域名供应商都给你提供了隐藏用来注册域名的信息（即，姓名、地址、联系方式）的选择，但也有一些供应商默认不提供。Njalla 默认保护你的信息，但 Namecheap 有一个额外的附加选项，你需要 购买&#x2F;启用 才能保护你的信息。就目前来看，我觉得它应该会永久免费，但具体来说 Namecheap 未来可能会改变。</li></ol></li><li>在用户名中仅使用保持隐私的支付信息。</li><li>就像静默支付的地址和 BOLT12 offer，你的域名也不会改变。虽然这可以提供一种类型的隐私性（防止地址复用、保护你的闪电节点的隐私性），<em>当你在多个平台上分享同一个域名时，其他人也将知道分享者是同一个人</em>。请确保你的用户从一开始就是 匿名&#x2F;准匿名的，跟你的真实身份没有关联。</li></ol><h2 id="获得一个静默支付地址-以及-或者-BOLT12-offer"><a href="#获得一个静默支付地址-以及-或者-BOLT12-offer" class="headerlink" title="获得一个静默支付地址 以及&#x2F;或者 BOLT12 offer"></a>获得一个静默支付地址 以及&#x2F;或者 BOLT12 offer</h2><p>我会列出三个 app，它们是我最喜欢用来获得可复用且保持隐私的支付信息的应用，不过，在比特币生态系统中支持这种功能的 app 数量可能会迎来大爆发！如果你已经在使用以下其中一款钱包，可以跟随我列出的步骤；如果你用的是别家的应用，那还是选择你喜欢的应用，跳过这一段。</p><h3 id="通过-Cake-Wallet-获得静默支付地址"><a href="#通过-Cake-Wallet-获得静默支付地址" class="headerlink" title="通过 Cake Wallet 获得静默支付地址"></a>通过 Cake Wallet 获得静默支付地址</h3><ol><li>下载 <a href="https://cakewallet.com/">Cake Wallet</a>（译者注：如果你不是直接从正式的应用平台下载 app，请记得验证签名）</li><li>新建一个比特币钱包</li><li>备份这套新的种子词！</li><li>点击底部的 “Receive（收款）” 按钮</li><li>点击顶部 “Receive” 图标旁边的下拉菜单</li><li>选择 “Silent Payment（静默支付）”</li><li>复制这个支付码，然后发送给你自己，以便于在你的电脑上 复制-粘贴 它。要使用 Signal 的 “Note to Self” 这样的功能。（译者注：意思是使用安全的通讯方式。使用互联网的通讯工具来传输敏感数据是一种不推荐的做法。原作者在这里提到的 “Signal” 是一种端到端的加密通讯软件，理论上可以避免被服务商破译。但如果你的即时通讯工具没有端到端加密功能，请一定不要使用这种方式。应该使用 SD 卡&#x2F;U 盘 或 本地网络。）</li></ol><h3 id="通过-Phoenix-Wallet-获得-BOLT12-Offer"><a href="#通过-Phoenix-Wallet-获得-BOLT12-Offer" class="headerlink" title="通过 Phoenix Wallet 获得 BOLT12 Offer"></a>通过 Phoenix Wallet 获得 BOLT12 Offer</h3><ol><li>下载 <a href="https://phoenix.acinq.co/">Phoenix Wallet</a></li><li>完成钱包初始化</li><li>备份你的新种子词！</li><li>点击底部的 “Receive（收款）” 按钮</li><li>点击 “展示可复用的 QR 码”</li><li>复制它，使用 Signal 的 “Note to Self” 或类似功能分享给自己</li></ol><h2 id="通过-Zeus-获得-BOLT12-Offer"><a href="#通过-Zeus-获得-BOLT12-Offer" class="headerlink" title="通过 Zeus 获得 BOLT12 Offer"></a>通过 Zeus 获得 BOLT12 Offer</h2><ol><li>下载 <a href="https://zeusln.com/">Zeus</a></li><li>建立一个新钱包（要么快速启动一个内置的节点，要么连接到你自己的 CLN 节点）<ol><li>注意，LND 本身还不支持 BOLT12，而且近期看不到支持的迹象，令人遗憾</li></ol></li><li>保存你的种子词（如果有需要的话）</li><li>在主屏幕的闪电图标上从左到右滑动</li><li>点击 “Pay Codes（支付码）”</li><li>（如有需要）为这个 BOLT12 支付码设置一个标签</li><li>选择新的支付码</li><li>长按 BOLT12 字符串以复制这个 offer，然后发送给你自己，以便于在电脑上复制粘贴</li></ol><h2 id="获得一个域名"><a href="#获得一个域名" class="headerlink" title="获得一个域名"></a>获得一个域名</h2><p>现在，来到整个流程最难的一步了。为了使用 BIP353，你需要拥有一个域名（比如我的 <code>sethforpricacy.com</code> ），然后才能把这些支付指令放上去。流程还是非常直接的，不过我会带你有我最喜欢的域名注册器 <a href="https://njal.la/">Njalla</a> 完全走一遍。这些步骤需要你使用 Tor 浏览器，以便在设置域名时获得多一点匿名性；但如果你认为这没必要（你也计划在别的可能关联到你真实身份的地方使用这个域名），那么你可以使用常常规的网站。</p><ol><li><p>如果你还没有，请下载 Tor 浏览器</p></li><li><p>打开 Tor 浏览器，访问 <code>https://njallalafimoej5i4eg7vlnqjvmb6zhdh27qxcatdn647jtwwwui3nad.onion/</code> </p></li><li><p>搜索你认为有趣的域名，想搜什么就搜什么</p><p><img src="/../images/setting-up-a-bitcoin-username/njalla-1.png" alt="njalla-1"></p></li><li><p>如果你发现了一个喜欢的域名，就点击 “Select domain”</p><p><img src="/../images/setting-up-a-bitcoin-username/njalla-2.png" alt="njalla-2"></p></li><li><p>选择 “Check out（结账）”</p></li><li><p>创建一个账户</p><ol><li>理想情况下，你应该使用 <a href="https://simplelogin.io/">SimpleLogin</a>（或类似工具），使用一个电子邮箱昵称（而不是真实的电子邮箱地址）</li><li>此外，你应该使用一个强度高、唯一的口令。可以使用 <a href="https://bitwarden.com/">Bitwarden</a> 这样的工具</li></ol><p><img src="/../images/setting-up-a-bitcoin-username/njalla-3.png" alt="img"></p></li><li><p>进入购物清单后，点击右下角的 “Add funds（充值）” 按钮</p><p><img src="/../images/setting-up-a-bitcoin-username/njalla-4.png" alt="njalla-4"></p></li><li><p>使用你喜欢的支付方式充值</p><ol><li>我会强烈建议你使用保持隐私的支付手段，比如 Monero（或者混币之后的比特币），以保证域名跟你之间没有金融上的联系</li></ol><p><img src="/../images/setting-up-a-bitcoin-username/njalla-5.png" alt="njalla-5"></p></li><li><p>资金到账之后，选择 “Pay Now（现在支付）”</p></li></ol><p>这就完成了！现在，你是一个新域名的主人了，你可以使用 BIP 353 比特币用户名（以及域名的其它功能）了！</p><h2 id="建立你的比特币用户名"><a href="#建立你的比特币用户名" class="headerlink" title="建立你的比特币用户名"></a>建立你的比特币用户名</h2><p>拥有域名之后，就到了设置你的比特币用户名的时候了。切记，你要先创建一个静默支付地址，或者 BOLT12 Offer。先登录你之前建好的 Njalla 账户（或者你选择的别的域名供应商的管理界面），然后再开始。</p><p>因为 Namechaep 是另一个非常流行的域名供应商，我也会在下面列出使用 Namcheap 的配置流程。</p><h3 id="在-Njalla-上创建你的比特币用户名"><a href="#在-Njalla-上创建你的比特币用户名" class="headerlink" title="在 Njalla 上创建你的比特币用户名"></a>在 Njalla 上创建你的比特币用户名</h3><ol><li><p>跳转到 “Domains（域名）” 页面</p></li><li><p>点击你要设置的域名右边的  “Manage（管理）” 按钮</p></li><li><p>选择页面左边的 “Add record（添加记录）” 按钮</p></li><li><p>将 “Type（类型）” 下拉菜单中的 “A” 改成 “TXT”</p></li><li><p>在 “Name（姓名）” 字段，输入 <code>username.user._bitcoin-payment</code>，记得把这里的 <code>username</code> 改成你喜欢的词（比如 <code>tips</code>）</p><ol><li>这个 <code>username</code> 就将成为你的 BIP 353 地址位于 <code>@域名.com</code> 前面的部分</li></ol></li><li><p>在 “Content（内容）”字段，你需要创建特定格式的字符串（由 <a href="https://bips.dev/21/">BIP 21</a> 指定）</p><ol><li><p>如果你只想使用 BOLT12 Offer，输入下列字符，并将 “REPLACE_ME” 换成你的 BOLT12 Offer（你从 Phoenix 或 Zeus 中得到的、以 <code>lno</code> 开头的字符串）</p><ol><li><code>bitcoin:?lno=REPLACE_ME</code></li><li>例如：<code>bitcoin:?lno=lno1pgqpvggzrdhszmg5yafguxmkm779vd8jftxskjyadjdrallmq8uxfjdjfyaq</code></li></ol></li><li><p>如果你只想使用静默支付，输入下列字符，并将 “REPLACE_ME” 换成你的静默支付地址（你从 Cake Wallet 中获得的 <code>sp1</code> 开头的字符串）</p><ol><li><code>bitcoin:?sp=REPLACE_ME</code></li><li>例如：<code>bitcoin:?sp=sp1qqweplq6ylpfrzuq6hfznzmv28djsraupudz0s0dclyt8erh70pgwxqkz2ydatksrdzf770umsntsmcjp4kcz7jqu03jeszh0gdmpjzmrf5u4zh0c</code></li></ol></li><li><p>如果你想同时使用两者，那么输入以下字符，并将 “REPLACE_ME_BOLT_12” 替换成你的 BOLT12 offer，将 “REPLACE_ME_SP” 替换成你的静默支付地址</p><ol><li><code>bitcoin:?lno=REPLACE_ME_BOLT_12&amp;sp=REPLACE_ME_SP</code></li><li>例如：<code>bitcoin:?lno=lno1pgqpvggzrdhszmg5yafguxmkm779vd8jftxskjyadjdrallmq8uxfjdjfyaq&amp;sp=sp1qqweplq6ylpfrzuq6hfznzmv28djsraupudz0s0dclyt8erh70pgwxqkz2ydatksrdzf770umsntsmcjp4kcz7jqu03jeszh0gdmpjzmrf5u4zh0c</code></li></ol><p><img src="/../images/setting-up-a-bitcoin-username/njalla-7.png" alt="njalla-7"></p></li></ol></li><li><p>点击右边的 “Add（添加）” 按钮</p></li><li><p>跳转到 “DNSSEC” 页面</p></li><li><p>选择 “启用 DNSSEC”</p><ol><li>DNSSEC 是一种协议，可以保证除了你和正式的 DNS 服务器之外，没人能替换你的 TXT 记录，这是 BIP353 的关键安全错许昌。没有它，你的用户名就无从谈起！</li></ol></li></ol><p>这就是全部啦！现在，你应该可以用你的新的用户名来收取支付啦，它的形式是 “<a href="mailto:username@domain.com">username@domain.com</a>” 这样的，在我们这里，是 <code>tips@bip353.com</code> 。</p><h3 id="在-Namecheap-上创建你的比特币用户名"><a href="#在-Namecheap-上创建你的比特币用户名" class="headerlink" title="在 Namecheap 上创建你的比特币用户名"></a>在 Namecheap 上创建你的比特币用户名</h3><ol><li><p>登录你的<a href="https://ap.www.namecheap.com/dashboard">管理面板</a></p></li><li><p>点击你的域名右边的 “Manage（管理）” 按钮</p></li><li><p>选择页面顶部右边的 “Advanced DNS（高级 DNS）” 页面</p><p><img src="/../images/setting-up-a-bitcoin-username/namecheap-1.png" alt="namecheap-1"></p></li><li><p>选择 “Host Records（托管记录）” 细分选项的 “Add new record（添加新记录）” 功能</p><p><img src="/../images/setting-up-a-bitcoin-username/namecheap-2.png" alt="namecheap-2"></p></li><li><p>将下拉列表中的 “A record” 改为 “TXT record”</p></li><li><p>在 “Host（托管）” 字段，输入 <code>username.user._bitcoin-payment</code>，记得把这里的 <code>username</code> 改成你喜欢的词（比如 <code>tips</code>）</p><ol><li>这个 <code>username</code> 就将成为你的 BIP 353 地址位于 <code>@域名.com</code> 前面的部分</li></ol></li><li><p>在 “Content（内容）”字段，你需要创建特定格式的字符串（由 <a href="https://bips.dev/21/">BIP 21</a> 指定）</p><ol><li><p>如果你只想使用 BOLT12 Offer，输入下列字符，并将 “REPLACE_ME” 换成你的 BOLT12 Offer（你从 Phoenix 或 Zeus 中得到的、以 <code>lno</code> 开头的字符串）</p><ol><li><code>bitcoin:?lno=REPLACE_ME</code></li><li>例如：<code>bitcoin:?lno=lno1pgqpvggzrdhszmg5yafguxmkm779vd8jftxskjyadjdrallmq8uxfjdjfyaq</code></li></ol></li><li><p>如果你只想使用静默支付，输入下列字符，并将 “REPLACE_ME” 换成你的静默支付地址（你从 Cake Wallet 中获得的 <code>sp1</code> 开头的字符串）</p><ol><li><code>bitcoin:?sp=REPLACE_ME</code></li><li>例如：<code>bitcoin:?sp=sp1qqweplq6ylpfrzuq6hfznzmv28djsraupudz0s0dclyt8erh70pgwxqkz2ydatksrdzf770umsntsmcjp4kcz7jqu03jeszh0gdmpjzmrf5u4zh0c</code></li></ol></li><li><p>如果你想同时使用两者，那么输入以下字符，并将 “REPLACE_ME_BOLT_12” 替换成你的 BOLT12 offer，将 “REPLACE_ME_SP” 替换成你的静默支付地址</p><ol><li><code>bitcoin:?lno=REPLACE_ME_BOLT_12&amp;sp=REPLACE_ME_SP</code></li><li>例如：<code>bitcoin:?lno=lno1pgqpvggzrdhszmg5yafguxmkm779vd8jftxskjyadjdrallmq8uxfjdjfyaq&amp;sp=sp1qqweplq6ylpfrzuq6hfznzmv28djsraupudz0s0dclyt8erh70pgwxqkz2ydatksrdzf770umsntsmcjp4kcz7jqu03jeszh0gdmpjzmrf5u4zh0c</code></li></ol></li></ol><p> <img src="/../images/setting-up-a-bitcoin-username/namecheap-3.png" alt="namecheap-3"></p></li><li><p>点击页面右边的绿色勾，保存内容</p></li><li><p>确保 “Host Records” 项下的 DNSSEC 功能启用了</p><p><img src="/../images/setting-up-a-bitcoin-username/namecheap-4.png" alt="namecheap-4"></p></li></ol><h3 id="测试你的新用户名"><a href="#测试你的新用户名" class="headerlink" title="测试你的新用户名"></a>测试你的新用户名</h3><p>最好的工具是由 <a href="https://x.com/TheBlueMatt">TheBlueMatt</a>（BIP353 的作者）编写的。</p><ol><li><p>跳转到 <a href="https://satsto.me/">satsto.me</a></p></li><li><p>在文本框里输入你的新的 <a href="mailto:username@domain.com">username@domain.com</a></p><ol><li>（在我这里是 <code>tips@bip353.com</code>）</li></ol></li><li><p>看看解析出来的支付细节对不对</p><p><img src="/../images/setting-up-a-bitcoin-username/satstome.png" alt="satstome"></p></li></ol><p>你也可以用已经支持 BIP 353 的应用（比如 Phoenix Wallet）测试看看。</p><h2 id="Monero-用户名"><a href="#Monero-用户名" class="headerlink" title="Monero 用户名"></a>Monero 用户名</h2><p>如果你只使用 Monero，有一个已经受到支持的、非常相似的协议，叫做 Open Alias。（略）</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>看到 BIP 353 用户名协议的采用在增加，我非常激动，因为它让可复用且保持隐私的支付手段更易于找寻和使用。希望这份教程能帮助更多人建立自己的用户名并传播出去！如果你觉得这份指南还是太难了（或者你就是不想处理跟域名相关的东西），可以看看 <a href="https://twelve.cash/">twelve.cash</a> ，一个神奇（但可信任！）的服务。</p><p>如果你对这份指南有任何疑问，或希望寻找某个方面的更多信息，请<a href="https://sethforprivacy.com/about/#how-to-contact-me">联系我</a>。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">让支付信息更容易获得且无需信息发布者运行一个服务器</summary>
    
    
    
    
    <category term="实践" scheme="https://www.btcstudy.org/tags/%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>OP_CAT：限制条款的完美解决方案？</title>
    <link href="https://www.btcstudy.org/2024/07/18/op-cat-the-purr-fect-solution-for-covenants/"/>
    <id>https://www.btcstudy.org/2024/07/18/op-cat-the-purr-fect-solution-for-covenants/</id>
    <published>2024-07-18T06:03:55.000Z</published>
    <updated>2024-09-02T04:30:25.041Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Kiara Bickers</em></p><p><em>来源：<a href="https://blog.blockstream.com/op_cat-the-purr-fect-solution-for-covenants/">https://blog.blockstream.com/op_cat-the-purr-fect-solution-for-covenants/</a></em></p></blockquote><p>OP_CAT 会激活吗？作为一种限制条款提议，它最近得到了 <a href="https://github.com/bitcoin/bips/blob/master/bip-0347.mediawiki?ref=blog.blockstream.com">347</a> 的 BIP 编号。但在我们深入讲解它之前，先来了解一下 “限制条款（covenant）” 是什么，以及人们为什么想要这种功能。</p><p>比特币是电子 e-cash 的一种理想状态吗？还是说，我们想从链上的钱币中得到更多东西呢？</p><h2 id="浮光掠影：比特币脚本的局限性"><a href="#浮光掠影：比特币脚本的局限性" class="headerlink" title="浮光掠影：比特币脚本的局限性"></a>浮光掠影：比特币脚本的局限性</h2><p>要理解 OP_CAT 这样的限制条款提议，我们先要理解今天的比特币脚本（<a href="https://glossary.blockstream.com/bitcoin-script/?ref=blog.blockstream.com">Bitcoin Script</a>）的根本局限性。在表象之下，比特币允许创建基本的智能合约：用代码来定义锁定和解锁资金的规则。但是，其编程语言 Bitcoin Script 非常局限，仅在交易要移动资金时产生作用。</p><p><em>在今天的比特币上，你没有办法预先配置或者说指定你的钱币的转移路径，也无法在锁定一笔资金时限定该笔资金的取款速度（除非你使用基于 PSBT（待签名的比特币交易）的非常规工作流程，但这既无法很好地处理交易手续费，也无法在决定不再使用时可靠地删除、阻止广播）。</em></p><p>这种简洁性，虽说是比特币的安全模型的核心，还是给 Script 这种脚本语言支持（哪怕是基本的）智能合约的能力带来了显著的局限性。</p><h3 id="线性执行模式"><a href="#线性执行模式" class="headerlink" title="线性执行模式"></a>线性执行模式</h3><p>Bitcoin Script 的局限性之一在于其操作模式：<a href="https://glossary.blockstream.com/opcode/?ref=blog.blockstream.com">操作码</a>是按顺序执行的，而且没有循环。</p><p><img src="/../images/op-cat-the-purr-fect-solution-for-covenants/linear-execution.png" alt="linear-execution"></p><p>以这个 P2PKH 交易为例，你可以看出，脚本是线性执行的：复制公钥、将公钥哈希成一个地址、验证该哈希值与锁定脚本一致，最后用这个公钥来检查交易签名。</p><p>缺乏循环，意味着脚本不是图灵完备的、保证能终止运行，防止了可能会导致节点宕机或显著拖慢整个网络的无限循环操作。虽然这种设计选择让资源的消耗量是静态受限的，它也限制了 Script 管理复杂工作流的能力。</p><h3 id="缺乏基本的算术"><a href="#缺乏基本的算术" class="headerlink" title="缺乏基本的算术"></a>缺乏基本的算术</h3><p>Bitcoin Script 只有不到 100 个重要的操作码，有时候会令人吃惊：它不能乘、除，也不能组合堆栈中的对象。许多对 OP_CAT 感兴趣的用户可能知道，中本聪在 2010 年<a href="https://github.com/bitcoin/bitcoin/commit/4bd188c4383d6e614e18f79dc337fbabe8464c82?ref=blog.blockstream.com">禁用了</a>比特币的多个操作码，包括 OP_OR、OP_MUL（乘法）、OP_DIV（除法）以及 OP_CAT（字符串拼接）等。这些被禁用的操作码被移除了，因为它们的原本实现有可被爆破的漏洞，可能会牺牲网络的安全性。但缺乏这些操作码使得 Script 难以实现基本的数学运算，这在一些简单的场景中是有用的，比如，计算一个合约中的交易手续费。</p><h3 id="交易数据不可见"><a href="#交易数据不可见" class="headerlink" title="交易数据不可见"></a>交易数据不可见</h3><p>浅薄地说，我认为绝大多数人都假设比特币的智能合约可以看到交易的数额以及其他部分的数据，因为这些信息在区块链上是公开可见的。但实情正好相反，比特币中的合约无法设置基于交易数据的花费条件，因为 Bitcoin Script 了解交易数据的能力是非常有限的。</p><p>如果脚本有能力内省交易数据中的更多细节，我们就可以开发出健壮得多的智能合约，它可以做到所有有趣的实情，比如强制执行某一个花费条件、创建分阶段执行的交易，以及启用更高级的安全保管特性（比如 “保险柜合约（vault）”）。</p><h2 id="那么我们要怎么做呢？"><a href="#那么我们要怎么做呢？" class="headerlink" title="那么我们要怎么做呢？"></a>那么我们要怎么做呢？</h2><p>我们知道比特币有这些局限性，而且过去几年中，人们讨论了许多引入（有时是重新引入）这些功能的提议。Bitcoin Script 上的更前卫的实验，例如 Simplicity 语言及其它，致力于提供替代堆栈形式约束的方案。而 OP_MULTISHA256、OP_LESS 和 OP_LE32TOLE64 这样的操作码，则旨在升级比特币的运算能力。OP_CTV 和 OP_CAT 这样的处理<a href="https://glossary.blockstream.com/introspection-opcodes/?ref=blog.blockstream.com">内省操作码</a>的提议，则被归类为 “限制条款”。</p><p>那么，“智能合约” 与 “限制条款”，到底有何区别？</p><h2 id="智能合约-vs-限制条款"><a href="#智能合约-vs-限制条款" class="headerlink" title="智能合约 vs. 限制条款"></a>智能合约 vs. 限制条款</h2><p>智能合约是自执行（self-executing）的交易，无需中介就能转移资金。在今天的比特币上，智能合约局限在使用 Bitcoin Script 锁定和解锁比特币的操作上。限制条款旨在通过允许用户控制自己的资金在未来的交易中如何花费，来强化比特币的智能合约功能。</p><p>如果允许 Script 内省交易数据，我们就在实质上允许了这些数据被用在合约逻辑中。</p><p>这里列举几个为限制条款功能而提议的更有趣的内省操作码：</p><ol><li>OP_TXHASH：提供交易的输入（或输出）的哈希值，并给予 Script 基于交易数据来验证和强制执行条件的能力。</li><li>OP_CSFS + OP_CAT：这两种操作码允许脚本检查对任意数据（而不仅仅是对交易本身）的签名。这意味着，Script 可以验证基于交易数据和外部信息的条件，这就拓展了在比特币脚本内的验证操作的可能性。</li></ol><p>这两种操作码是有意望宽泛方向设计的，所以可以支持复杂的验证流程以及内省能力。还有一些则是有意窄化的，设计成了更局限的限制条款。</p><ol><li>OP_CHECKTEMPLATEVERIFY（CTV）：允许交易的输出嵌入后续一笔花费交易的模板，启用了更拘束的限制条款。</li><li>OP_VAULT：启用了一种专门用于保险柜合约的限制条款，让用户可以指定交易的目的地、但在时延结束之前不会真正移动资金。</li></ol><p>还有就是 OP_CAT，它不是直接启用内省能力的操作码……</p><ol><li>OP_CAT：允许 Script 将堆栈中的两个元素前后拼接，可以用来组合脚本中的信息碎片。</li></ol><p>OP_CAT 看起来没有任何内省能力，那怎么会被归类为限制条款呢？</p><h2 id="OP-CAT：释放所有可能"><a href="#OP-CAT：释放所有可能" class="headerlink" title="OP_CAT：释放所有可能"></a>OP_CAT：释放所有可能</h2><p>2021 年，Andrew Poelstra 在一篇<a href="https://blog.blockstream.com/cat-and-schnorr-tricks-i/">文章</a>中介绍了使用 OP_CAT 的内省技巧。他提供了具体的案例，只不过假设了读者对类似的技术有前置知识。</p><p>在 Bitcoin Script 中，只有三种主要的操作码可以内省交易数据：CHECKLOCKTIMEVERIFY（绝对时间锁）、CHECKSEQUENCEVERIFY（相对时间锁）以及 CHECKSIG（检查签名）。此外，它们还有一些变体，比如：CHECKSIGVERIFY、CHECKSIGADD、CHECKMULTISIG 和 CHECKMULTISIGVERIFY，本质上都是 CHECKSIG 的微型变体；前面两种让你可以看出检查是否能通过，只提供了非常狭窄的功能。CHECKSIG 是类似的，区别在于你可以从堆栈中抓取签名和公钥。有点意思。</p><p>以前，我们将 concatenation 理解成拼接两个元素的函数，但我们也可以使用它来分割一个元素 —— 将签名分割成 (r, s) 对。</p><p>怎么能从 OP_CAT（拼接） 中派生出 OP_SPLIT（分割）功能呢？</p><blockquote><p>“如果你有一些大体积的对象，你可以将它们分成两半，办法是要求用户在花费是提供这两段碎片。你可以 CAT 这两段碎片，再检查相等。每一种操作都可以用这种方法反转。使用 CAT，你就可以将签名分成两半。”</p><p>—— Andrew Poelstra，<a href="https://btctranscripts.com/tabconf/2021/2021-11-05-jeremy-rubin-andrew-poelstra-covenants/?ref=blog.blockstream.com">TABConf 2021</a>（<a href="https://www.btcstudy.org/2022/12/07/jeremy-rubin-andrew-poelstra-covenants-tabf-2021/">中文译本</a>）</p></blockquote><p>这到底是怎么回事？</p><p>用户先提供签名、公钥和被签名的交易，你可以将签名分成两半，然后用交易数据分别检查每一部分。这种技术可以视为一种分割，也可以视为一种拼接，因为它验证的是签名和公钥是一笔有效交易的一部分。</p><p>（译者注：此处的 “可以将数据分成两半” 指的并不是可以在脚本的运行中将一段数据拆成两段，而是将两段数据作为见证数据分别传入，然后用 CAT 将它们拼接起来，再运行原本要对完整数据运行的检查。有了这种办法，我们就可以在传入两段数据的时候先对它们进行额外的检查。）</p><p>这跟内省又有什么关系呢？</p><blockquote><p>“在 Taproot 中，我们已经有了 Schnorr 签名。使用 OP_CAT 和 Schnorr 签名验证操作码，经证明，我们可以得到一种非递归的限制条款：你可以确确实实得到一条交易的哈希值。不是被胡乱涂画过的交易哈希值哦，就是堆栈中所有交易数据的 SHA2 哈希值。”</p><p>—— Andrew Poelstra，<a href="https://btctranscripts.com/tabconf/2021/2021-11-05-jeremy-rubin-andrew-poelstra-covenants/?ref=blog.blockstream.com">TABConf 2021</a>（<a href="https://www.btcstudy.org/2022/12/07/jeremy-rubin-andrew-poelstra-covenants-tabf-2021/">中文译本</a>）</p></blockquote><p>Poelstra 在下文中演示了如何获得堆栈中剩下的交易输入或输出的 SHA2 哈希值。我们会跳过这些魔幻的数学，但启示就在于：使用 OP_CAT，我们将对交易的某些部分的约束，作为解锁脚本的要求。我们可以约束发送者的地址，或交易要发送的数额，而交易的哈希值将作为解锁资金的钥匙。</p><h3 id="保险柜"><a href="#保险柜" class="headerlink" title="保险柜"></a>保险柜</h3><p>使用相同的技巧，我们就有了交易内省能力，而且马上给我们一种基本的保险柜合约。沿着 Poelstra 在文章中的推理，一位名为 Rijndael 的开发者证明了我们只需 OP_CAT 就可以实现 <a href="https://delvingbitcoin.org/t/basic-vault-prototype-using-op-cat/576?ref=blog.blockstream.com">Purrfect Vaults</a>（“完美的保险柜”）。</p><blockquote><p>“在堆栈中重构一个 TXID 以内省以往的交易，比我想象中要更加简单。”</p><p>—— Rijndael</p></blockquote><p>使用保险柜，用户可以指定资金下一步要前往的地址，这提供了在密钥泄露时复原资金的机制，减少了盗窃私钥的激励。</p><h3 id="脚本内的默克尔树"><a href="#脚本内的默克尔树" class="headerlink" title="脚本内的默克尔树"></a>脚本内的默克尔树</h3><p>在今天的比特币上，“<a href="https://glossary.blockstream.com/merkle-tree/?ref=blog.blockstream.com">默克尔树</a>” 这种数据结构用于数据验证、同步，以及一定意义上 “绑定” 交易和区块。而 OP_CAT 可以拼接堆栈中的两个变量，当它跟公钥的 SHA256 哈希值一起使用的时候，就可以在脚本中实现一种直接的默克尔树验证程序。这种方法，最初由 Pieter Wuille 在 2015 年提出，已经在 <a href="https://liquid.net/?ref=blog.blockstream.com">Liquid</a> 中实现。</p><p>想象一棵满布不同花费条件（例如哈希原像、时间锁和公钥）的树结构，就是所谓的 “树形签名”。</p><h3 id="树形签名"><a href="#树形签名" class="headerlink" title="树形签名"></a>树形签名</h3><blockquote><p>“（树型签名）提供了一种多签名脚本，其大小与公钥的数量呈对数关系，而且可以编码 n-of-m 以外的花费条件。举个例子，小于 1 KB 的交易，可以支持拥有 1000 个公钥的树形签名。它也打开了逻辑泛化的花费条件。”</p><p>—— OP_CAT 作者 Ethan Heilman，发布于 <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-October/022049.html?ref=blog.blockstream.com">bitcoin-dev 邮件组</a></p></blockquote><p>这将能够验证树结构中的任何被哈希的内容，维持数据完整性以及可信度，而不会给区块链添加不必要的负担。</p><p>上面所有这些东西有趣的地方在哪里？</p><h3 id="递归型限制条款"><a href="#递归型限制条款" class="headerlink" title="递归型限制条款"></a>递归型限制条款</h3><p>如果你可以解读一笔交易并对其特定部分施加约束，你就可以建立能在多笔条件中延续的条件，也就是创造持续约束的链条。这个概念就叫 “递归型限制条款”。OP_CAT 是一个独特的协议，因为它用仅仅 10 行代码给了我们强大的力量。它能够解决我们在前面提到的所有局限性：交易数据可见性、更好的数学功能，以及线性的执行模式。</p><p>虽然 OP_CAT 乍看起来平平无奇，它解锁了巨大的潜能，可以被创造性利用。它还可以作为一个砖石，在本文讨论范围之外的更多功能上发挥作用，比如抗量子计算的 Lamport 签名。</p><h3 id="它安全吗？"><a href="#它安全吗？" class="headerlink" title="它安全吗？"></a>它安全吗？</h3><p>在 OP_CAT 最初被移除之前，结合 OP_DUP（复制堆栈），即使堆栈中最初被操作的对象只有 1 字节，通过反复运用这一对操作码，堆栈对象的体积也会迅速膨胀，直至挤爆内存。这可以用作一种 DoS 攻击。新提议通过对堆栈元素施加 520 字节的限制，轻松地防止了这种攻击。</p><p><strong>是否有创造出无限运行的合约的风险？</strong></p><p>如果这个问题的意思是，OP_CAT 改变脚本的线性执行模式是否意味着脚本不再能静态地约束其资源使用量（使之成为脚本体积的一个线性函数），那么答案是否定的。</p><p><strong>限制条款会在比特币上带来一个发行其它币的市场吗？</strong></p><p>如果我们有了递归型限制条款，那么技术上来说，你可以开发出复杂的 2 层应用，包括 NFT、去中心化交易所、电子猫，等等。但是，要想做出来并不容易。难以看出这会形成一个可观的市场。</p><p><strong>你可以使用 CAT 永久 “玷污” 一笔钱吗？</strong></p><p>在染色币和 NFT 的案例中，发行资产实际上会 “烧掉” 一聪，标记它以象征 “layer-2” 资产的所有权。这个过程是所谓的 “玷污”。但只有一笔钱的所有者才能标记他的钱，而且比特币的钱包也不能理解这一切（除非开发者加入了额外的代码来启用这个功能）。最终得到的钱币也不会被比特币钱包接受。也许它们能被电子猫钱包或者别的什么东西接受，但它跟绝大多数比特币用户无关。</p><h3 id="它会给比特币带来-MEV-问题吗？"><a href="#它会给比特币带来-MEV-问题吗？" class="headerlink" title="它会给比特币带来 MEV 问题吗？"></a>它会给比特币带来 MEV 问题吗？</h3><p>比特币与以太坊的一个关键区别在于交易的可见性。不像以太坊，比特币中的合约并非所有方面都必然是透明的，因此比特币矿工并不具有跟以太坊矿工相同的看到合约内部状态并抢先执行某些操作的能力。</p><p>对 OP_CAT 的主要顾虑是在它可能影响经济激励，造成 “矿工可抽取价值（MEV）”。我的上一篇<a href="https://blog.blockstream.com/miner-extractable-value-mev-and-programmable-money-the-good-the-bad-and-the-ugly/">文章</a>详尽地讨论了这个主题。许多用户担心的是，如果我们让 2 层合约在技术上变得可能，MEV 就不可避免会到来。但真是这样的吗？具体来说，如果你可以在比特币上发行 2 层币，是否就意味着它们一定会被采用？</p><p>你可以想象能开发出简单的互换合约，或者相对低效的 NFT，但开发带有自动化做市商的去中心化交易所这么复杂的东西就几乎不可能做到；而且，尽管 “技术上可行”，我们在 Liquid 上从未看到这样的东西被开发出来。</p><h2 id="OP-CAT-真是完美的吗？"><a href="#OP-CAT-真是完美的吗？" class="headerlink" title="OP_CAT 真是完美的吗？"></a>OP_CAT 真是完美的吗？</h2><p>当然不是。一些人希望看到递归型限制条款，而另一些人则完全不希望看到比特币会改变。</p><p>一部分比特币人，可以叫做 “固化主义者”，支持让比特币保持当前的状态，对任何协议升级都抱有怀疑态度。他们尤为担心重大的变更，比如限制条款的引入，可能会降低网络的去中心化。他们的主张基于一种信念：最好还是坚持比特币最初的愿景。讽刺的地方是，OP_CAT 就是最初的比特币的一部分，这就导向了完全相反的意见。一些人认为，让 OP_CAT 回归，更契合中本聪最初的愿景。</p><p>如果你希望得到一些由递归型限制条款带来的安全保管特性，那么 OP_CAT 就是好东西，但绝对不如成熟的 Lisp 式脚本语言那么好。问题在于，引入这样的东西将是巨大的变更，而且不太可能很快获得欢迎。</p><p>又或者，也许你站在另一边，你更喜欢非递归型限制条款（比如 OP_CTV 和 OP_VAULT）的简洁性。非递归型限制条款更简单，也更容易分析，没有创造不受控制的限制链条的风险。</p><p>但如果某种形式的递归型限制条款一定会出现呢？</p><p>过去几年中，开发者们已经注意到，几乎任何对交易验证逻辑的拓展都可以用来模拟 OP_CAT 的功能。</p><p>在 Script 的宇宙中，基于堆栈元素的体积，可以划分出两个世界。对于大于 4 字节的元素，你可以检查相等、将它们解读成公钥或签名，还可以哈希它们。而对于小于等于 4 字节的元素，你可以在上面作运算。使用一个运行在一个 BitVM 上的 <a href="https://glossary.blockstream.com/risc-v/?ref=blog.blockstream.com">RISC-V</a>处理器，你可以作任何事情。任何允许你模拟 OP_CAT 功能（分拆堆栈元素或将它们拼接）的东西，都可以将这两个世界融合，从而允许你在脚本中 “做任何事情”。</p><p>一些研究员，比如 Andrew Poelstra ，预期我们可以用非常少量的新操作码来制作递归型限制条款。如果这是真的，那就有理由找出一种尽可能好的办法。</p><h2 id="OP-CAT-是最有可能通过的限制条款提议吗？"><a href="#OP-CAT-是最有可能通过的限制条款提议吗？" class="headerlink" title="OP_CAT 是最有可能通过的限制条款提议吗？"></a>OP_CAT 是最有可能通过的限制条款提议吗？</h2><p>如果限制条款不仅是一个玩具，而是众望所归，我们如何保证它的实现方式会让更多比特币用户能够免信任地发送价值，就像中本聪最初期待的那样？虽然固化主义者还有分歧，OP_CAT 在限制条款辩论中依然是一个强有力的竞争者。</p><p>OP_CAT 不是最优雅的工具，但它的 功能&#x2F;复杂性 之比是最高的，这将允许开发者创造一些惊人的新特性。</p><p><em>注：本文的一个旧版本曾在 Bitcoin Magazine 出版，可以在此处<a href="https://bitcoinmagazine.com/technical/op-cat-the-purr-fect-solution-for-covenants-?ref=blog.blockstream.com">阅读</a>。</em></p><p>（完）</p>]]></content>
    
    
    <summary type="html">有点意思</summary>
    
    
    
    
    <category term="covenant" scheme="https://www.btcstudy.org/tags/covenant/"/>
    
  </entry>
  
  <entry>
    <title>从 Lamport 签名中获得脚本状态</title>
    <link href="https://www.btcstudy.org/2024/07/15/script-state-from-lamport-signatures/"/>
    <id>https://www.btcstudy.org/2024/07/15/script-state-from-lamport-signatures/</id>
    <published>2024-07-15T10:06:19.000Z</published>
    <updated>2024-09-02T04:30:25.045Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Andrew Poelstra</em></p><p><em>来源：<a href="https://blog.blockstream.com/script-state-from-lamport-signatures/">https://blog.blockstream.com/script-state-from-lamport-signatures/</a></em></p></blockquote><p>过去的半年时间里，我们看到了多项旨在提升比特币脚本（Bitcoin Script）的提议：<a href="https://blog.blockstream.com/op_cat-the-purr-fect-solution-for-covenants/">CAT</a>、64 位运算，以及其它更古老的想法（例如 CTV）、更面向未来的想法（如 Chialisp 和 <a href="https://blog.blockstream.com/simplicity-language/">Simplicity</a>）。这些活动在很大程度上掩盖了一些近期发生的、我们对现有比特币脚本的理解的革命性的变化；这些变化构成了 <a href="https://glossary.blockstream.com/bitvm/">BitVM</a> 的基础，但也可能会变成其它同样让人兴奋的升级的基础。</p><p>本文尝试总结和分类其他人对比特币脚本的研究。我无意声称对这里所描述的东西有原创性的发现。</p><h2 id="比特币脚本"><a href="#比特币脚本" class="headerlink" title="比特币脚本"></a>比特币脚本</h2><p>如许多研究者注意到的，Bitcoin Script 是嵌在比特币区块链系统中的一种简单的编程语言，我们用它来编程移动一笔资金所需满足的条件。迄今为止，Script 最常见的用法是使用一个公钥来检查一个签名。虽然比特币的地址格式在过去几年中经历了许多变化，但每一种地址都将脚本的这种用法当成首要用法并予以支持：公钥可以直接编码到比特币地址中，然后钱包软件会知道如何将这个公钥展开成完整的、用来检查该公钥的签名的程序。</p><p>但 Script 可以做到更多事情：它可以检查哈希值的原像、可以检查相对的和绝对的时间锁，还可以作一些简单的推理、从而以多种方式组合这些检查。这就是 <a href="https://glossary.blockstream.com/miniscript/">Miniscript</a> 编程语言背后的假设：我们可以将 “把公钥展开成一个脚本” 的想法普遍化，从而 “将任意大的签名条件组合展开成一个脚本”。</p><p>从技术上来说，Script 可以做的甚至比这还要多：它可以加减 32 比特长的数字，它可以求数据的哈希值并检查哈希值相等，它还可以重新安排和操作一个 “堆栈” 的数值，方式灵活多样。但是，Script 有许多局限性：它没有<a href="https://glossary.blockstream.com/opcode/">操作码</a>来运行简单的算术（比如乘法），它（几乎）不能分析超过 32 比特的对象并且（几乎）不能内省交易本身的数据。后者就是支持 “限制条款（covenant）” 可能需要软分叉的原因，而前者就是直到今天 Script 都没有被用来计算任何 “有趣” 函数的原因。</p><p>举个例子，在 Script 中，要将两个 16 比特的数字相乘，即只使用 Script 提供的加法和减法操作码，你需要将它们先打散成比特（通过要求在见证数据中提供比特，然后复制、相加，以重建原本的数字），然后以加法的形式来实现乘法。最终，你的代码将需要数十行操作码来实现一次乘法。</p><p>在 Taproot 升级以前，Script 还有一个人为的限制，每个程序最多只能使用 201 个操作码，而一次乘法会占用这个额度超过 1&#x2F;4，所以你根本做不了什么事情。在 Taproot 升级之后，这个 201 个操作码的限制已经移除了，但每一个操作码都依然会占用一个见证字节，这意味着，对于普通的钱包来说，要想在区块链上放置几千字节的程序，代价会高不可攀。</p><p>而且，没有交易内省的话，我们也不清楚要用这样大体积的计算来做什么。</p><p>毕竟，即使你能对任意数值作任意计算，但这些数值跟区块链上的交易数据没有关系，那这些计算如何能为比特币带来有用的语法？</p><h2 id="Lamport-签名"><a href="#Lamport-签名" class="headerlink" title="Lamport 签名"></a>Lamport 签名</h2><p>“Lamport 签名” 是 Leslie Lamport 在 1979 年发明的 —— 虽然如果没有现代的密码学哈希函数，它是不安全的，而现代密码学哈希函数到 1990 年代才出现 —— 也是少数几种从那个时代存留到今天的密码学物件。它的经久不衰的热度来自它的简洁性，而它对抗量子计算机的能力仅仅基于充分随机的哈希函数（不像更晚出也更高效的抗量子签名方案提议）。</p><p>但是，Lamport 签名有两个重大缺点：（1）它是极为低效的，公钥和签名都需要几 kB 的数据；（2）它是一次性的。用户只要使用同一个公钥签名多于一条消息，第三方就可以伪造更多消息，从而让所有签名都变得毫无价值。这是可以优化的，比如说，让你的 “公钥” 变成一棵由几百万个一次性公钥组成的 “<a href="https://glossary.blockstream.com/merkle-tree/">默克尔树</a>” ，但已经越过了实用性的边界。</p><p>这些局限性，让 Lamport 签名在量子计算突破的时候，可以作为比特币的一种 “备用签名方案”。但也使它无法在任何广泛部署的系统中作为主要的签名方案。</p><p>它的工作方式也非常简单：假设被签名的消息是 256 比特长的（可通过先运行 SHA256 哈希函数来保证任意长度的待签名消息都会被 “转化” 为 256 比特长）。用户的公钥就由 256 对哈希值组成（总共是 512 个哈希值）。要签名一条消息的时候，用户就揭开每一对哈希值中的其中一个哈希值的原像，至于要揭晓哪一个，就看消息的对应比特位的数值。</p><p>签名的验证者需要重新哈希消息和原像来检查签名与比特位相对应。</p><p>在 2021 年，Jeremy Rubin <a href="https://rubin.io/blog/2021/07/02/signing-5-bytes/">发布</a>了一篇文章，声称 Bitcoin Script 可以直接验证对 33 位数值的 Lamport 签名。他的机制是非常清晰的。Bitcoin Script 没有操作码可以直接读取一个数字的每一个比特，也没有能够从比特中构造数字的比特位（bitwise）操作。但 Script 有一个操作码可以将两个数字相加，而通过让只有一个比特集（bit set）的不同数字相加，我们就可以按位构造（bitwise-construct）以及按位解构（bitwise-deconstruct）一个数字。</p><p>凭借这一洞见，Rubin 以如下方法检查了一个编码成一系列哈希原像的 Lamport 签名：</p><ol><li>对每一个原像，计算其哈希值，并将其哈希值与一对嵌入 Script 的目标数值相比较（这些目标值就构成了公钥）。</li><li>如果哈希值与成对目标值的第一个数值相等，那就返回比特 0；这时候脚本不会做任何事。</li><li>如果哈希值与成对目标值的第二个数值相等，那就返回比特 1；这时候，在累加器上加 2 的特定次幂。</li><li>（要是对不上任何一个数值，那么这个签名就是无效的，脚本会终止。）</li></ol><p>累加器最终的数值将等于被签名的数字，后者是通过通过累加相应于其比特展开形式的每一个比特的 2 的幂数来获得的。</p><p>这已经足够有趣了：它意味着，对于特定类型的 “断言机签名” 应用来说，你可以直接在 Bitcoin Script 中检查签名，假定你的断言机愿意对特定事件制作一次性的 Lamport 签名，而且人们可以提前知道你的断言机对每一个事件的 Lamport 公钥的话。举个例子，一场球赛的结果，可以编码成 1 个比特。而比分则可以用几个比特来编码。一个具体的时间戳可能需要编码成 33 比特，等等。当然，只需检查多个 Lamport 签名，你就可以签名任意数量的比特。</p><p>但如果不能签名大体积的消息，你就不能获得对交易数据的签名，因此无法制作限制条款。（<a href="https://groups.google.com/g/bitcoindev/c/mR53go5gHIk">真的吗？</a>）</p><h2 id="BitVM-与模棱两可"><a href="#BitVM-与模棱两可" class="headerlink" title="BitVM 与模棱两可"></a>BitVM 与模棱两可</h2><p>Jeremy Rubin 的<a href="https://rubin.io/blog/2021/07/02/signing-5-bytes/?ref=blog.blockstream.com">文章</a>在当时被很多人认为是稀奇的东西，然后就被淹没在围绕他所提出的 OP_CTV 提议和限制条款的更大范围的讨论中。在 2023 年 12 月，该文在 Ethan Heilman 和 Armin Sabouri 所撰写的 OP_CAT <a href="https://github.com/bitcoin/bips/pull/1525">BIP</a> 中被间接引用，让它在对 Bitcoin Script 有不同看法的人群中获得了新的受众。</p><p>人们之所以会产生不一样的看法，是因为在 2023 年 10 月，也就是两个月以前，Robin Linux 在邮件组里<a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-October/021984.html">宣布</a>了他的项目 “BitVM” —— 这是一个通过将程序分切成多笔交易、从而在 Bitcoin Script 中实现任意计算的大胆项目。单笔交易只作一个简单的操作，而一个操作的输出会通过 哈希值-原像-揭晓 的构造挂钩到另一个操作的输入中，这看起来跟 Lamport 签名极为相似。</p><p>这里的技巧是，如果一个用户使用同一个公钥签出了对多条消息的 Lamport 签名，结果将是同一对哈希值的两个原像都暴露。这在 Script 中是很容易检查出来的，这就可以用来构造一种 “罚没交易”，将资金从这样做的用户手中拿走。只要一个用户使用相同的 Lamport 公钥公开签名了两条消息，这样的罚没交易将是完全有效的。罚没交易可以用在多交易的协议内部，以惩罚行为不轨的用户，一般是没收他们必须提前缴纳的保证金。</p><p>所以，这些 Lamport 签名，不是在被复用时单纯地失去安全性，而是可以被配置成主动惩罚多次签名的用户。这对于断言机签名场景有明显的用途：签名者被假设会见证真实世界中的事件的一个结果；我们希望遏制这样的签名者声称（比如说）两个队都赢了比赛。但还不止于此。</p><p>在密码学文献中，我们管一个参与者为一个理应独一无二的数揭晓两个数值的情形叫 “模棱两可（equivocation）”。我们可以<a href="https://dl.acm.org/doi/10.1145/2810103.2813686?ref=blog.blockstream.com">认为</a>，罚没交易是一种对抗模棱两可的措施，因为它惩罚任何使用同一个公钥对同一条消息签出多个签名的签名人。</p><p>那么，有了抗模棱两可构造的 Lamport 签名，就有了将公钥映射成具体的、不可篡改的数值的效果。换句话来说，我们有了一个全局的 <a href="https://glossary.blockstream.com/key-value-store/?ref=blog.blockstream.com">“键-值”对存储</a>，是可以通过 Script 来访问的，而且它还有一个神奇的特性，这个全局表中的每一个条目都可以由一个具体的人（知道该公钥的原像的人）来设定，但永远只能设定一次。这个键值对存储对任何比特币交易（实际上，是对任何区块链上的交易）来说都是可以访问的，无论它是否连接到另一笔交易。</p><p>这个键值对存储有 2^256 个条目，其中的大部分都是不能访问的，因为没人知道这些键背后的原像，所以，虽然它是一个由每一种使用这种 Lamport 签名构造的程序共享的 “全局键值对存储”，但它不会被填满，也没有来自一个程序的数据意外破坏来自另一个程序的数据的风险，也没有理应由某一个用户设置的数值被另一个用户设定的风险。这个键值对存储也并不完整地存储在任何地方。</p><p>BitVM 及其变种利用这个事实，将一个操作的输出跟下一个操作的输入捆绑起来：给定的一个程序可以分割成一长串的基本操作，比如 <a href="https://glossary.blockstream.com/risc-v/?ref=blog.blockstream.com">RISC-V</a> 指令集中的操作码，而每一个这样的基本操作都可以用一个自包含（self-contained）的 Script 程序实现出来，它会在键值对存储中搜索操作的输入和输出，检查它们是否已被正确联系起来，如果没有，就以某种方法惩罚用户。</p><p>完整的 BitVM 要比我们这里说的复杂得多：对每一个程序，它要从键值对存储中划出一个可寻址的内存空间；每一个操作都需要从内存空间中搜索其输入和输出；每一个操作都需要跟踪一个程序计数器，以及输入和输出以外的状态；而且整个系统要使用交互式的协议以及待确认交易的树捆绑在一起，以保证罚没交易可以正确地强制执行；而且，在一个步数高达数十亿的程序中，只需一步走错，就可被瞄准并遭到惩罚。但这篇文章并不是关于 BitVM 的，我们不会再展开。</p><h2 id="插句话：小脚本和大脚本"><a href="#插句话：小脚本和大脚本" class="headerlink" title="插句话：小脚本和大脚本"></a>插句话：小脚本和大脚本</h2><p>我们要花一分钟来帮读者回顾：Script 只能对 32 位长（以及更小）的数值作不简单的计算。这样的数值是 “scriptnums”，而 Script 由多个操作码可以操作它们，可以将它们解释成有符号的整数，或是布尔值，有时候两者皆可。</p><p>使用 BitVM 或一种类型的机制，将 Script 程序分割在多笔交易中，你可以在小体积的脚本中做任意计算，从 “<a href="https://glossary.blockstream.com/zero-knowledge-proofs-zkps/?ref=blog.blockstream.com">零知识证据</a>” 的验证，到 PoW 检查，再到数分解，都可以。</p><p>而大于 32 比特的数值，则只能被少数用途狭窄的操作码操作：可以哈希它们；可以将它们解释成公钥或签名，以检查一个交易签名；可以计算它们的字节长度；也可以作为不透明的数据在堆栈中移动。对它们来说，可以做到的唯一 “真正” 通用的计算是检查相等，它本身的价值微不足道。</p><p>我们将 32 比特数值的世界称作 “小脚本”，它富有表达计算的能力，只是不能以任何方式访问交易数据。而更大的数值的世界可以称作 “大脚本”，可以通过 CHECKSIG（检查签名）操作码来访问交易数据。也可以在大脚本世界中检查哈希原像，这正是实现 Lamport 签名的关键，但这几乎就是你能在大脚本中做的全部了。</p><p>没有办法有效地沟通这两个世界：你可以哈希一个小数值来获得一个大数值，但你无法从这个大数值中知道你原来不知道的任何东西。没错，你可以用 SIZE 操作来知晓一个大数值的长度，但如果这个数值代表着一个哈希值、公钥或签名，那它的长度是固定的，所以你无法知晓任何新东西。（虽然在 Taproot 之前，签名的长度是可变的，所以你<a href="https://groups.google.com/g/bitcoindev/c/mR53go5gHIk?ref=blog.blockstream.com">有可能</a>从一个恰当约束的、传入 CHECKSIG 的交易中抽取中交易信息。）</p><p>所有这些都是为了提醒读者，虽然这个新的 Script 功能令人兴奋，它提供了大量计算表达能力，但它没有内省交易数据的能力，因此无法用在 “保险柜（<a href="https://glossary.blockstream.com/vaults/?ref=blog.blockstream.com">vaults</a>）” 或其他限制条款应用中。</p><p><a href="https://github.com/bitcoin/bips/blob/master/bip-0347.mediawiki?ref=blog.blockstream.com">CAT</a> 操作码提供了一种沟通两种脚本的机制，这就是为什么 CAT 自身就足以提供限制条款功能。这也是为什么 Script 在许多方面 “只差一步” 就支持限制条款，以及为什么像 CAT 这样看起来不相关的提议能够启用限制条款：非常多的操作码可以取小数值为输入、输出大输出，或者反过来；它们可以将从大脚本世界中获得的交易数据输送到小脚本世界的通用程序中。甚至 SHA1 操作码的一个非常糟糕的中断，也可能被用作这样的桥梁，因为这样你就可以通过将大数值解释成 SHA1 哈希值、寻找它的小数值原像，在大数值上作 “计算”。</p><h2 id="插句话：虫洞"><a href="#插句话：虫洞" class="headerlink" title="插句话：虫洞"></a>插句话：虫洞</h2><p>实际上，假设你有足够多的运算力，你可以在小脚本中获得限制条款。通过跳出 Script “之外”，用户可以（在脚本中）验证比特币区块链，以及包含这段脚本的交易（需要避免直接编码其自身的数据，以避免体积无限膨胀，但这可以通过间接的方式来做到来；下一节会提供更多的细节），然后，就可以将限制施加在这一内部验证自身的 “视角” 上，从而对这样的交易施加额外的约束。</p><p>这个想法可以创建出一些有限的限制条款功能，但要记住，对键值对存储的正确访问是分割大型计算的前提，但它并不是直接执行的。相反，需要一些额外的机制来保证对不正确访问的惩罚。这会让保险柜这类限制条款的实现变得复杂很多，因为其功能依赖于特定的花费模式变得不可行（而不是仅仅受到抑制）。</p><h2 id="三子棋"><a href="#三子棋" class="headerlink" title="三子棋"></a>三子棋</h2><p>到目前为止，我们已经谈到了 Lamport 签名的反模棱两可特性，以及这种特性如何在 Bitcoin Script 中实现一种 “全局的键值对存储”，这种键值对存储又如何在脚本程序间传递数据、从而将大型计算分割成许多独立的部分。但 Lamport 签名还有另一个有趣、可能是优越的方面：它们可以在脚本中承诺一个唯一的数值，而不让这个数值影响它所在的交易的 TXID。</p><p>这有两个后果：一，我们可以在交易中承诺数据，而不影响 TXID；意味着，我们可以改变一个 Script 程序内部的参数而不会让待确认交易的链条失效；二，我们可以承诺数据，而不影响签名哈希；意味着，用户可以在不知道全部交易数据的时候 “预签名” 一笔交易。</p><p>（顺带说一句，只要有一种检查可以惩罚签名多个数值的行为，那么任何签名方案都具备这种属性。Lamport 签名有趣的地方在于我们在今天的比特币上就能使用它。）</p><p>这种在一个 Script 程序中放置数据，而不影响包含该程序的交易的 TXID 的能力，为一个能够引用自身代码的程序的构造打开了大门（举个例子，通过在程序中注入其自身的 TXID，而 TXID 是所有交易数据 —— 包括该程序 —— 的哈希值）。这个叫作 “自复制程序（<a href="https://en.wikipedia.org/wiki/Quine_(computing)?ref=blog.blockstream.com">Quine</a>）”，可以用来启用委托（delegation）以及创建递归型限制条款。这种能力正是 Simplicity 语言的 “<a href="https://blog.blockstream.com/simplicity-sharing-of-witness-and-disconnect/">disconnect 组合器</a>” 背后的动机。不过，因为我们只能在小脚本中验证 Lamport 签名，这就排除了 TXID 这么大的对象，似乎在这个方向上目前我们还没什么可以做。不过，没有什么能阻止我们用相似的技巧来模仿非递归的限制条款。</p><p>我们来介绍一个由 supertestnet 在 Github 上发表的<a href="https://github.com/supertestnet/bitvm-workshop?ref=blog.blockstream.com">案例</a>。</p><p>三子棋游戏是一种两个人在一个井字格上玩的回合制游戏。规则很简单：玩家不能在已经落子的方格上落子；只要能让自己的子连成一条直线（不论是直线还是斜线），就赢。假设一些玩家想在链上玩这个游戏，一笔交易就代表一个回合。</p><p>当然，与这些交易并行的，是他们会签名一笔 “握手言欢” 交易：双方都签名，把资金直接交给胜出的一方；所以，如果双方都同意游戏的结果，他们就不需要发布表示每一回合的交易！但构造完整游戏的副本依然重要，因为这样一来，在发生争议的时候，区块链才能居中调解。</p><p>要模拟这个游戏，他们可以采取的一种办法是一连串的预签名交易，每一笔交易都要求来自双方的签名。先手玩家的第一步有 9 种可能；那么后手玩家需要签名全部 9 笔交易，然后先手玩家选择代表自己要走的那一步的交易来签名。然后，在后手玩家的第一步，有 8 种可能的落子位置；所以先手玩家也要签名所有 8 笔交易，让后手玩家来选择自己想要的。以此类推。</p><p>可以证明，这种办法不太能行 —— 因为任何一个玩家都有可能拒绝签名某一步棋，在游戏卡住的情况下，没有办法归责，因此落败的玩家也就没有激励完成游戏。为了防止这种情形，每一个玩家都必须在游戏开始之前签名对手可能的所有走棋。这样一来，一个玩家就只能拒绝签名他自己的走棋，而这可以容易用带有时间锁的没收条件，来迫使他们行动。</p><p>另一种方法是让每一个玩家都签名对手的走棋，而他们可以招募一个受信任的第三方来预先签名每一步棋。但结果是完全一样的：每一种可能的交易链条都必须得到签名。对三子棋游戏来说，总共有 255168 种对局可能，需要总计 549946 笔预先签名的交易。这就突破了实用性的边界，而且显然，这样的策略无法推广到更复杂的游戏上。举个例子，对国际象棋来说，这样的可能性以 “<a href="https://en.wikipedia.org/wiki/Shannon_number?ref=blog.blockstream.com">香农数</a>” 为界，这可是 10^120 。</p><p>我们面临这么大的膨胀，是因为我们要通过不同的交易来区分每一步棋，而每一笔交易都必须在游戏开始之前设置好。</p><p>不过，使用 Lamport 签名，我们就可以做得更好：</p><ul><li>每一局三子棋都（最多只）有 9 步；</li><li>每一步都让棋局从一个状态转变为另一个状态；而棋局的状态小到可以用 Lamport 签名；</li><li>每一次状态转换所要遵守的规则，都足够简单，可以用 Script 来编码。</li></ul><p>因此，我们可以用另一种方法来实现这种游戏：每一个玩家，都生成一个 Lamport 公钥，用来签名自己的每一步之后的棋局状态（所以先手玩家需要 5 个 Lamport 公钥；后手玩家需要 4 个）。然后，他们生成一连串的 9 笔交易，交易输出的 taptree 有三个分支：</p><ol><li><p>一个 “常规走棋” 分支，由以下条件满足：</p><ul><li>来自双方的常规签名</li><li>来自相应玩家对上一个棋局状态的 Lamport 签名</li><li>来自另一个玩家，对下一个状态的 Lamport 签名</li><li>一个用 Script 实现的检查：两个状态是正确关联的（两个状态的区别在于，理当行动的玩家只走了一步合法的棋）。</li></ul></li><li><p>一个 “赢棋” 分支，由以下条件满足：</p><ul><li>来自双方的常规签名</li><li>来自相应玩家对上一个棋局状态的 Lamport 签名</li><li>一个用 Script 实现的检查：本玩家已经赢得比赛。</li></ul></li><li><p>一个 “超时” 分支，由以下条件满足：</p><ul><li>来自双方的常规签名</li><li>一个相对时间锁已经过期。</li></ul></li></ol><p>最后一笔交易的 “常规走棋” 分支要换成一个 “平局” 分支，因为如果格子都已被填满但还没有胜者，就说明打平了，锁定的资金要原路返回。</p><p>和面前一样，每一个玩家都要预先签名所有的交易，在这里是 27 笔，包括 “胜出条件” 交易（将所有的资金发给胜出的玩家）、“超时条件” 交易（将所有的资金发给没有超时的玩家），以及 “平局条件”。</p><p>这样一来，即使国际象棋的规则会复杂很多，棋盘状态可能需要多个 32 比特的数值来表示，而且步数显然多于 9 步，采用相同的构造也是完全有可能的。</p><h2 id="交易树"><a href="#交易树" class="headerlink" title="交易树"></a>交易树</h2><p>在上一个例子中，我们充分利用了一个事实：三子棋的规则可以嵌入 Script，意味着玩家签名一个无效的棋局状态是没有用的。（即使他们签名了无效的走棋，表示这一步棋的交易也将是无效的，而且表示所有未来走棋的交易可能会作废，因为它们都依赖于它。）所以，所有的攻击者能够做到的仅仅是泄露被攻击者的一部分 Lamport 签名密钥，从而让其他玩家可以伪造被攻击者的走棋。</p><p>我们也利用了一个事实：我们的整个协议并不长，最多只有 9 步。这意味着，如果一个玩家拒绝完成游戏，或者完成游戏但不承认结果，那么将完整的游戏副本发送到链上（以追索资金），是合理的。对许多游戏来说，这已经足够了。</p><p>这个模型还有许多技巧，但已经超出了本文的范围：作为证明者和验证者之间的 “游戏”、检查单方的计算；外包一个甚至两个角色；使用较大的 taptree 将多个步骤合并到一笔交易中；将线性的副本换成对无效步骤的二进制搜索，等等。这些技巧构成了 BitVM、BitVM 2、BitVMX 等等的基础。</p><p>使用这样的技巧，我们可以减少现有的依赖于未签名交易树的协议的开销。Bentov 和 Miller 在 2017 年出版的一篇古老<a href="https://arxiv.org/abs/1612.05390v1?ref=blog.blockstream.com">论文</a>声称在 UTXO 模型上实现富状态协议将总是面临指数级的膨胀（相对于在账户模型（例如以太坊）上实现类似协议）。使用 Lamport 签名作为一个全局的键值对存储，我们可以部分反驳这篇论文。但这又超出了本文的范围，需要在我们的下一篇文章中展开！</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢 Robin Linux 和 Ethan Hilman 审核本文的草稿。</p><p><em>注：本文的一个较早的版本首次发表在 <a href="https://bitcoinmagazine.com/technical/script-state-from-lamport-signatures-?ref=blog.blockstream.com">Bitcoin Magazine</a> 上。</em></p>]]></content>
    
    
    <summary type="html">对现有比特币脚本的理解的革命性的变化</summary>
    
    
    
    <category term="比特币主网" scheme="https://www.btcstudy.org/categories/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%BB%E7%BD%91/"/>
    
    
    <category term="开发" scheme="https://www.btcstudy.org/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="比特币脚本" scheme="https://www.btcstudy.org/tags/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>并行签名中的适配器签名的安全性</title>
    <link href="https://www.btcstudy.org/2024/07/12/security-of-signature-adaptors-in-parallel-draft/"/>
    <id>https://www.btcstudy.org/2024/07/12/security-of-signature-adaptors-in-parallel-draft/</id>
    <published>2024-07-12T05:50:28.000Z</published>
    <updated>2024-09-02T04:30:25.045Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：AdamISZ</em></p><p><em>来源：<a href="https://github.com/AdamISZ/AdaptorSecurityDoc/tree/main">https://github.com/AdamISZ/AdaptorSecurityDoc/tree/main</a></em></p></blockquote><blockquote><p>作者注：本文为关于适配器签名安全性的一个简短笔记。当前处于 “草稿” 及 “未审核” 状态。</p><p>草稿意味着它还不是最终版本，可能发生变更。</p><p>未审核意味着还没有谁认定本文中的任何描述是正确的。</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在本文中，我们给出了 Schnorr 签名语境下的 “签名适配器（signature adaptor）” 的定义（该术语最早由 Poelstra 提出 [1] ），（具体来说，是公钥前缀版本由 BIP340 [4] 标准化的 Schnorr 签名）。我们会从一个 “玩具” 定义开始，为单一公钥 $P$ 指定。</p><p>（回顾关于这个问题的更早的工作）之后，我们会正式声明这种构造的安全性特性。</p><p>然后，我们会解释，为什么这样一种 “签名适配器” 可能合并到一种 3 轮次的 MuSig [2] 协议中（<strong>注</strong>：下文使用的 “MuSig” 全部都指的是 <em>这篇</em> 论文中的构造；再说清楚一点，<em>不是</em> MuSig2 [3] ），从而可以用一个聚合公钥（$P _ {agg}$）签名。我们还会解释，它的安全性属性跟前面的案例有什么关系。</p><p>然后，我们会处理在一个 MuSig 签名会话中 <em>并行地</em> 使用多个签名适配器的情形。具体来说，我们处理的可能是最重要的情形：<em>同一个</em> （因此是私密的）适配器点并行地用在多个不同的签名会话中。我们发现，这种构造的安全性可以通过一种化约法（reduction argument）来证明，但也要加上一些重要的说明。在未来，这个领域可能需要进一步的工作。</p><p>最后一部分分析比较实用，因为它适用于需要签名适配器的最为著名的构造，即 “基于适配器签名的 CoinSwap” [14] [15] 、匿名的多跳锁定 [16] ，以及更奇异的版本，比如 “多方 S6”[6] 。</p><h2 id="记号"><a href="#记号" class="headerlink" title="记号"></a>记号</h2><p>虽然我们默认使用椭圆曲线 secp256k1（见下一段），下文的论述对任何其它能使离散对数问题难解的素数阶循环群（group of prime order）应该也成立。</p><p>我们使用 $\mathbb{H}$ 来表示由 BIP340 [4] 指定的哈希函数，用于哈希消息（当然，用来做其他事也是可以的）。我们使用 $\mathbb{H} _ c$ 来表示用于承诺到曲线点的哈希函数，用在这里讨论的未修正和修正过的 MuSig 版本中。</p><p>在我们提到要创建 nonce 值的时候，一定说的是 “随机选出”，也即，没有用于表示 “确定性随机” 的记号。其安全性和不安全性已经在 BIP340 和 MuSig2 BIP [5] （以及其它地方）有详细讨论。</p><p>此外，我们总是使用 $R$ 来表示签名中的 nonce 点，而其对应的标量值会写成 <em>k</em> （还会加上适量的上下标）。</p><h2 id="关于签名适配器的早期工作"><a href="#关于签名适配器的早期工作" class="headerlink" title="关于签名适配器的早期工作"></a>关于签名适配器的早期工作</h2><p>在提出我们的基础定义（从而为安全性论证打下基础）之前，值得先看看其他人是怎么看待签名适配器的安全性的。</p><p>据我们所知，正式处理签名适配器的安全性的工作可追溯到 Fournier [13] 和  Aumayr 等人 [9] 。先看后者，在 “敌手可访问一种常规的签名断言机以及一个适配器签名断言机” 的假设下，可以定义出 “EUF-CMA 安全性”（译者注：“EUF-CMA” 意味着 “选择明文攻击下的实质不可伪造性”）。该论文的定义 1 声称，在这个敌手可以得到需要伪造的消息的一个签名适配器的时候，无法伪造完整签名。我们认为，这个定义有点太弱了，因为更有意义的是考虑这样一个场景：敌手可以获得对 <em>一条</em> 消息的 <em>多个</em> 签名适配器，以伪造完整的签名。作为对该模型的批评，这是否成立，是可以辩论的，但是，这一点却正是本文剩余部分讨论的核心。</p><p>待完成：包含对更新的 Wei Dai 论文的索引。</p><p>同样的安全模型也被用在关于 “支付通道” 的论文 [12] 中。许多这样的论文都需要一种通用的构造，而非专属于 Schnorr 签名的构造，尤其是因为他们考虑了使用 ECDSA 而非 Schnorr 作为例子展示签名适配器的可能性 —— 但 ECDSA 显然在密码学上更加复杂。</p><p>也与此相关的是，从 [9] 开始，有一种说法是签名适配器本身（被叫作 “预签名”）也是不可伪造的。但是，这种说法假设了一个细微的差别，在我们的附录 D 里面得到了正式的证明：敌手无法伪造 <em>给定</em> 的一个 “陈述” $T$（在我们这个案例中就是一个曲线点，或者一个公钥）的适配器签名。但这没有涉及敌手使用一个随机的、非预先选定的 $T$ 伪造适配器签名的能力；而且，实际上，这种能力是下面的论证的核心。（此外，也很难说这超越了实用性协议的范围，因为随机选出 $T$ 值的情况是很常见的）。</p><p>Fournier 在 [13] 提出了一个密切相关的论点，直接引用如下：<em>EUF-CMA [VES] 并不涉及签名加密手段的不可伪造性。实际上，即使敌手无需签名密钥就可以制作有效的 VES 密文，那也是完全具备这种特性的。当然，不能允许敌手有能力伪造某一个加密密钥的 VES 密文，否能，他们就可以伪造他们已经知道解密密钥的加密签名，然后解密它（从而打破安全性）…</em> 。实际上，该论文在其后续的第三章含蓄地指出，也许存在一些协议，签名适配器会由多方合作协议中的其他人来创建。在 Fournier 的模型中，他将签名适配器当作 “一次性的可验证加密签名（VES）”，而 “一次性” 当然指的是签名适配器的这种属性：一旦揭晓明文，加上早已知道的密文，就会揭晓（加密）私钥（在 Schnorr 签名的语境下，就是一个离散对数，也即对应于 $T$ 的 $t$）。虽然其模型与 [9] 不同，但大体上，其安全性论证是相似的。</p><p>在 Erwig 等人所作的《两方适配器签名》[10] 中，[9] 的模型得到了延伸，考虑了相同的模型如何应用到从一个 ID 协议中派生的任意签名方案中。因此，它作出了富有启发的注释：根据定义，这样的签名适配器在唯一签名方案（unique signature scheme）（比如 BLS [11] ）中是不可能实现的（Fournier 在其论文中也简要提到了这一点）。这篇论文也正式地将模型延伸到多方签名的语境，跟本文的关注点一样，但使用了一种 KOSK（“私钥知识”）模型，与前面提到的 MuSig 和 MuSig2 不同。</p><h2 id="BIP340-Schnorr-签名的单公钥签名适配器"><a href="#BIP340-Schnorr-签名的单公钥签名适配器" class="headerlink" title="BIP340 Schnorr 签名的单公钥签名适配器"></a>BIP340 Schnorr 签名的单公钥签名适配器</h2><p>给定 BIP340 对公钥 $P$、消息 $m$、私钥（在这里记作 $x$）和签名 $(R, σ)$ 的定义，我们定义一种 “签名适配器” 创建算法 <strong>AdaptorCreate</strong>，它取一个标量 $t ∈ Z _ N$ 以及前述定义的一个公钥 $P$、一条消息 $m$ 以及一个签名 $(R, σ)$ 作为输入，输出一个 “签名适配器”，它是一个数组 $ (R, σ’ , T)$ 。</p><p>$T$ 有时候会被称为 “适配器点”，对应的 $t$ 则是 “适配器秘密”。</p><p>创造签名适配器的算法是先计算：</p><p>$$T :&#x3D; tG$$</p><p>$$σ’ :&#x3D; σ - t$$</p><p>然后返回 $ (R, σ’ , T)$ 。在这个返回的数组中包含 $R$ 的尴尬之处直接关系到为什么这个过程是 “无用的”，我们后文会说明。</p><p>然后，我们定义一种算法 <strong>AdaptorVerify</strong> ，它取一个签名适配器 $ (R, σ’ , T)$ 为输入，然后计算：</p><p>$$σ’G ?&#x3D; R - T + \mathbb{H}(R||P||m)P$$</p><p>然后返回真或假。</p><p>如果上述定义看起来是错的，请注意：</p><p>读者可能更熟悉 “签名适配器” 的等式定义：$\sigma’ &#x3D; k + \mathbb{H}(R+T||P||m)x$ 为点 $T$ 的适配器。这里给出的减法版本是等价的，但稍为容易分析，因为由 $T$ 构成的 “调整因子” 现在仅仅出现在哈希函数 <em>之外</em>。再看一个等价的版本：重新定义 $R’ &#x3D; R + T$ ，因此 $R &#x3D; R’ - T$ ，因此 $\sigma’ &#x3D; R’ - T + \mathbb{H}(R||P||m)P$ 。</p><p>这个等式可以用下面这个任务来说明：假设你想要为你的私钥 $x$ 和消息 $m$ 创建一个适配器签名，适配器点为 $T$，且你不知道 $T$ 背后的离散对数。在 “另一种” 形式化版本 $\sigma’ &#x3D; k + \mathbb{H}(R+T||P||m)x$ 中，你可以直接做这样的计算，因为它只需要 $T$ ，并不需要 $t$ 。而在这种新的形式中，你必须先随机选出一个 $k _ 2$ 然后定义 $k _ 2 &#x3D; k - t$，从而让 $R &#x3D; R _ 2 + T$ ，然后才能计算 $\sigma’ &#x3D; k _ 2 + \mathbb{H}(R||P||m)x$ ，然后返回 $(R, \sigma’, t)$ 作为你的适配器。因此，当一个对手通过发布 $\sigma &#x3D; \sigma’ + t$ 揭晓一个签名时，你可以通过减法得出此前未知的 $t$。</p><h3 id="论点-1"><a href="#论点-1" class="headerlink" title="论点 1"></a>论点 1</h3><p><em>上面定义的单公钥签名适配器是诚实验证者零知识的。</em></p><p>首先，我们定义出创建签名适配器的另一种算法，我们称为 <strong>AdaptorForge</strong> ：</p><ol><li>选出随机数 $k \in Z _ N$</li><li>令 $R :&#x3D; kG$</li><li>随机选出 $\sigma’ \in Z _ N$</li><li>令 $T :&#x3D; R + \mathbb{H}(R||P||m)P - \sigma’G$</li></ol><p>因此，一个敌手可以制作出一个签名适配器 $(R, \sigma’, t)$ ，显然可以通过 <strong>AdaptorVerify</strong> ，无论你选出的 $R, \sigma’$ 是什么数值都可以（甚至无需一对真实的 $(R, \sigma’)$ 先存在，这当然意味着伪造更加容易）。不过，请注意，敌手无法为选定的签名适配器找出秘密 $t$ ，除非他能抽取椭圆曲线上的离散对数（证明：假设相反情形，敌手 <em>能够</em> 找出 $t$ ，那么这暗示着他能从公钥 $P$ 中抽取出私钥 $x$，又因为 $x &#x3D; \frac{t + \sigma’ -k}{\mathbb{H}(R||P||m)}$ ，而敌手拥有所有的 RHS。因此这个敌手在不需要跟断言机互动的情形下抽取了 $P$ 的离散对数）。</p><p>将 <strong>AdaptorCreate</strong> 的执行当成一种跟挑战者 $C$ 的互动，它会以随机数值回复对 $\mathbb{H}$ 的调用（正是合格的 “诚实验证者”，因为我们默认假设该挑战者所返回的数值是真正随机的）：</p><ul><li>发送 $R, P, m$ 给 $C$</li><li>从 $C$ 处获得 $\mathbb{H}(R||P||m)$</li><li>输出 $T, \sigma’, R$</li></ul><p>我们可以将相同的逻辑应用在 Schnorr 身份验证协议中，如 Boneh 和 Shoup [7] 中的定理 19.4 一样：如果敌手可以使用 <strong>AdaptorForge</strong> 伪造副本，且其统计分布跟我们从使用 <strong>AdaptorCreate</strong> 的诚实应用中看到的没有区别，那么我们就拥有 “诚实验证者零知识（HVZK）” 安全性。</p><p><strong>AdaptorForge</strong>  可以作为 HVZK 定义中的 “模拟器（$Sim$）”，只需传入公钥（不是私钥），它就可以随机选出 $\sigma’$，然后定义 $T$（也是完全随机的，假定有一种理想的哈希函数）。在使用 <strong>AdaptorCreate</strong> 的时候，$t$ 是由（知晓私钥的）创建者选出的，然后 $\sigma’$ 是使用 $\sigma - t$ 计算出来的，而 $\sigma$ 是常规的 Schnorr 签名，而且，我们同样假设有一种理想的哈希函数，其输出是均匀随机的。在两种情况下，因为挑战数值（建模为随机数断言机（RO）的输出）是随机的，而且独立于输入 $R, P, m$，所以输出值 $(T, \sigma’)$ 的分布也将是均匀随机的。</p><p>注意，<strong>AdaptorForge</strong> 不是什么 “新发现” 或者令人惊讶的结果，它是这样的 “签名适配器” 的众所周知的固有属性，只是它对这个概念的发展至关重要。而且，如前面所指出的，[9] 并没有提到这一点。</p><p>我们已经观察到两件事：签名适配器不会泄露关于私钥（在这里是 $x$）的信息，以及，签名适配器很容易伪造，即，它本身不是电子签名。（当然，请注意，前者并不 <em>意味着</em> 后者；真正的电子签名方案就是反例）。</p><p>因此，我们的论点是，在创建适配器的场景下，不需要对底层签名方案（在这里是 BIP340 Schnorr 签名）不为造型的更复杂的论证；根据零知识的定义，敌手没有从任何数量的适配器中得到任何额外的信息，所以没有改变（底层签名方案的特性）。</p><h3 id="为什么单公钥签名的适配器是无用的"><a href="#为什么单公钥签名的适配器是无用的" class="headerlink" title="为什么单公钥签名的适配器是无用的"></a>为什么单公钥签名的适配器是无用的</h3><p>我们说上述算法是 “无用的”，因为它没有提供以下任何一种特性：</p><ul><li>一种创建强制机制的办法，可以保证公布对一条预先定义的消息的签名将揭晓一个秘密值</li><li>一种若没有本算法就无法实现的嵌入秘密数据的新办法</li></ul><p>在第一点上，我们观察到，Schnorr 签名并非 <em>唯一的</em>；意思是，你只需使用另一个 nonce 值 $R$ ，就可以为相同的语境 $P, m$ 创建另一个签名。因此，<strong>AdaptorCreate</strong> 的输出 $(R, \sigma’, t)$ 将不允许强制揭晓 $t$ ，只要你还可以创建新的签名，例如，使用另一个 $R$ 来许可一笔比特币交易（也即 “预先定义的消息”）。这就是为什么本文剩余的部分都是关于 MuSig 场景的，其中，在签名以合作方式完成之前，$R$ 可以是固定的（以聚合的形式）。</p><p>（注意，Dryja 的 “谨慎日志合约”[8] 也应用了类似的推理，“固定了” $R$，只不过出于不同的目的：为了防止通过签名两条相互矛盾的消息来含糊其词。）</p><p>在第二点上，显然将秘密数据隐藏在公开数据中是容易的事，只要秘密的发送者和接受者可以提前分享一些私钥；例子如一次性密码本（one-time pad）。这不是要贬低公开的随机性对隐写术的有用性（而且，比如说，在比特币区块链上，占最大比例的数据就是以签名和公钥形式体现的公开随机性）；只是想说，适配器签名不是为此而生的算法；简单的减法或 XOR（异或运算）也有相同的效果。</p><h2 id="多方（MuSig）场景的定义"><a href="#多方（MuSig）场景的定义" class="headerlink" title="多方（MuSig）场景的定义"></a>多方（MuSig）场景的定义</h2><p>我们将从定义开始：</p><ul><li><strong>签名语境</strong> $c$ 将由一组由 $n$ 个参与者 $p$（记为一组有序列表 $p _ 1, …, p _ n$）构成的合作团体，以及一条待签名的消息 $m$ 组成。</li><li>算法 <strong>KeySetup</strong>，取一组来自参与者 $p$ 的公钥 $\prod _ i$ ，然后为每一个成员输出一个公钥 $P _ i$ 。这个算法是由 MuSig 论文定义的。注意，我们将使用记号 $x _ i$ 来表示 $P _ i$ 的私钥（因此，这是起始公钥 $\prod _ i$ 的私钥的非线性版本）。$P _ {agg}$ 定义为 $\sum _ iP _ i$ 。</li><li>算法 <strong>Sign1Check</strong>，由每个成员 $p _ i$ 各自运行，取来自其他每一个成员（即 $p _ j, j \not&#x3D; i$）的哈希值 $h _ j$ 为输入，然后在且仅在从其他成员处收到的数值是预先一致同意的哈希函数 $H _ c$ 的有效输出时返回 “真”。</li><li>算法 <strong>Sign2Check</strong>，由每个成员 $p _ i$ 各自运行，取来自其他每一个成员（即 $p _ j, j \not&#x3D; i$）的公钥 $R _ j$ 以及 $R _ i$ 为输入，然后，在 $\mathbb{H} _ c(R _ j) \not&#x3D; h _ j$ 时输出 “拒绝”；而在所有的哈希值都匹配的时候输出 $R _ {agg} &#x3D; \sum _ {k&#x3D;1}^{n} R _ k$ 。注意，每一个 $R _ k$ 背后都有一个对应的私钥 $k _ k$ 。</li><li>算法 <strong>AdaptorCreateM</strong>，可以由任何成员 $p _ i$ 运行，取 <strong>KeySetup</strong> 的输出 $P _ {agg}$、<strong>Sign2Check</strong> 的输出 $R _ {agg}$ 作为输入，然后输出一个适配器：$(T _ i, \sigma’ _ i)$ 。注意，这个元组不再包含 $R$（跟单公钥适配器不同）。</li></ul><p>请注意，<strong>Sign1Check</strong> 和 <strong>Sign2Check</strong> 是分别在 MuSig 算法（本身要求三轮交互）的第一轮和第二轮中运行的；MuSig 论文给出了完整的描述。</p><p>此外，根据定义，<strong>AdaptorCreateM</strong> 只能在成功完成前面三个算法后运行。</p><p>现在，我们定义三种独立的验证算法：</p><ul><li>$\mathbb{V} _ s$ 取一个元组 $(\sigma, R, P, m)$ 为输入，然后输出 “真” 或 “假”。这就是 Schnorr 签名验证算法（为求精确，我们可以指明是 BIP340 验证算法）。注意，在上文的 “签名语境” 中是没有定义这一部分的，因为签名语境不知道作为该算法输入的公钥 $P$ 的构成。仅供参考，这个算法是这样的：$\sigma G ?&#x3D; R + \mathbb{H}(R||P||m)P$ 。</li><li>$\mathbb{V} _ p$ 取 $(c, \sigma _ j, j, R _ j, R _ {agg}, P _ {agg})$ 为输入，其中 $P _ {agg}, R _ {agg}$ 分别是来自 <strong>KeySetup</strong> 和 <strong>Sign2Check</strong> 的输出。它在且仅在 $\sigma _ jG &#x3D; R _ j + \mathbb{H}(R _ {agg}||P _ {agg}||m)P _ j$ 时返回 “真”（注意，$m$ 是包含在 $c$ 中的），否则返回 “假”。</li><li>$\mathbb{V} _ a$ 取 $(c, j, (T _ j, \sigma’ _ j), R _ j, R _ {agg}, P _ j, P _ {agg})$ 为输入，其中$(P _ {agg}, P _ j), R _ {agg}$ 分别是来自 <strong>KeySetup</strong> 和 <strong>Sign2Check</strong> 的输出。它在且仅在 $\sigma’ _ jG &#x3D; R _ j - T _ j + \mathbb{H}(R _ {agg}||P _ {agg}||m)P _ j$ 时返回 “真”（注意，$m$ 是包含在 $c$ 中的），否则返回 “假”。</li></ul><p>这两种看起来复杂的 Schnorr 验证算法 $\mathbb{V} _ p, V _ a$ 具有很长的输入元组，但可以通过要求算法 <strong>KeySetup</strong> 、<strong>Sign1Check</strong> 和 <strong>Sign2Check</strong> 必须提前运行且成功完成来简化（因为，显然这是下面的安全性论点所需要的）。然后定义就会变成：</p><ul><li>$\mathbb{V} _ p$ 会取 $(\sigma _ j, j)$ 为输入，输出 接受&#x2F;拒绝。</li><li>$\mathbb{V} _ a$ 会取 $((T _ j, \sigma’ _ j), j)$ 为输入，输出 接受&#x2F;拒绝。</li></ul><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><h3 id="论点-2"><a href="#论点-2" class="headerlink" title="论点 2"></a>论点 2</h3><p>选择上述定义的必然结果是：</p><p>*假设第一类算法 (<strong>KeySetup</strong>, <strong>Sign1Check</strong> 以及 <strong>Sign2Check</strong>) 已经运行且成功完成。进一步假设一个参与者 $p _ j$ 已经运行了算法  <strong>AdaptorCreateM</strong>，创建了一个签名适配器 $(T _ j, \sigma’ _ j)$ 且该适配器能够通过 $\mathbb{V} _ a$ 。那么，$\sigma’ _ j \leftrightarrow T _ j$ 之间必然有准确的一对一映射，也就是说，没有另一个 $T^{\ast} $ 使得 $(T^{\ast}, \sigma’ _ j)$ 能够通过 $\mathbb{V} _ a$ 。因此，这种绑定是完美的，而不仅仅是计算上的。*</p><p>这可以从下列描述中看出来：$R _ {agg}, P _ {agg}, R _ j, m$ 和 $P _ j$ 都是在 <strong>Sign2Check</strong> 结束时定义好的。因此，在等式 $\sigma’ _ j &#x3D; k _ j - t _ j + \mathbb{H}(R _ {agg}||P _ {agg}||m)x _ j$ 中，除了 $\sigma’ _ j$ 和 $t _ j$ ，所有项都是固定的。（在域 $Z _ N$ 中）选了一个，就将决定另一个。</p><p>这个属性当然是极为关键的：如果我们的目标是创建一种能够强制揭晓一个秘密值的算法，我们就需要保证恶意的适配器创建者不能含糊其词、“揭晓” 另一个秘密值。</p><p>关于 “完美” 绑定，还有一个提醒：<em>在固定语境 $(c, R _ {agg}, P _ {agg}, m, \sigma’ _ j)$ 下无法伪造另一个适配器的意义上</em>，该论点为真。真正实用的安全性限制来自 MuSig 本身，也即，敌手在没有诚实参与者同意的情况下伪造多签名的能力（或无能为力）。</p><h3 id="论点-3"><a href="#论点-3" class="headerlink" title="论点 3"></a>论点 3</h3><p><em>就像 <strong>AdaptorCreate</strong> 一样，HVZK 属性在 <strong>AdaptorCreateM</strong> 上也成立。</em></p><p>这里我们定义了一种算法 <strong>AdaptorForgeM</strong>：</p><ul><li>假设敌手为 $c$ 中的 $j$，而且 <strong>KeySetup</strong>, <strong>Sign1Check</strong> 以及 <strong>Sign2Check</strong> 都已经运行且成功完成。</li><li>敌手随机选出 $\sigma’ _ j \in Z _ N$ 。</li><li>然后计算 $\mathbb{H}(R _ {agg}||P _ {agg}||m)P _ j - \sigma’ _ j &#x3D; Q$ </li><li>然后计算 $T _ j &#x3D; Q + R _ j$</li><li>返回 $(T _ j, \sigma’ _ j)$</li></ul><p>可以检查到，$(T _ j, \sigma’ _ j)$ 能够通过 $\mathbb{V} _ a$ ，虽然这个元组的创建者不知道 $T _ j$ 的离散对数，也不知道 $P _ j$ 的离散对数。</p><p>因此，签名适配器的 “可伪造性” 在多参与者聚合签名、聚合 nonce 的语境下与单公钥语境下是一样的，对其诚实验证者零知识的论证也是一样的。只需观察到 <strong>AdaptorForgeM</strong> 和 <strong>AdaptorCreateM</strong> 的统计分布是一样的。</p><h3 id="“伪造”-AdaptorForge-M-的源头"><a href="#“伪造”-AdaptorForge-M-的源头" class="headerlink" title="“伪造” AdaptorForge(M) 的源头"></a>“伪造” AdaptorForge(M) 的源头</h3><p>这一节尝试满足读者的头脑，分析为什么适配器会有前面提到的属性。</p><p>基本的 Schnorr 签名的涉及依赖于这样一个事实：Fiat-Shamir 启发法的应用 <em>在开始挑战之前固定了对话副本中的所有元素</em>。这防止了敌手在不知道秘密值的情况下反求解（back-solving）$\sum$-协议中的响应元素。这对适配器也适用，因此：</p><p>在应用到论点 1 时，如果承诺的数值是 $R$ ，那么我们并没有承诺用在适配器中的实际 nonce 值 $k - t$ ，而只是该值的一个偏移量 $k$，差值是未定义的数值 $t$，因此，我们可以任意的 $\sigma’$ 反求解 $T$ 的数值。</p><p>在应用到论点 3 时，承诺的数值是 $R _ {agg}$，而 nonce 值 $R _ j$ 在 <strong>Sign1Check</strong> 这一步中就承诺了，所以这些值都是固定的了，但我们没有承诺实际上的 nonce 秘密值 $k _ j - t _ j$ ，因为 $T _ j$ 是来自 $R _ j$ 的偏移量，可以在这些事件后反解出来。通过 <em>哈希成语境</em> 来固定 $R$ 并没有移除可伪造性，因为伪造的可能性躲在 nonce 偏移量 $k - t$ 中。</p><h3 id="存在适配器时碎片签名的不可伪造性"><a href="#存在适配器时碎片签名的不可伪造性" class="headerlink" title="存在适配器时碎片签名的不可伪造性"></a>存在适配器时碎片签名的不可伪造性</h3><p>在这一节中，我们将详细讨论，在超过一个签名会话中使用适配器会不会影响 MuSig 中定义的碎片签名（实际上也将影响完整签名）的不可伪造性。</p><p>作为前奏，我们需要概述 MuSig18 [10] 签名协议的步骤：对一条消息 $m$ ，一组 $N$ 个参与者，编号为 $i &#x3D; 1 … N$ ，插入位于合适点上的适配器：</p><ol><li><strong>KeySetup</strong>：每一位参与者都宣布碎片公钥 $\prod _ i$ ，所有参与者对 $P _ {agg} &#x3D; \sum \mathbb{H}(L, \prod _ i)\prod _ i$ 达成共识，其中 $L$ 是对公钥 $\prod _ 1…\prod _ N$ 的序列化。提醒，在本文中，$P _ i$ 指的是 $H(L, \prod _ i)\prod _ i$ 。</li><li><strong>Sign1Check</strong>：分享 nonce 承诺，每一位参与者都发送 $\mathbb{H}(R _ i)$ 给其他所有人。</li><li><strong>Sign2Check</strong>：分享 nonce 值 $R _ i$ ，然后验证其他人的 nonce 承诺。计算 $R _ {agg} &#x3D; \sum R _ i$ 。</li><li>（不是MuSig 的一部分，但，这就是要分享适配器的地方；见 <strong>AdaptorCreateM</strong>）。包括排序在内的细节，将在下文的特定情况下讨论。</li><li><strong>Round 3</strong>：分享碎片签名 $\sigma _ i &#x3D; k _ i + \mathbb{H}(R _ {agg}||R _ {agg}||m)x _ i$ （见上一章对 $x _ i$ 的定义）。准确来说，$\sum \sigma _ i$ 就是聚合公钥 $P _ {agg}$ 对消息 $m$ 的一个有效 Schnorr 签名。</li></ol><p>我们将在下列情况下提供作为参考的有序列表：</p><p><strong>基本情形：在一次会话中其中一方使用一个适配器</strong></p><p>考虑这样一种情形：编号为 $j$ 的参与者在一个签名会话中提供了一个适配器 $\sigma’ _ j$ 。在这种情形下，我们提出进一步的论点：</p><p><strong>论点 4</strong></p><p>*假设前面 3 步已经运行且成功完成。进一步假设一个参与者 $p _ j$ 运行了算法 <strong>AdaptotCreateM</strong>，产生了 $(\sigma’ _ j, T _ j)$ 。其对应的碎片签名 $\sigma _ j$ 在这些步骤之后是无法伪造被对手（$i \not&#x3D; j$）的任何子集伪造的，除非他们能解决椭圆曲线上的离散对数问题。*</p><p><em>证据</em>：我们展示一种标准的化约法：控制了所有参与者 $p _ i$（$i \not&#x3D; j$）、可以计算出 $\sigma _ j$ 的一个敌手 $\mathbb{A}$ ，可以抽取出任意的离散对数。</p><p>我们将敌手 $\mathbb{A}$ 封装起来，并取一个点 $Q$ 作为挑战值，并准备用 $\mathbb{A}$ 抽取出 $Q$ 背后的离散对数。我们运行上面的 1 ~ 3 步，然后使用伪造程序计算一个适配器，就跟论点 1 中的 <strong>AdaptorForge</strong> 一样，只不过有一处重要的修改；我们不假设我们已经知道了 nonce 秘密值 $k$：</p><ol><li>挑战者给我们一个点 $Q$ 。我们令 $R _ j :&#x3D; Q$ （注意，我们还不知道它的离散对数）</li><li>我们，作为参与者 $p _ j$ ，以及作为所有其他参与者的 $\mathbb{A}$ ，遵循上述步骤 1 ~ 3，如常产生一个 $P _ {agg}$ 和 $R _ {agg}$ 。</li><li>我们 <em>伪造</em> 一个适配器（见论点 1）：首先，随机选出 $\sigma’ _ j$ ，然后计算 $T _ j &#x3D; \mathbb{H}(R _ {agg}||P _ {agg}||m)P _ j - \sigma’ _ jG$ 。将元组 $(\sigma’ _ j, T _ j)$ 发送给 $\mathbb{A}$，后者可以用 $\mathbb{V} _ a$ 来验证。</li><li>$A$ 以不可忽视的概率返回编号 $j$ 的一个有效的碎片签名 $\sigma _ j$ 。</li><li>我们可以计算 $k _ j &#x3D; \sigma _ j - \mathbb{H}(P _ {agg}||R _ {agg}||m)x _ j$ ，作为 $Q$ 的离散对数，返回给挑战者。</li></ol><p>注意这个程序的不寻常一面：虽然我们的角色是 “诚实的” 参与者 $p _ j$ ，按要求遵循了协议的所有步骤，我们一开始也 <em>不知道</em> $R _ j$ 的离散对数，所以也无法真的制作出属于 $j$ 的碎片签名。但是，敌手 $\mathbb{A}$ <em>可以</em> 为我们制作出来的事实，产生了所需要的 ECDLP（椭圆曲线离散对数难题）化约效果。</p><p>同样要指出的是，这个论证的结构比起为 MuSig 展示一种化约到 ECDLP 或 OMDL 的方法，要简单得多；原因在于，我们并不尝试证明签名方案本身的健全性；（对 MuSig 来说）这样的证明已经存在。这里我们只尝试证明，对 <em>诚实参与者</em>（$p _ j$）来说，假设其已经知道私钥 $x _ j$ ，则添加适配器不会引起外部伪造的风险了；而且，让 <em>论证</em>  变得非常简单的，正是上文中详细讨论过的可伪造性。</p><p><strong>第二种情形：多个适配器，一个签名会话</strong></p><p>也许这是一种不实用的场景，但的确有可能发生：参与者 $p _ j$ 在同一个签名会话的第 4 步中<em>超过 1 个</em>对应于适配器点 $T _ q, q \in 1…m$ 的适配器。注意一个代数上的细微差别：在这样一种场景中，不仅碎片签名 $\sigma _ j$ 的曝光会同时揭晓对应所有对应的秘密值 $t _ q$ ，即使一个秘密值（比如 $t _ 1$）揭晓，也会导致其它所有秘密值 $t _ q$ 以及碎片签名 $\sigma _ j$ 揭晓。这本质上 “只有一个秘密值”。我们依然介绍这种情形，因为可以想象其重要性。</p><p>在这种情形中，来自前面章节的论证或多或少是一样的。我们生成 $m$ 个随机数值 $\sigma’ _ {j, q}$ ，然后为每一个使用相同的伪造程序，同时，像上一节一样，将 $R _ j$ 设为由挑战者给出的 $Q$（请记得，这里也只有一个 $R _ j$）。如果 $A$ 能成功制作碎片签名（$\sigma _ j$），那就能揭晓挑战值 $Q$ 背后的离散对数。</p><p>注意：因为在根据论点 1 给出的伪造程序计算数值 $T _ q$ 时使用了哈希函数 $H$，这种论证进队适配器点 $T$ 具有随机分布时才成立。</p><p><strong>第三种情形：一个适配器点，多个签名会话</strong></p><p>这是 “同时给出多个适配器” 的一个显然更有趣的应用：假设 Alice 希望为 $m$ 个 <em>不同</em> 的签名语境提供同一个点 $T _ A$ 上的适配器，这些语境是她跟 $N$ 个不同的对手 Bob、Carol 等人建立的。实际上，适配器最基础的应用就是基于适配器的 CoinSwap [14] ，正是这种情形的两方特例。</p><p>这第三种情形不能用第一种情形那样的碎片签名伪造程序证明是安全的。原因在于，我们的算法 <strong>AdaptorForgeM</strong> 在应用时只能生成一个不可预测的数值 $T$ ；如果我们要在多个签名会话中使用 <em>相同的</em> $T$ ，就不能直接使用它。</p><p>为了让化约能够进行，我们需要给论证增加两个 约束&#x2F;假设。首先，我们依赖于 “随机数断言机模型（ROM）”，以允许我们在特定时间点修补哈希函数的输出，再交给敌手。其次，对时间序列有个限制：不同签名会话中的 <strong>Sign1Check</strong> 和 <strong>Sign2Check</strong> 不能并行执行。</p><p>最后要指出的是：这样一来，化约中的 “密合性（tightness）” 必然减少，原理上是因为有多种伪造可能性，即，原理上是 $m$ 的一个线性因子。</p><p>因此，我们定义 $A _ 2$ 为：（1）它扮演 $m$ 个签名会话中编号为 $2…N$ 的所有对手；（2）它被给予 <strong>KeySetup</strong>, <strong>Sign1Check</strong> 以及 <strong>Sign2Check</strong> 的有效输出。注意，如前所述，这些步骤都完成了，但 $m$ 个签名会话中的每一个都是按顺序完成的，<em>不是</em> 并行完成的。（3）<em>然后</em>，它得到 $\sigma’ _ {1, 1},\sigma’ _ {1, 2},…\sigma’ _ {1, m}$ 其中 $\sigma’ _ {x, y}$ 是编号为 $x$ 的参与者在第 $y$ 个会话中的签名适配器。（4）$\mathbb{A} _ 2$ 的任务是以不可忽视的概率，在 <em>至少一个签名会话中</em>输出伪造的有效碎片签名 $\sigma _ {1, q}$ 。</p><p>现在，我们基于比 “论点 4” 更复杂的游戏，将签名伪造化约成 ECDLP。</p><ol><li>挑战者给我们一个点 $Q$ 。我们令 $R _ {1, 1} :&#x3D; Q$ 。</li><li>在 $m$ 个签名会话（编号为 $q$ ）中，MuSig 的所有参与者都可以运行 <strong>KeySetup</strong> ，从而对 $P _ {agg, q}$ 达成一致。</li><li>然后，我们作为 $p _ 1$ ，跟 $\mathbb{A} _ 2$（作为其他参与者）一起，<strong>仅在第一个签名语境中</strong>，运行 <strong>Sign1Check</strong> 和 <strong>Sign2Check</strong> ，从而产生 $R _ {agg, 1}$ 。</li><li>现在，我们如 “论点 4” 一样，为 <em>签名语境 1</em> 伪造一个签名适配器：首先，随机选出 $\sigma’ _ {1, 1}$ 。然后计算 $T _ 1 &#x3D; R _ {1, 1} + \mathbb{H}(R _ {agg, 1}||P _ {agg, 1}||m _ 1)P _ {1,1} - \sigma’ _ {1, 1}G$ 。这时候，（在签名会话间）共享的 $T _ 1$ 就决定好了。</li><li>下一步，对于所有剩余的签名会话 $q \in 2…m$ ，我们做这些：（1）随机选出 $\sigma’ _ {1, q}$ 。（2）为 $\mathbb{H}(R _ {agg, q}||P _ {agg, q}||m _ 1)$ 选出一个随机的数值 $H$ （注意，这时候我们还不知道 $R _ {agg, q}$ ）。（3）计算  $R _ {1, q} &#x3D; T _ 1 + \sigma’ _ {1, q}G + H P _ {1, q}$ 。</li><li>现在，我们为 $q \not&#x3D; 1$ 的语境提供准备好的 $R _ {1, q}$ 并运行 <strong>Sign1Check</strong> 和 <strong>Sign2Check</strong> 。注意，这些步骤 <em>不需要</em> 查询哈希函数 $\mathbb{H}$，只需要提供用来作为承诺的 $\mathbb{H} _ c$ 。在这个点上，我们拥有了 $R _ {agg, q}$ ，所以我们可以放置后门，令 $\mathbb{H}(R _ {agg, q}||P _ {agg, q}||m _ q) :&#x3D;H$ 。</li><li>为编号为 $2…m$ 的所有语境完成上面的两步之后，我们有了一组签名适配器 $(\sigma’ _ {1, 2}, T _ 1), … , (\sigma’ _ {1, m}, T _ 1)$ ，都交给 $\mathbb{A} _ 2$ 。</li><li>对 $\mathbb{A} _ 2$ 来说，所有这些适配器都可以通过 $\mathbb{V} _ a$ 验证，因为，很容易检查出来，因为我们的随机数断言机有后门。</li><li>$\mathbb{A} _ 2$ 以不可忽略的概率（定义为 $p$），为<strong>至少一个签名会话</strong> $q \in 1…m$ 返回一个有效的碎片签名 $\sigma _ {1, q}$ 。</li><li>以概率 $\frac{p}{m}$ ，$\mathbb{A} _ 2$ 为第一个签名会话返回有效的碎片签名。这时候，我们就可以计算 $k _ {1, 1} &#x3D; \sigma _ {1, 1} - \mathbb{H}(P _ {agg,1}||R _ {agg,1}||m)x _ {1,1}$ ，从而我们可以返回 $Q$ 的离散对数。</li></ol><p>按顺序提供一些解释：</p><ul><li>上面的第 10 步有一个未言明的假设：我假定敌手 $\mathbb{A} _ 2$ 为每个签名语境成功伪造碎片签名的概率是相同的。这个假设背后的直觉是，呈现给 $\mathbb{A} _ 2$ 的 <em>新</em> 信息（相比于常规的 MuSig 签名会话），是一次性给出的：一组签名适配器。不过，这并不严格，所以也许这个论证还可以收紧一点。</li><li>不管怎么说，化约密合性的损失并不 <em>恰好</em> 是因子 $m$ ：随机数断言机的后面引入了另一个因子（由于碰撞的可能性），虽然我们认为这是微不足道的，而且不重要。</li><li>这里并没有论证并行运行所有会话的 <strong>Sign1Check</strong> 和 <strong>Sign2Check</strong> 就是 <em>不安全的</em> ；关于这一点，我们没有意见。但我们这里的化约法要求在所有其它会话<strong>之前</strong>运行<strong>一个</strong>会话。</li></ul><p><strong>第四种情形：多方在多个签名会话中使用自己的适配器</strong></p><p>在一个（一组）签名会话中，每一方都需要一种安全性：他们 <em>自己</em> 的碎片签名无法被其他参与者的任何子集伪造。我们认为，上面的论证已经能解决这个问题。如果（敌意的）对手制作了自己的签名适配器，这只会给诚实参与者提供额外的信息，因此不构成额外的安全风险。这个命题假设了我们会让 “论调 4” 所展示的事件 1 ~ 5 保持相同顺序。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li>“Adaptor signatures”, Poelstra, 2017 <a href="https://download.wpsoftware.net/bitcoin/wizardry/mw-slides/2017-03-mit-bitcoin-expo/slides.pdf">https://download.wpsoftware.net/bitcoin/wizardry/mw-slides/2017-03-mit-bitcoin-expo/slides.pdf</a></li><li>MuSig (3-round), Maxwell, Poelstra, Seurin, Wuille<br><a href="https://eprint.iacr.org/2018/068">https://eprint.iacr.org/2018/068</a> </li><li>MuSig2, Nick, Ruffing, Seurin 2021<br><a href="https://eprint.iacr.org/2020/1261">https://eprint.iacr.org/2020/1261</a></li><li>Bitcoin Improvement Proposal 340 (Schnorr signatures)<br><a href="https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki</a></li><li>Bitcoin Improvement Proposal 327 (MuSig2 protocol)<br><a href="https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki</a></li><li>Multiparty S6 (blog; how to do a multiparty adaptor-based swap).<br><a href="https://reyify.com/blog/multiparty-s6">https://reyify.com/blog/multiparty-s6</a></li><li>Boneh and Shoup’s Graduate Course in Cryptography (contains a lot of useful fundamentals on security proofs)<br><a href="https://toc.cryptobook.us/">https://toc.cryptobook.us/</a></li><li>Discreet Log Contracts, Dryja<br><a href="https://adiabat.github.io/dlc.pdf">https://adiabat.github.io/dlc.pdf</a></li><li>Generalized Channels from Limited Blockchain Scripts and Adaptor Signatures, Aumayr et al<br><a href="https://eprint.iacr.org/2020/476">https://eprint.iacr.org/2020/476</a></li><li>Two-Party Adaptor Signatures From Identity Schemes, Erwig, Faust, Hostakova, Maitra, Riahi<br><a href="https://eprint.iacr.org/2021/150">https://eprint.iacr.org/2021/150</a></li><li>Short signatures from the Weil pairing, Boneh, Lynn, Shacham 2001<br><a href="https://www.iacr.org/archive/asiacrypt2001/22480516.pdf">https://www.iacr.org/archive/asiacrypt2001/22480516.pdf</a></li><li>Anonymous Atomic Locks for scalability in Payment Channel Hubs, Tairi, Moreno-Sanchez, Maffei 2019<br><a href="https://eprint.iacr.org/2019/589">https://eprint.iacr.org/2019/589</a></li><li>One-Time Verifiably Encrypted Signatures, Fournier 2019<br><a href="https://eprint.iacr.org/2019/589">https://eprint.iacr.org/2019/589</a></li><li>Scriptless script based atomic swaps, Blockstream Research<br><a href="https://github.com/BlockstreamResearch/scriptless-scripts/blob/master/md/atomic-swap.md">https://github.com/BlockstreamResearch/scriptless-scripts/blob/master/md/atomic-swap.md</a></li><li>Adaptor signatures, summary by Bitcoin OpTech<br><a href="https://bitcoinops.org/en/topics/adaptor-signatures/">https://bitcoinops.org/en/topics/adaptor-signatures/</a></li><li>Anonymous Multi-Hop Locks<br><a href="https://eprint.iacr.org/2018/472">https://eprint.iacr.org/2018/472</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;作者：AdamISZ&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;来源：&lt;a href=&quot;https://github.com/AdamISZ/AdaptorSecurityDoc/tree/main&quot;&gt;https://github.com/AdamI</summary>
      
    
    
    
    
    <category term="密码学" scheme="https://www.btcstudy.org/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>便利性与安全性的取舍光谱</title>
    <link href="https://www.btcstudy.org/2024/07/08/continuous-usability-vs-security-tradeoff-spectrum/"/>
    <id>https://www.btcstudy.org/2024/07/08/continuous-usability-vs-security-tradeoff-spectrum/</id>
    <published>2024-07-08T03:52:41.000Z</published>
    <updated>2024-09-02T04:30:25.017Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Giacomo</em></p><p><em>本文为 Giacomo Zucco 在推特上对批评 ecash 的意见的回复。他将不同的方案视为在用户的便利性和自主保管安全性之间取舍，并且这种取舍不是非此即彼的，允许作出不同程度的微调。</em></p><p><em>来源：<a href="https://x.com/giacomozucco/status/1810038033967952019">https://x.com/giacomozucco/status/1810038033967952019</a></em></p></blockquote><p>notgrubles：</p><p>（不论如何）我还没看过谁可以教大家怎么审计 ecash 铸币厂、保证铸币厂不是搞部分储备金的把戏。</p><p>Giacomo Zooko：</p><p>便利性和安全性的取舍是一条连续的光谱。</p><p>电子表格：直接信任一个第三方（译者注：指托管式交易所这样的完全托管方案）</p><p>Ecash 铸币厂：与上一种情况相同，但那个第三方无法 跟踪你&#x2F;刺探你的隐私</p><p>Element 这样的侧链 + 机密交易（CT）：与 ecash 铸币厂相同，同时，第三方无法搞通胀，也没法搞部分准备金（译者注：Element 是 Liquidity 侧链背后的技术方案。）</p><p>Statechain：与上一种情形相同，但第三方只有跟 statechain 资金的前任所有者串通才能跑路（重复花费）</p><p>Ark：与 statechain 相同，但第三方无法审查你，而且即使能跟前任所有者串通，也只能影响近期的一些交易，时间上足够久远的交易不受影响（除非这个第三方也拥有 51% 的哈希率）</p><p>Poon-Drija 通道：与 Ark 相同，但仅在你连续几周都不回到线上时，第三方才能跑路&#x2F;审查你的交易（除非这个第三方拥有 51% 的交易）（译者注：就是当前使用的闪电通道。）</p><p>排他控制的链上资金：与上一种情形相同，但即使没有惩罚机制，第三方也无法使用旧状态来跑路（除非他有 51% 的哈希率）</p><p>每前进一步，安全性都会提升，但引导用户采用的成本、流动性挑战和确认时间也会增加。智能的比特币钱包将自动管理光谱上的资金，从小额的白银和快速的交易到大额的储蓄资金、长期储蓄。闪电网络将成为在所有这些安全性模型之间切换的通用语言。</p><p>另一个完全正交的光谱是：这个受信任的人是<strong>谁</strong>。</p><p>可以是一个人，比如 <a href="https://x.com/callebtc">@callebtc</a> （实用，也简单，但安全性差）</p><p>也可以是一个声誉良好的全球性联盟，比如 Liquid（容易审查你，但不太可能跑路）</p><p>或是由许多小型的地方性联盟比如 Fedis 拼凑起来的网络（很难全局性审查你，但更有可能跑路）</p><p>或者是许多准受信任的对手方，我们都已经有商业关系的那种。</p><p style="text-align:center">- - -</p><blockquote><p><em>一年前，Giacomo 在讨论 Drivechain 时也使用的相同的方法，认为不同方案的安全性是落在一条连续的光谱上的。</em></p><p><em>来源：<a href="https://x.com/giacomozucco/status/1679758359979872259">https://x.com/giacomozucco/status/1679758359979872259</a></em></p></blockquote><p>Giacomo：</p><p>我认为，也许所有的现实都可以被表述为程度上的差异。但在一条连续的光谱上，Drivechain 的安全模型更接近于 Liquid 而不是比特币 L1 。而 Liquid 又更接近于 Coinbase 交易所（托管模式）而不是（整体上的）闪电网络。在我看来，将 “托管” 的门槛放在 Drivechain 和 Liquid 之间是非常奇怪的，而且会产生误导。实情应该是这样的：</p><p>实物黄金</p><p>|<br>|<br>|</p><p>非常老的比特币 L1 UTXO</p><p>|<br>|<br>|</p><p>只有一次确认的 UTXO</p><p>|</p><p>闪电通道</p><p>|</p><p>Ark</p><p>|<br>|<br>|<br>|<br>|</p><p>Statechain</p><p>|<br>|<br>|<br>|</p><p>Drivechain</p><p>|</p><p>Liquid</p><p>|</p><p>Fedimint</p><p>|</p><p>Cashu</p><p>|</p><p>Coinbase 账户</p><p>（完）</p>]]></content>
    
    
    <summary type="html">比较不同方案的取舍</summary>
    
    
    
    
    <category term="Ecash" scheme="https://www.btcstudy.org/tags/Ecash/"/>
    
  </entry>
  
  <entry>
    <title>2100 万比特币全部都已问世</title>
    <link href="https://www.btcstudy.org/2024/07/05/all-21-million-bitcoin-already-exist/"/>
    <id>https://www.btcstudy.org/2024/07/05/all-21-million-bitcoin-already-exist/</id>
    <published>2024-07-05T03:22:00.000Z</published>
    <updated>2024-09-02T04:30:25.009Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Phil Geiger</em></p><p><em>来源：<a href="https://unchained.com/blog/all-21-million-bitcoin-already-exist/">https://unchained.com/blog/all-21-million-bitcoin-already-exist/</a></em></p><p><em>本文首次出版于 2019 年。</em></p></blockquote><blockquote><p><em>“货币量的每一部分都由市场经济的某一个成员持有。从一个成员的控制下转移给到另一个成员，货币的转移是迅捷且川流不息的。”</em></p><p>—— 路德维希·冯·米塞斯，《人的行动》</p></blockquote><p>为庆祝第 60 万个比特币区块挖出（这使比特币的供给量达到 1800 万 BTC），也为了在欢庆活动上当一个更加风趣的人，我要解释一下 “2100 万 BTC 全部都已问世” 这个想法。这可能听起来像一个文字游戏，或者是一种小圈子黑话，但比特币是完全不同的物种，它要求我们仔细检查我们头脑中的假设，以及我们用来描述它的语词。如果能更清楚地定义比特币、解释它的工作原理，我们就能更准确地描述其货币化进程，这最终会帮助持币人向自己的家人和朋友介绍它。我们可以活着，并见证经济史上最大的事件 —— 一种稀缺的、非政治性的全球货币的迅速扩张。如果比特币能够存活，为我们的社区提供一种先发的竞争优势，可能会在长远的未来带来许多正面影响。</p><p>在比特币世界中，不当用词早已风行，例如 “钱包”、“地址” 和 “挖矿” 这样的术语。比特币的钱包更接近于一串钥匙，或者 公私钥的一个 生成&#x2F;协调 工厂。比特币的地址也并不是我们希望用户重复访问的位置，跟现实世界中的地址以及电子邮件地址都完全不同。挖矿也有类似的不准确之处。我认为，这就是我们在分析比特币的时候，许多困惑的来源；同时也是许多围绕比特币的 FUD（利用怀疑来勾起的恐惧）着力的地方，因为对于新人来说，这些词很容易被错误解读，也极为让人困惑。</p><p>为了理解 “2100 万 BTC 全部都已问世” 这个想法，我们需要解释一些问题和假设。一个计算机程序能够持有 BTC 吗？为了发起一笔比特币交易，需要输入哪些东西？为什么人们会选择某一种交易方法，而不是另一种？什么什么，2100 万 BTC 就问世了？可得和不可得的供给量有何区别？</p><p>首先，我们要理解，比特币的供给量与另一种 “硬通货” 的供给量有何区别。我们先来比较比特币和另一种货币：黄金。</p><h2 id="比特币的供给量-vs-黄金的供给量"><a href="#比特币的供给量-vs-黄金的供给量" class="headerlink" title="比特币的供给量 vs. 黄金的供给量"></a>比特币的供给量 vs. 黄金的供给量</h2><p>最准确的说法是，基于我们当前对物理学和化学的理解，宇宙中绝大部分黄金（AU 这种物质）的供给量都已经存在了，额外的增量来自于未来发生的核爆炸。</p><p>而黄金和比特币在供给量上的关键差别来自于我们探知其供应量的能力。由于<a href="https://en.wikipedia.org/wiki/Expansion_of_the_universe">宇宙的膨胀</a>以及宇宙中速度上限（光速）的存在，人类没有办法估计黄金的总供应量，因为其存在位置是不可知的，有可能在非常非常遥远的地方有很多的黄金。</p><p>另一方面，关于比特币的总供应量，我们有非常强的社会和技术共识；而且我们还知晓被锁定的供应量的确切位置。事实上，我们对未来的区块 “存储” 着多少比特币的了解，比起当前已经解锁的供应量都分布在哪里，要多得多。我们完全知道，新发现的比特币区块的 “<a href="https://blog.cex.io/bitcoin-dictionary/coinbase-transaction-12088">coinbase 交易</a>”将解锁多少 BTC，但我们没法知道现在是不是有某个百万币翁，正准备在某一刻卖出自己所有的比特币、换成另一种货币。</p><p>比特币会根据一个设定好的供给量日程表解锁，而且它是通过一个每 2016 个区块发生一次的难度调整程序来自动校正的，所以这个日程表能得到维持。这使我们能非常肯定地知道，当前还在锁定状态的 300 万 BTC 什么时候会解锁（具体的区块高度）；程度稍差一些但依然能非常准确地知道的是，什么时候这些比特币可以被私钥花费（按平均 10 分钟发现一个区块的速度计算）。难度调整就是利用个体经济激励来维持比特币自身增长的特性。通过让难度与网络的规模成比例，它阻止了人们创造更多的供应量，反而用人们的努力来提供网络的安全性。</p><p>理论上来说，我们可以知道地球上的所有黄金都存储在哪里，但我们没法准确知道什么时候能挖出它们、届时提取黄金的成本又是多少，也没法准确知道地球之外有多少黄金。因此，我们可以作一个假设：如果黄金变得足够有价值，我们可以，也必将找出一种办法、开采更多黄金，无论是在地球或地外星球上挖矿，还是利用核爆炸来生成。这都是由供给和需求决定的。不论什么商品和服务，只要需求变得足够高，都会提高人们增加供给的激励。</p><p><img src="/../images/all-21-million-bitcoin-already-exist/300x120.png" alt="img"></p><p>而比特币网络自身就等于 2100 万 BTC 的供给量。在 供给-需求 曲线模型中，它的供给量是一条垂线，意思是，它是完全没有弹性的。这个限制写在所有全节点运营者都选择运行的代码中，而且更重要的是，这是我们买下我们的第一笔比特币的时候全都同意的事情 —— 它得到了几乎全体一致的社会共识。在比特币的历史中，人们发现了多种会导致通货膨胀的<a href="https://hackernoon.com/bitcoin-core-bug-cve-2018-17144-an-analysis-f80d9d373362">技术漏洞</a>，而且<a href="https://en.bitcoin.it/wiki/Value_overflow_incident">有一个还真的被利用了</a>，但网络最终将这些交易认定是无效的少数派硬分叉，继续维持得到理解的供给量日程表，即使这需要节点运营者运行打过补丁的软件。合理预期，在未来我们还会发现这样的软件漏洞，网络还将不得不依赖于社会共识。幸运的是，比特币网络的激励都是围绕着在社会上和技术上维持这个 2100 万 BTC 限制而设计出来的。</p><p><img src="/../images/all-21-million-bitcoin-already-exist/phiel-twitter.png" alt="phiel-twitter"></p><p style="text-align:center">- 全节点运营者都相当笃定这个 2100 万限制。这个问卷调查的结果将是比特币跟一种非主流币竞争，而后者显然可以命名为 “Bitcoin Inflation” -</p><p>至于黄金，则无法达成管理供应量的技术和社会共识。黄金只是一种元素，没办法知道什么时候会挖出黄金、如何挖出黄金、以哪一种数量单位得到使用。在黄金这个例子中，我们可以使用基于供给量的预测模型来度量未来的供给量。但我们无法知道宇宙中存在多少黄金，我们只知道在地球上增加多一些供给量有多难。我们也可以在需求保持相对稳定的前提下预估黄金的供给量会如何膨胀。</p><h2 id="那要按你这么说，挖矿又算怎么回事呢？"><a href="#那要按你这么说，挖矿又算怎么回事呢？" class="headerlink" title="那要按你这么说，挖矿又算怎么回事呢？"></a>那要按你这么说，挖矿又算怎么回事呢？</h2><p>在比特币中，人们有两种办法交易比特币。第一种办法是大多数人都知道并且喜欢的，基于私钥的身份验证。如果某人持有跟某个有资金的地址相关联的私钥，就可以通过公开发布来自这个私钥的签名来移动该地址内的资金，同时，交易中要包含手续费，以激励整个网络购买电力、处理交易。但首先，要想获得比特币，一定有某人在某个地方消耗了能量来获得 BTC。</p><p>第二种办法，就是以运行 <a href="https://en.bitcoin.it/wiki/SHA-256">SHA-256 哈希算法</a>的形式，将电力卖给比特币网络 —— 这就是我们平时说的（错误称呼的） “挖矿”。</p><p>通过将尽可能便宜的电力转化为尽可能多的 SHA-256 哈希运算，这些比特币人会同时排序和提出待处理比特币交易的批次，并找出<a href="https://en.bitcoin.it/wiki/Mining">在当时难度下这一批次交易（也即区块）的有效 SHA-256 哈希值</a>。如果你的 ASIC（专用型集成电路）可以在别人之前找出一个有效哈希值，并且该区块内的交易也都是有效的（可以通过全节点基于规则的验证），你就可以决定该区块的 <a href="https://blog.cex.io/bitcoin-dictionary/coinbase-transaction-12088">coinbase 交易</a>，它包含了人们常说的挖矿奖励，以及该区块内的交易所提供的手续费，你可以把它发到任何你想要的地址。</p><p>那么，“矿工” 到底是创造了新的供给量呢，还是以 SHA-256 运算的形式花费电力、从而换来了人们早就知道的 coinbase 交易以及交易手续费呢？</p><p><img src="/../images/all-21-million-bitcoin-already-exist/phiel-twitter-2.png" alt="phiel-twitter-2"></p><p style="text-align:center">- 还真是旗鼓相当。52% 的人认为矿工在某种意义上创造了供应量，而 48% 的人认为他们没有。很可能是因为这个调查的用词不妥当 -</p><p>我个人认为，这是以个微妙但重要的区别，让我们可以权威地说，只有 2100 万 BTC 可能存在（不可能更多）。问题（某种程度上）在于每一个全节点运营者和持币人需要作的个人决定。节点运营者个人并不能定义什么是比特币、什么不是，他们只能验证一笔比特币是不是真的存在，而他们个人要么在共识之中，要么在共识之外。那么，当我们到达 63 万区块高度、发生下一次区块奖励减半时，你的全节点会接受 12.5 BTC，还是只接受 6.25 BTC？</p><p>我的节点会拒绝任何尝试花费不遵守供给量日程表的 coinbase 交易的区块，因为根据我认可的社会和技术共识，这就是一笔无效的比特币交易。在个体组成的分布式网络中，每个人都作出这样的个人选择，市场最终会决定哪一种货币是比特币；而截至今日，市场已经客观地将比特币的数量限制设定为 2100 BTC。</p><h2 id="如果一台计算机在森林里孤独地运算哈希值，谁会在乎？"><a href="#如果一台计算机在森林里孤独地运算哈希值，谁会在乎？" class="headerlink" title="如果一台计算机在森林里孤独地运算哈希值，谁会在乎？"></a>如果一台计算机在森林里孤独地运算哈希值，谁会在乎？</h2><p>将电力转化成 SHA-256（或任何其他算法）哈希值，这本身时没有生产力的活动，除非它服务于一些有价值的目标。为了比特币网络，将电力转化为哈希值，就是有生产力的，也是有利可图的，因为比特币持有者为使用电力保护网络出了价，只要 “矿工” 遵守了持币人和全节点运营者的共识所确定的规则。</p><p>对于有兴趣向网络出卖用于哈希计算的电力、以换取获得 coinbase 资金和交易手续费的机会（也即挖矿）的个人来说，只有少数规则是绝对固定的。其中最重要的规则就是只有 2100 万 BTC。下一个规则就是，coinbase 交易中的 BTC 数量，会从 2009 年的 50 BTC 开始，每挖出 21 万个区块就降低一次，直至 2140 年，所有的比特币都可被私钥花费。在此之后，用于哈希计算的电力将只能买到获得 “交易手续费” 的机会，而交易手续费就来自使用私钥发起交易、广播交易的用户。</p><p>对 “矿工” 来说，幸运的是，难度调整保证了总有一些人能从向网络出售电力而获利（哈希运算效率最高的那些人）。如果某个矿工在长期中无利可图，他就必须作出选择，要么关停自己的业务（可能要在二级市场上卖掉自己的硬件），要么找出更便宜的电力来源。要是很多 “矿工” 都无利可图，关掉了自己的机器，那么网络的哈希速度会下降，找出新区块的时间将长于 10 分钟，然后难度调整算法就会将难度重新校准为适应新的、更低的哈希速度，从而维持供给量日常表（平均而言）。结果是，比特币网络将不断调准自身，基于网络的价值，为转化成哈希运算的电力支付市场价格。如果某个矿工在向比特币网络卖出电力时是无利可图的，这仅仅意味着他被其他更高效的 “矿工” 击败了。</p><p>给定这些绝对严格的网络规则，聪明的 “矿工” 会很快意识到，如果他们能让电力成本趋近于零，比如说自己来发电并决定是否要用在别的用途种（或是为比特币网络运算哈希函数），他们就可以永远卖出运行哈希计算的电力而有利可图。</p><h2 id="货币的价值重要，但有多少数量不重要"><a href="#货币的价值重要，但有多少数量不重要" class="headerlink" title="货币的价值重要，但有多少数量不重要"></a>货币的价值重要，但有多少数量不重要</h2><blockquote><p><em>“必须指出的是，货币的总存量水平，与一单位货币的价值水平，在考虑使用这种货币能得到什么好处的时候，是完全没有意义的。社会总是在享用使用货币所能得到的最大好处。即使社会一同抛弃了一半的货币，货币所产生的效应也将与存量保持不变时相同；甚至即使货币单位的价值的变动并不与货币存量的变动成比例，也依然是如此。”</em></p><p>—— 路德维希·冯·米塞斯，《货币与信用理论》</p></blockquote><p>在中本聪找出比特币的创世区块、哈尔·芬尼以及朋友们开始参与网络之后，根据代码（以及，更重要的，社会共识）中设定的规则，全部 2100 万 BTC 就在一个 “大爆炸” 的时间立即问世了。每一位拿运行哈希计算的电力交换 coinbase 交易的早鸟都获得了大量比特币的私钥访问权（在当时并没有价值），同时理解了规则：未来的持币人和 “矿工” 可以通过发送电力来相互竞争、处理交易，从而获得被锁定的比特币供给量。</p><p>如此一来，我们就可以看到被锁定的比特币的价值，虽然它是分散的，是由网络的每一个成员平等拥有的。这个价值是由持币人按照市场价格支付给向网络提交电力的 “矿工” 的；而这个市场价格又由这些电力所保护的网络的价值来衡量。在 2009 年，比特币网络仅对少数几个人有价值，而且价值非常小，所以换得 50 BTC coinbase 资金所需的电力代价是非常低的。今天，获得解锁 12.5 BTC 的能力值得花费大约<a href="https://www.blockchain.com/en/charts/hash-rate">每秒 100 兆次哈希运算的电力</a>。</p><p>每个加入网络的人，不论出于什么原因，都应该知道，截至 2019 年 10 月，其所获得的价值中大约 14%（300 万&#x2F;2100 万）是由网络中的所有成员平等拥有的，只有为排序和保护交易提交有效的 PoW 才能取得这些价值。这从比特币诞生的第一天开始，就已经由供给量日程表决定了，而且在未来，向网络销售哈希化电力的经济激励也不会改变。难度调整机制从设计上就保证了，对于最高效的能源生产者来说，向比特币网络卖出最便宜的电力总是有利可图的。</p><p>曾有人猜测，机器和软件也可以持有比特币并用私钥来转移它。我则认为，我们已经有 11 年的经验证据，表明网络自身一直在持有和交易比特币，只不过不是用的私钥签名，而是用于哈希运算的电力。</p><p>重要的不是某人或者另一个人所拥有的比特币的数量。网络整体的价值才重要，而网络的价值只有在人么理解到比特币的货币属性是健全的，才能够增长。世上只有 2100 万 BTC。</p><h2 id="全都存在，或全都不存在"><a href="#全都存在，或全都不存在" class="headerlink" title="全都存在，或全都不存在"></a>全都存在，或全都不存在</h2><p>比特币的创新在于人们可以用无国界、中立、免许可的方式获得绝对的稀缺性。这一创新对人类交互的所有方面都有惊人的颠覆作用，而且正是这种创新，驱动网络的价值不断增长。比特币与其 2100 万数量上限密不可分。它的供给量不可能是 2100 万 BTC 以外的水平，因为那将违背我们的认知，以及对其网络运行原理的理解，并且也将无法解决 “电子化稀缺性” 的问题。</p><p>比特币可以实现绝对稀缺性，是靠着这个网络架构，它被设计成在时间推移中逐步提高去中心化程度，并且主动地拒绝人类增加高需求商品供给量的欲望。不断提升的去中心化程度实质上将比特币总供给量的决定权众包给了整个网络的参与者，其基本假设是在一个由个体组成的去中心化网络中，当没有人可以征收铸币税时，他们不会贬值自己的货币。</p><p>因此，谨慎的全节点运营者，“矿工” 和持币人，都可以假设这 2100 万 BTC 的限制是不可谈判的。对这种颠覆性稀缺的知识会通过自由市场以及 “作为最终决定者的持币人” 网络逐渐传播开去，但整个实验依然依赖于数量限制所形成的坚实基础，以及人们可以遵循的清晰、中立、不可变更的规则。</p><p>因为我们自愿选择了这个网络，我们可以说，今天，2100 万 BTC 已然存在，因为网络共识所遵循的规则规定供给量日程表必须得到维持。可访问&#x2F;不可访问 的供给量的唯一区别在于谁（或者说什么东西）当前持有比特币 coinbase 的价值，以及人们要如何竞争才能获得比特币，无论是由区块链跟踪的比特币（可以访问的），还是由区块高度、PoW 和难度调整决定的比特币（当前还不可访问的）。</p><p>电子化稀缺性是一个奇异的想法。由区块链跟踪的比特币最终来说只是一些 1 和 0，以及由经济激励所支持的数学函数。coinbase 交易中的比特币也是一样的。日程表卸载我们所运行的软件中，而且未来的区块不可能包含更多的 coinase 资金，因为社会和技术共识将认为它是无效的，并非比特币。</p><p>比特币是代码和社会共识的互动。你可以说，所有的比特币（2100 万 BTC）都已经存在，你也可以说，根本就不存在比特币。没有中间地带。</p><p style="text-align:center">- - -</p><p>本文仅代表我的而个人观点，不代表 Unchained Capital 或者我的同事。感谢 <a href="https://twitter.com/parkeralewis">Parker Lewis</a>、<a href="https://twitter.com/nolanbjohnson">Nolan Johnson</a> 和 <a href="https://twitter.com/bitstein">Michael Goldstein</a> 审核我的文章并给予我有价值的反馈。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">关键差别来自于我们探知其供应量的能力</summary>
    
    
    
    <category term="货币理论" scheme="https://www.btcstudy.org/categories/%E8%B4%A7%E5%B8%81%E7%90%86%E8%AE%BA/"/>
    
    
    <category term="货币" scheme="https://www.btcstudy.org/tags/%E8%B4%A7%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>十字路口的密码学：道德责任，密码朋克运动与机构</title>
    <link href="https://www.btcstudy.org/2024/07/02/cryptography-at-the-crossroads/"/>
    <id>https://www.btcstudy.org/2024/07/02/cryptography-at-the-crossroads/</id>
    <published>2024-07-02T08:18:40.000Z</published>
    <updated>2024-09-02T04:30:25.021Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Eric Blair</em></p><p><em>来源：<a href="https://eprint.iacr.org/2024/970.pdf">https://eprint.iacr.org/2024/970.pdf</a></em></p><p><em>译者：Kurt Pan</em></p></blockquote><p>本文受《密码朋克宣言》和 Phillip Rogaway 对密码学的道德特征分析的启发，探讨了密码学工作和道德责任与政治行动主义（political activism）的交叉点。讨论涵盖了密码学发展的历史背景、密码朋克意识形态的哲学基础，以及大规模监控和隐私问题带来的当代挑战。通过研究这些方面，本文呼吁重新致力于开发优先考虑人权和公共物品的密码学解决方案。</p><p style="text-align:center">- - -</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>密码学长期以来一直是确保通信安全和保护隐私的工具。然而其作用已然超出了技术实现的范畴，涵盖了重要的政治和道德维度。由 Eric Hughes 于 1993 年撰写的《密码朋克宣言》[7] 强调了密码学固有的政治本质，并提倡将其用作确保隐私和个人自由的手段。同样，Phillip Rogaway 的工作 [10] 强调了密码学家的道德责任，特别是在大规模监视和社会影响的背景之下。</p><p>根本上看，密码学可以被视为大众保护自己的一种“武装”手段。 1993 年的宣言和 Rogaway 的工作强调了两个关键点：对政府的不信任和对集体数据的保护。这一观点在 David Chaum 的想法中得到了呼应，他提出了一种依靠强加密来保护隐私的交易模型。尽管距离这些想法首次提出已经过去了 40 多年，但保护社会免遭信息滥用的梦想仍然遥不可及。正如 Chaum 警告的：</p><blockquote><p>“计算机化正在剥夺个人监督和控制关于其自身的信息的使用方式的能力。 （…）正在为一个档案社会奠定基础，在这个社会中，计算机可用于根据普通消费者交易中收集的数据推断其个人的生活方式、习惯、行踪和关系”[5]。</p></blockquote><p>现实中，我们已经走向了不同的方向。今天，我们依靠这些数据来简化和改善我们的生活。此外，我们愿意提供这些数据，以使设备“更智能”，更适合我们的需求。一方面，这让我们有更多时间专注于其他任务，例如开发先进的人工智能技术。另一方面，我们也忘记了密码学为何必要的本质以及最初的梦想是什么。</p><p>从以隐私为中心的观点转向为了方便而拥抱数据共享的观点凸显了一个重大的道德困境。虽然技术进步让生活变得更加轻松，但也增加了创造出一个监控社会的风险。旨在赋予个人权力并保护他们的隐私的密码朋克精神似乎与当今实践并不一致。为了调和这些差异，密码学家和隐私倡导者必须重新点燃密码学的最初愿景——不仅将其作为一种寻求便利的工具，而且要将其作为一种维护隐私、自主和抵御不受控的监控的手段。</p><p>范式的另一个转变涉及密码学和安那其主义之间的联系。正如最初的密码安那其主义宣言中所阐述的那样，安那其主义的思想和密码学的使用是紧密地交织在一起的。从本质上讲，密码学被视为推进安那其主义原则的工具。安那其主义反对一切形式的权威并呼吁废除机构，在密码技术中找到了天然的盟友。</p><p>在某些方面，现代密码学实践继续挑战着机构权威。然而，这里存在一个悖论：虽然密码学旨在抵制中心化控制，但其开发和实现往往都是由专家决定的，并由大型科技公司和机构资助。这在安那其主义的去中心化理想与强大实体驱动的密码学创新现实之间造成了一种张力。为了真正尊重密码朋克和安那其主义的愿景，必须找到开发和部署密码学工具的方法，使得这些工具可以赋予个体权力，同时抵制任何形式的权力整合。</p><p>我们的社区还存在一个关于知识中心化的讽刺悖论。深受喜爱的 IACR（国际密码学研究协会）的政策和座右铭之一是在全世界传播知识。原始而纯粹的想法是很棒；然而，在过程中的某个地方，这个理念变质了。考虑非营利组织的目的。这里强调 “<strong>非营利</strong>”一词。然而，在每次 IACR 会议上，最先展示的一张幻灯片都是“我们拥有稳健的财务状况”。有趣的是，对于一个想要透明度的协会来说，除了参加会议之外，很难找到有关其“财务”的数据。此外，每年我们看到会议注册费和基金金额都在增加，而最初分享知识的目标似乎更加遥远了，或者只是一个乌托邦。</p><p>直说吧，我们就是利用早期的安那其主义、知名教授和构造密码学的有趣时光，在学术努力的幌子下简单地构建了一个蒙面的公司。这种背离密码朋克和安那其主义愿景基本原则的转变表明，有必要回归到密码学发展的源头——确保它仍然是赋予个体权力并保护隐私免受各种形式的中心化和控制的工具。</p><p>在本文中，我们的目标是提出一种密码学的全面的社会观点以及多年来使密码学进步成为可能的实体。我们将探讨密码学的道德伦理责任、密码学所影响的社会运动的起源以及当前密码学的发展轨迹。一个重点将是追溯密码学的历史重要性以及它是如何塑造我们社会的各个方面的。通过研究这些要素，我们希望能够更深入地了解密码学在现代世界中的多方面作用。</p><h2 id="密码学的历史背景及其影响"><a href="#密码学的历史背景及其影响" class="headerlink" title="密码学的历史背景及其影响"></a>密码学的历史背景及其影响</h2><p>最初，密码学被定义为数学和计算机科学的一个分支，专注于开发加密和解密通信的技术。然而今天，密码学的范畴已然显著扩大。虽然现代密码学仍然植根于数学，但它也涉及计算机科学、电子工程、物理学和其他几个学科。因此，<strong>现代密码学</strong>更全面的定义是：“密码学是致力于数字安全研究的多学科领域，旨在提供确保通信安全的工具。”</p><p>密码学的发展受到其在战时通信中的使用及其向数字安全应用的演变的深刻影响。一些重要的历史里程碑包括：</p><ul><li><p><strong>第二次世界大战和 Enigma 机</strong>：密码学在军事通信中的使用以及盟军的破解凸显了密码学工作的双重性质，既是安全工具，也是敌手的目标。</p></li><li><p><strong>公钥密码学的出现</strong>：20 世纪 70 年代公钥密码系统的引入彻底改变了安全通信，为现代密码学的实践奠定了基础。</p></li><li><p><strong>Shor算法和素数因式分解</strong>：发展能够破解已在全球部署的现代公钥密码学的量子算法。</p></li></ul><p>密码学在第二次世界大战期间取得了重大进展，这段时期的密码学和密码分析活动非常活跃。这一时期密码分析的成功彰显了严格分析的重要性以及加密方法中存在漏洞的可能性。</p><p>随着计算机行业的发展以及私有部门对安全硬件和软件需求的增长，对加密技术（最初被归类为战争设备）的国内使用和出口的限制性法规已经过时。持续的技术进步需要最先进的安全措施[6]。对数据收集和过时的法规的不信任，一起导致了对加密技术的倡导，这既成为一个市场的必需品，又成为了一种对日益增长的监控系统的抵制形式。</p><p>20 世纪 90 年代中期，随着 Shor 算法的发展，密码学领域取得了重大科学突破。这种量子算法高效地解决了整数分解和离散对数等问题，这些问题构成了 RSA 和 ECC 等许多经典密码系统的基础。Shor 算法的出现刺激了后量子密码学的发展，其目标是构造能够抵御量子攻击的密码算法。这已成为一个重要的研究领域，因为未来量子计算机的潜在实现可能会破坏当前密码系统的安全性。确保向抗量子加密方法的过渡对于维持后量子时代数字通信的完整性和安全性至关重要。</p><p>NIST（美国国家标准及技术研究所）和 ISO（国际标准化组织）等标准化机构在密码学标准的开发和采用方面发挥了至关重要的作用，确保了不同系统和应用之间的互操作性和安全性。这些标准提供了安全实现密码学算法和协议的指南，这对于保护各个领域的敏感信息至关重要。</p><p>密码学现在是区块链、数字货币、安全聊天应用和物联网 (IoT) 等现代技术的基础。例如，区块链技术依赖密码学哈希和数字签名来确保交易的完整性和真实性。同样的，Signal 和 WhatsApp 等聊天应用中的端到端加密可确保只有目标收件人才能阅读消息。</p><p>该领域还必须不断发展以应对各种密码攻击，包括侧信道攻击、暴力枚举攻击和复杂的密码分析技术。研究者也不断开发新的防御技术和密码原语，以增强数字系统的安全性并防范这些不断演变的威胁。</p><p>展望未来，密码学研究的新兴趋势包括同态加密的进步，其允许在不解密的情况下对加密数据进行计算；零知识证明，可以验证一个陈述而不泄露除了该陈述为真之外的任何信息；量子密钥分发，利用量子力学原理安全地分发密码学密钥。</p><h3 id="密码朋克宣言：一个政治宣言"><a href="#密码朋克宣言：一个政治宣言" class="headerlink" title="密码朋克宣言：一个政治宣言"></a>密码朋克宣言：一个政治宣言</h3><p>在《密码朋克：数字时代的隐私与安全》一书中[3]， Anderson 从新的哲学角度解决了有关密码朋克运动的道德伦理和宣言的几个问题。这本书相对较新，且对密码朋克运动的道德伦理采用了现代方法。</p><blockquote><p>“然而，密码朋克哲学不仅涉及安全和隐私的政治。从根本上说，密码朋克的世界观从根本上来说是规范性的，意即其建立在关于人和机构 <em>应该做什么</em> 以及社会 <em>应该是什么样</em> 的主张之上。” [3]</p></blockquote><p>这段引文使我们能够将其与安那其主义运动联系起来，甚至推断密码朋克哲学可以被视为一种安那其主义的数字迭代。可以与巴枯宁的早期作品进行类比，其中呼应了类似的社会规范主张：</p><blockquote><p>“我们坚信，没有社会主义的自由就是特权和不公正，没有自由的社会主义就是奴役和野蛮。” [4]</p></blockquote><p>这两段话都强调了社会应该如何构建以及平衡自由与正义的重要性的基本信念。Anderson的密码朋克哲学强调数字隐私和安全，而巴枯宁的安那其主义则强调社会自由和平等的必要性。它们共同反映了指导社会理想的规范原则的共同愿景。这给密码朋克运动提出了一个自然的问题：“这就是数字社会的指南吗？”</p><p>如前所述，我们必须认识到“现实”世界和“数字”世界之间的区别正变得越来越模糊。因此，另一个相关问题是：“我们是否应该更新对密码学构造的看法以反映这种统一的现实？”</p><p>《密码朋克宣言》认为密码学是数字时代保护隐私和促进个人自由的基本工具。宣言的主要原则包括：</p><ul><li><strong>隐私作为一项基本权利</strong>：主张隐私对于自由社会至关重要，个人必须有办法保护其个人信息。这种隐私权被视为其他公民自由的基石，强调没有隐私，其他自由就会受到严重损害。</li><li><strong>去中心化和个体赋权</strong>：强调去中心化系统和通过高强度密码学为个体赋权的重要性。去中心化对于防止中心化实体滥用权力至关重要，从而产生更具弹性和公平的数字生态系统。</li><li><strong>行动主义和实际应用</strong>：鼓励行动主义者开发和部署密码学工具，以对抗政府和企业的监视。这种行动主义植根于这样一种信念，即实用的技术解决方案对于维护数字时代的自由是必要的，而在数字时代，仅靠立法措施可能是不够的。</li></ul><p>在数字现实和物理现实交织在一起的现代世界，《密码朋克宣言》的原则比以往任何时候都更加重要。密码学不仅仅是一种保护信息的工具，而且是确保个人主权和抵抗压迫结构的基本要素。随着技术的不断发展，宣言对隐私、去中心化和积极行动主义的呼吁为建立公平公正的数字社会提供了一种关键的框架。</p><h3 id="密码学家的道德责任"><a href="#密码学家的道德责任" class="headerlink" title="密码学家的道德责任"></a>密码学家的道德责任</h3><p>Phillip Rogaway 在他的论文《密码学工作的道德特征》[10] 中认为，密码学研究不是价值中立的，密码学家道德上有责任考虑其工作的社会和政治影响。他提出了几个要点：</p><ul><li><strong>道德责任</strong>：密码学家应该认识到他们的道德责任以及他们的工作对社会产生的影响。</li><li><strong>历史背景</strong>：密码学的发展与政府和军事利益密切相关，特别是在监视和情报收集方面。</li><li><strong>监视和控制</strong>：现代密码学工作通常间接支持监视和控制系统，这可能与隐私和公民自由的价值观相冲突。</li><li><strong>公共物品</strong>：密码学家应该致力于为公共物品做出贡献，开发保护个人隐私和抵制独裁主义的技术。</li><li><strong>政治参与</strong>：Rogaway 鼓励密码学家参与政治并考虑其研究更广泛的社会影响。</li></ul><p>Rogaway主张密码学进行一次范式转变，倡导研究者采取更具社会意识的方法。这不仅需要关注技术方面，还需要积极参与有关其工作的道德和政治层面的讨论。</p><p>尽管 Rogaway 的文章颇具影响力，但密码学学术中的道德挑战几乎没有改变。其中包括国际密码学研究协会（IACR），该协会仍然缺乏正式的道德指导准则。</p><p>密码学本质上是多学科的——但无论其是植根于数学、计算机科学还是工程学， 都引发了人们对其道德基础的质疑。Karst 和 Slegers [8] 强调了提供密码学教育的各部门之间道德的多元融合，强调了共有的道德标准的必要性。</p><p>相比之下，一些部门比其他部门表现出更明确的道德框架。例如，计算机协会 (ACM) 维护了详细的道德和职业行为准则，包括有关诚实、隐私和社会贡献的准则 [1]。而美国数学会 (AMS) 和美国数学协会 (MAA) 则提供了关于道德行为的更普遍的指引 [2,9]。事实上，我们可以说，职业准则只是简单地（而且非常模糊地）触及了与道德相关的问题：</p><blockquote><p>“MAA 要求董事、管理人员、会员、受 MAA 报酬的人员和贡献时间的人员以及所有员工在履行职责和责任时遵守高标准的商业和个人道德。” [9]</p></blockquote><blockquote><p>“当数学工作可能影响公众健康、安全或公共福利时，数学家有责任在必要时向雇主和公众披露其工作的影响。” [2]</p></blockquote><p>值得注意的是，工业与应用数学学会 (SIAM) 缺乏正式的道德规范。另一个重要的密码学机构 IACR 尽管专注于密码学，但同样缺乏全面的道德声明。鉴于密码学与政治和社会问题的深刻交集，这一差距令人震惊。</p><h4 id="伦理道德的哲学讨论"><a href="#伦理道德的哲学讨论" class="headerlink" title="伦理道德的哲学讨论"></a>伦理道德的哲学讨论</h4><p>由于其哲学本质和文献中的不同解释，我们难以定义何为伦理学。伦理学涉及道德、价值观、行为的正确与错误以及指导个人或集体行为的原则等问题。它研究什么构成了好的行为和坏的行为，个人在各种情况下应该如何行动，以及道德判断背后的原因[11]。</p><p>作为一个植根于数学和计算机科学的社区，密码学社区重视定义的精确性和严格的推理。然而，道德推理提供了一条通向更形式化定义的途径。它包括构造由合理论据和结论支持的论点，旨在实现准确性和逻辑连贯性。</p><blockquote><p>“我们的道德思维应该有两个相辅相成的目标：正确行事，以及能够用完美的推理来支持我们的观点。我们想要真相，无论是我们对问题提出的最初假设还是最终得出的结论。但我们也想确保我们的观点得到充分的理由的支持。这为良好的道德推理提供了两个判据：第一，我们必须避免错误的信念，第二，我们的道德思维逻辑必须严密、无错误。” [11，第1章第10页]</p></blockquote><p>关于密码学工作道德的争论围绕在增进技术能力和解决此类进步的道德后果之间的平衡。密码学家必须应对复杂的道德领域，他们的工作既可以保护个人隐私，又可以实现监控。密码工作的道德特征需要一种反思性的方法，考虑密码工具和技术是如何影响社会规范和价值观的。这场辩论不仅是学术性的，而且具有现实世界的影响，影响政策决策并会塑造数字时代隐私和安全的未来。解决这些道德问题需要技术专家、伦理学家、政策制定者和公众之间持续对话，以确保密码学的进步与更广泛的社会利益相一致。</p><p>换句话说，该领域缺乏行为准则和道德规范可能会损害其未来的发展，特别是当它吸引了更多来自不同背景和年龄的科学家时。我们不能假设每个人都会内在地遵守该领域的道德准则。然而，建立明确的道德准则可以确保学术协会的声明更加准确和一致，使其章程与更广泛的科学诚信和道德原则保持一致。</p><h3 id="密码学、安那其主义和未来"><a href="#密码学、安那其主义和未来" class="headerlink" title="密码学、安那其主义和未来"></a>密码学、安那其主义和未来</h3><p>正如第三节提到的，密码朋克宣言和安那其主义表现出显著的相似之处。密码学和安那其主义之间的关系<em>植根于它们对隐私、个人自由和对抵制中心化控制的共同重视</em>。关键的交叉点包括：</p><ul><li><strong>隐私和个人自治</strong>：安那其主义者主张个人自治和个人隐私，反对国家或其他中心化权威机构进行任何形式的控制或监视。密码学技术使个人能够在数字时代维护自己的隐私和自主权。</li><li><strong>抵制中心化控制</strong>：安那其主义反对中心化控制和等级结构，主张去中心化和自愿结社。密码学通过在不依赖中心化机构的情况下实现安全的点对点通信和交易来支持去中心化系统。</li><li><strong>赋予个体权力</strong>：安那其主义者旨在通过拆除压迫性制度并实现自治和互助来赋予个体权力。密码学工具使个体能够保护自己的数据和通信，使其能够控制自己的数字存在和交互。</li><li><strong>匿名和假名</strong>：匿名可以是安那其主义者保护自己免受国家镇压并组织起来而不用担心报复的一种策略。 Tor 和匿名密码货币等密码技术提供匿名性和假名性，允许个体在不泄露身份的情况下进行操作。</li><li><strong>哲学基础</strong>：安那其主义的哲学基础包括对个体自由、非强迫和对权威的怀疑的坚定信念。密码朋克运动倡导使用密码学来实现隐私和安全，具有相似的哲学价值观。</li><li><strong>历史背景</strong>：纵观历史，安那其主义者经常使用秘密通信方法来避免被发现和镇压。现代密码技术的发展部分是出于保护个体和群体免受专制政权侵害的愿望。</li></ul><p>从这些关键点来看，密码学显然是实现各种安那其主义目标的关键工具。密码学方法是为了满足安那其主义框架内的特定需求而定制的，例如确保安全的通信信道、保护活动人士的身份以及促进去中心化协作。通过实现私密且安全的交互，密码学可以帮助安那其主义者抵御监控并维护操作安全。这种技术赋能使得安那其主义原则的实际应用成为可能，营造一种环境，使去中心化和志愿的协会能够在没有外部干扰的情况下蓬勃发展。</p><p>然而，近年来，曾经支撑密码货币发展的价值观似乎已经被对经济利益的关注所掩盖。密码货币的兴起虽然最初符合去中心化和财务自治的理想，但现在已经日益受到投机利益和盈利动机的主导。这种向货币化的转变可能会损坏密码学的道德基础，转移走人们对其保护隐私和赋予个体权力的潜力的注意力。社区必须记住密码朋克所阐述的原始价值观，并努力平衡创新与道德考量，确保对利润的追求不会掩盖对隐私和个体自由的承诺。</p><p>自引入 Diffie-Hellman 密钥交换协议以来，密码学发生了重大变化。最初，密码学是一个高度学术和科学的领域，专注于理论进步和知识追求。然而，随着时间的推移，它已经发展成为一个商业领域，公司利用密码技术来开发和销售产品。这种商业化已将焦点从学术探索转向市场驱动的解决方案，通常将利润置于最初指导该领域的道德和科学价值观之上。对于密码学界来说，恢复其学术根源并重申其对科学严谨性和道德责任的承诺至关重要。我们需要重新关注密码学的几个关键学术方面。虽然标准化流程和安全实现很重要，但它们是否应该消耗我们所有的注意力？探索新的攻击和开发替代密码方案就不应有未来吗？</p><p>密码学和安那其主义的交叉揭示了它们在隐私、个体自由和抵制中心化控制等核心价值观方面的深刻一致性。通过详细探索这些联系，我们可以更好地理解密码技术在推进这些原则和解决出现的道德挑战方面的作用。技术专家、伦理学家和活动家之间的持续对话与合作对于确保密码学进步有助于建立更自由、更公正的社会至关重要。</p><p>另一个关键点是我们领域内学术焦点与“非营利”概念之间的距离越来越大。我们的首要目标不应该是知识的进步吗？我们什么时候失去了焦点并让大型科技公司主导了我们的会议？例如，一个没有大量资金的学生如何负担得起在苏黎世这样的城市参加会议，注册费约为 450 欧元，再加上酒店和旅行费用？虽然津贴提供了部分解决方案，但选择更便宜的地点以允许更广泛的参与不是更好吗？我们什么时候变得如此精英主义以至于无法在不太知名但更经济的城市举办会议？这种向高成本场所的转变限制了可访问性和包容性，这与学术和科学探索的基本价值观背道而驰。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li>ACM. Acm code of ethics and professional conduct.</li><li>American Mathematical Society (AMS). Ethical guidelines of the american mathematical society.<br><a href="http://www.ams.org/about-us/governance/policy-statements/sec-ethics">http://www.ams.org/about-us/governance/policy-statements/sec-ethics</a>, 2024. [Online; accessed 10May-2024].</li><li>Patrick D Anderson. Cypherpunk ethics: Radical ethics for the digital age. Routledge, 2022.</li><li>Mikhail Bakunin. Federalism, socialism, anti-theologism. Bakunin on Anarchy: Selected Works by the<br>Activist-Founder of World Anarchism, pages 102–147, 1867.</li><li>David Chaum. Security without identification: Transaction systems to make big brother obsolete.<br>Communications of the ACM, 28(10):1030–1044, 1985.</li><li>Whitfield Diffie and Susan Landau. Privacy on the Line: The Politics of Wiretapping and Encryption.<br>MIT Press, 2001.</li><li>Eric Hughes. A cypherpunk’s manifesto, 1993.</li><li>Nathaniel Karst and Rosa Slegers. Cryptography in context: co-teaching ethics and mathematics.<br>PRIMUS, 29(9):1039–1059, 2019.</li><li>Mathematical Association of America (MAA). Welcoming environment, code of ethics, and whistleblower policy. <a href="http://www.maa.org/about-maa/policies-and-procedures/welcoming-environment-codeof-ethics-and-whistleblower-policy">http://www.maa.org/about-maa/policies-and-procedures/welcoming-environment-codeof-ethics-and-whistleblower-policy</a>, 2024. [Online; accessed 10-May-2024].</li><li>Phillip Rogaway. The moral character of cryptographic work, 2015.</li><li>Russ Shafer-Landau. The fundamentals of ethics. Oxford University Press, 4 edition, 2018.</li></ol>]]></content>
    
    
    <summary type="html">探讨了密码学工作和道德责任与政治行动主义的交叉点</summary>
    
    
    
    <category term="密码朋克" scheme="https://www.btcstudy.org/categories/%E5%AF%86%E7%A0%81%E6%9C%8B%E5%85%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Nostr Wallet Connect：一种比特币应用协作层</title>
    <link href="https://www.btcstudy.org/2024/06/21/nostr-wallet-connect-a-bitcoin-application-collaboration-layer/"/>
    <id>https://www.btcstudy.org/2024/06/21/nostr-wallet-connect-a-bitcoin-application-collaboration-layer/</id>
    <published>2024-06-21T03:59:36.000Z</published>
    <updated>2024-09-02T04:30:25.037Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：SHINOBI</em></p><p><em>来源：<a href="https://bitcoinmagazine.com/technical/nostr-wallet-connect-a-bitcoin-application-collaboration-layer">https://bitcoinmagazine.com/technical/nostr-wallet-connect-a-bitcoin-application-collaboration-layer</a></em></p></blockquote><p>走向比特币普及和开发的未来，有一个软件交互的问题正在成为开发人员必须面对的首要掣肘因素：兼容性。随着行业里的应用和协议变得更加复杂、特性更加丰富，为了满足真实用户和应用场景的需要，这成了一个根本上只有两种答案的困局：要么，一个应用（或者说钱包软件）必须在内部集成所有的协议，并实现为满足这个目的而必须具备的特性；要么，不同的应用必须能彼此沟通。</p><p>暴露出这个问题的一个例子是将闪电钱包集成到不同的应用和软件工具中。但闪电网络是一套实现起来非常复杂的协议栈，它涉及许许多多子协议，都跟如何协调和处理闪电通道的状态更新有关。这涉及用来表达各通道的状态的交易结构、它要强制执行的东西、制作和签名新交易（以保证用户资金安全性）的有序步骤，还有观察区块链以自动化正确应对对手发布过时状态到区块链的功能。</p><p>对于一个应用开发者来说，要自己直接集成闪电节点实现到自己的项目中，是非常复杂的事情。显而易见的结论是，如果依赖已经生产出来的软件来处理实现闪电支付的问题很花力气，那就应该直接开发你的应用、让它能跟外部软件通信。但这又带来了下一个问题：要是你的应用的用户并不是使用你选择的那种闪电节点实现（钱包）的话，那又该怎么办呢？</p><p>即使可以外包一个应用的功能，开发团队依然无法完全解决这个复杂性问题。虽然他们不需要自己一手一脚实现闪电节点，但选择这条路线的开发者就要为用户可能使用的任何闪电钱包处理合适的 API 支持。这就需要追踪多种闪电钱包的所有更新和变动，从 API，到影响钱包工作的内部特性，以及额外受支持的特性。停止追踪，就会打破（那种钱包的）用户的使用。</p><p>需要一些标准化的机制来弥合软件们之间的鸿沟，使得只需实现一个东西就能让所有这些不同的工具沟通。这将让每一种应用的定法这、每一种闪电钱包的开发者，都可以直接集成并维护一套协议，就能让应用之间彼此沟通。</p><p>Nostr Wallet Connect 就是在这个方面做出尝试的一套协议，它想成为满足这个需要的一套真正通用的机制。在尝试在 Nostr 客户端中嵌入闪电支付功能时，所有这些复杂性都来源于嵌入的方式。</p><h2 id="闪电网络与-NWC"><a href="#闪电网络与-NWC" class="headerlink" title="闪电网络与 NWC"></a>闪电网络与 NWC</h2><p>Amethyst（一种 Nostr 客户端）和 Alby（一种网页版闪电钱包）背后的团队创造了 NWC 协议以解决 Nostr 用户希望在 Nostr 使用体验中集成闪电支付就需要使用专用钱包的问题。这套协议基于 Nostr 的身份架构：每一条通过 Nostr 协议发送的消息（在 Nostr 协议中称为 “event”）都由一个用作身份的密钥对签过名。这让应用可以直接生成一个 Nostr 密钥对，然后仅凭这一点实现一种密码学身份校验机制，从而跟外部的比特币钱包通信，以满足应用的需要。</p><p><img src="/../images/nostr-wallet-connect-a-bitcoin-application-collaboration-layer/image1.png" alt="image1"></p><p>使用这个密钥对在闪电钱包中登记外部应用，这个应用就可以通过你的钱包来发起一笔支付。当前的 NWC 规范支持支付 BOLT11 发票、keysend 支付（根据闪电节点的公钥发起的无发票支付）、同时支付多个发票、生成一个发票给要给你支付的人，以及允许应用查询支付历史和钱包余额的少量其它功能。</p><p>所有这些都是通过 Nostr 来协调的，这就允许使用多种多样的通信路径，不必依赖于单种即时通讯机制，也不需要依赖于复杂的软件（例如 Tor）或其它用于协调应用与（运行在用户家庭网络中的）钱包软件的网络连接新的协议。Nostr 也支持加密的直接通信，意味着钱包和应用之间的通信是完全私密的，不会向负责通信的 Nostr relay 泄露通关于支付的细节。</p><p>在 NWC 桥梁的钱包这边，可以实现安全限制，以在用于通信的 Nostr 密钥被泄露的时候阻止应用无拘无束地花费资金。 钱包端可以配置允许花费的数额、支付的频率。</p><p>NWC 的用法还不止于在 Nostr 应用中集成闪电支付。作为一套协议，Nostr 自身的设计哲学以简单为核心，简单到任何开发者只需少量时间和参考就可以正确实现整套协议。与 Nostr 无关的应用也容易集成 NWC 或类似的协议，几乎没有额外的运行开销和复杂性，就可以解决让自己的应用连接比特币的底层问题，而无需在应用中直接开发。</p><h2 id="闪电网络之外"><a href="#闪电网络之外" class="headerlink" title="闪电网络之外"></a>闪电网络之外</h2><p>NWC 这样的协议，还有望为钱包和应用开发者提供巨大的价值，远不止集成闪电钱包到自己的应用中而已。除了一些已经萌发根本性突破的头脑，很少有人意识到，与比特币钱包交互的长期方向，是协助多个用户用户之间的交互式协议。</p><p>多方的 coinpool 就是一个最好的例子。大部分的设计提议，比如 Ark 和 “超时树”，都围绕着一个中心化的协调方，也可以叫服务商，服务商可以容易地指定用户钱包之间传递消息的工具，但这就让设计空间受限于这个单点故障。假设 100 名用户参加一个 coinpool，他们的资金都放在一个 UTXO 中，而它的安全模式是，每个用户都有一个预签名的路径，可以单方面在链上取出自己的资金。在出现故障或者服务商消失的时候，可以使用这种机制来保证资金不丢失，但这从根本上来说，这是一种能够应对故障，但低效的方法。</p><p>如果用户可以找出一种让彼此可以通信的机制，那就可以使用高效得多的合作退出操作：他们可以使用大群组的多签名来转移资金，这样占用的链上空间会更少（因此会更加便宜）。NWC 和 Nostr 是绝佳的工具。</p><p>多方之间的合作式多签名钱包也可以受益于这样的协议。结合 PSBT 这样的标准，简单的 Nostr 通信机制就可以极大地简化支持多签名特性的不同钱包协作签名交易的复杂性，让签名过程变得平滑，而且对用户友好。</p><p>谨慎日志合约（DLC）是这样的协议的另一个神奇应用场景。DLC 的整套机制都依赖于，参与合约的双方都能获得断言机的签名，从而能够单方面地正确关闭合约，即使对方不愿意合作，也不影响最终的结果。Nostr 也是断言机发布签名的完美机制。并且用户的钱包只需订阅断言机的公钥，就可以自动地跟踪和获得广播出来的签名。</p><p>以后，会有越来越多需要用户间交互、应用间交互的应用和协议建立在比特币上，没有单点故障的通用通信机制是绝对必要的。</p><p>Nostr 的惊人简洁性，以及可以利用大量 relay 的冗余性，使之成为了协助这些交互的绝佳顶层机制。NWC 就是它成为一个可用解决方案的最好例子。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">不同的比特币软件和应用需要一种简单的协作机制</summary>
    
    
    
    
    <category term="Nostr" scheme="https://www.btcstudy.org/tags/Nostr/"/>
    
  </entry>
  
  <entry>
    <title>Cashu：一种以比特币为储备的 ecash 生态系统</title>
    <link href="https://www.btcstudy.org/2024/06/19/cashu-a-vision-for-a-bitcoin-powered-ecash-ecosystem/"/>
    <id>https://www.btcstudy.org/2024/06/19/cashu-a-vision-for-a-bitcoin-powered-ecash-ecosystem/</id>
    <published>2024-06-19T10:04:56.000Z</published>
    <updated>2024-09-02T04:30:25.017Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：SHINOBI</em></p><p><em>来源：<a href="https://bitcoinmagazine.com/technical/cashu-a-vision-for-a-bitcoin-powered-ecash-ecosystem">https://bitcoinmagazine.com/technical/cashu-a-vision-for-a-bitcoin-powered-ecash-ecosystem</a></em></p></blockquote><p>最近，ecash 正渐渐成为一个无法回避的话题。在新出现的几乎每一个提议都饱受争议的大背景下，ecash 作为一个今天就可以利用起来、无需替换和变更比特币协议的方案，显得特立独行。</p><p>在现在这个气候下，不必改变比特币就能部署应用，是非常有价值的事。所以，毫不意外，Cashu ecash 协议迅速在边缘地带站稳脚跟。Nostr 这样的平台上也开始有应用采纳它；而且，铸币厂之间通过闪电网络来结算的特性，也让 Cashu 钱包成了对 Wallet of Satoshi 这样的易用型闪电钱包的可用替代品。</p><p>Ecash 很可能会成为比特币生态系统的一个日益热门的部分，而（尤其是）Cashu，在鼓励多种兼容性实现上已经做得非常成功了。</p><p>Cashu 的开发者们，对于围绕这套协议去开发一个生态系统、解决 ecash 的一些根本性的信任模式问题、以及多种使用场景的具体需要，有一套全面的计划。我们就来看看这种愿景。</p><h2 id="盲化的-Token"><a href="#盲化的-Token" class="headerlink" title="盲化的 Token"></a>盲化的 Token</h2><p>所有 ecash 协议的核心都是盲签名方案。正是这种机制，让一个中心化的实体可以处理 ecash 支付而不牺牲用户的隐私。</p><p>在一开始，用户铸造一个 token 时，必须生成一个随机数。这个随机数就是一个真实的 ecash token。自己生成这个随机数，就保证了这个 token 是安全地保管在自己手里的，而不是保管在别人手里的。但这还不够，因为每个人都能生成随机数。一个 ecash 铸币厂需要用签名来给这个 token 作公证。</p><p>问题在于，要是铸币厂在签名的时候就看到了这个 token，那么他们就将能够知晓自己是给谁签名了 token，并且也可以在有人赎回这个 token 的时候，知道谁在给谁支付。为了解决这个问题，用户需要生成第二个随机数，称为 “盲化因子”。本质上，盲化因子就是将 token 乘以一个用于盲化的数值。</p><p>然后，用户将这个盲化之后的数交给铸币厂，由后者签名（公证）。这时候你肯定要问了，铸币厂签名的是这个盲化之后的 token，而不是明文的 token，那这个签名是对明文的 token 有效的吗？答案是肯定的。因为盲化协议和底层的密码学，你可以作跟盲化 token 相反的操作，来解除签名的盲化。</p><p>最后，你得到是对明文的 token 有效的签名，而且能够保证，有人要拿着它跟铸币厂赎回比特币的时候，铸币厂不会知道自己是在什么时候、为谁签名了它，也不知道自己到底签了什么。这就是 ecash 的原理（你学会了吗？）。</p><p>（译者注：考虑到 Cashu 铸币厂是存在于闪电网络上的，可以将这里的 “铸造” 理解成 “铸币厂接受用户的闪电支付&#x2F; token 支付，放出同等价值的 token”，而 “赎回&#x2F;兑付” 则是 “用户使用 token，要求铸币厂发起闪电支付”。）</p><h2 id="小型的个人铸币厂"><a href="#小型的个人铸币厂" class="headerlink" title="小型的个人铸币厂"></a>小型的个人铸币厂</h2><p>Cashu 的目标是成为一套有有倾向性的轻量协议，要易于实现、易于集成，并且易于在上面开发。Cashu 的愿景是让许许多多非常小的个人铸币厂全部通过闪电网络连接在一起，共同形成一个生态系统。因此，开发者们不那么关注具有网络效应、让用户可以彼此直接转移 token 的大铸币厂（这会让大量的比特币汇集到少数几个被信任的人手上），更关注小体量的个人运营者。</p><p>这让用户可以将信任放置在自己有朋友关系的人身上，从而每个用户都依赖于更接近自身社交圈子的运营者。闪电网络让这一切成为可能，因为你不需要说服每个人都接受来自你的铸币厂的 token，他们可以接受来自自己的铸币厂的 token，而且每个人都能赎回。</p><p>这种策略是希望尊重 “邓巴数” 的现实：一个人可以产生有意义关联、愿意投注信任的人数是有上限的。</p><h2 id="通过-Nostr-发现铸币厂"><a href="#通过-Nostr-发现铸币厂" class="headerlink" title="通过 Nostr 发现铸币厂"></a>通过 Nostr 发现铸币厂</h2><p>为这种鼓励人们基于信任圈设立铸币厂的想法注入活力的是新型的 Nostr 发现协议，它是 Cashu 生态系统长久运行的一个重要部分。Nostr 建立在让用户的身份绑定在自主保管的密钥之上，这使得只有他们自己才能使用自己的身份 —— 广播属于这个身份的消息。</p><p>当前，Nostr 的主要应用场景是社交媒体，它跟基于公钥的身份方案的结合为密码学中一个非常古老的概念提供了强大的基础：新人网络。Cashu 正在利用这一点，帮助用户发现可以使用的铸币厂。</p><p>使用 Nostr 公钥，任何人都可以使用一款支持定位铸币厂的 Cashu 钱包，而且还可以看到人们知道、信任哪些铸币厂，还可以集成这些铸币厂。这可以形成一个声誉系统，让用户在选择 Cashu 铸币厂时作出更加明智的决定，而不是盲目猜测、祈祷铸币厂不要跑路。</p><p>随着时间推移，越多铸币厂出现，就将有越多拥有 Nostr 身份的人使用它们，这个带有声誉的信任网络就越强大。这也许能自然驱逐恶意的、不知名的铸币厂，并给用户一群值得信任的、诚实的铸币厂。</p><h2 id="使用多个铸币厂"><a href="#使用多个铸币厂" class="headerlink" title="使用多个铸币厂"></a>使用多个铸币厂</h2><p>鼓励多样的铸币厂的生态系统、允许用户自己选择的基本概念，是让市场发挥开放竞争功能的一个坚实基础。但还可以更进一步。一个用户可以使用多个铸币厂。</p><p>用户可以在多个铸币厂都存放资金，而且，利用多路径支付的变种，可以将来自不同铸币厂的资金聚合起来、在闪电网络上对单个目的地发起一笔支付。这让资金托管的对手方风险分散到了多个对手方身上，又无需牺牲向使用不同铸币厂的用户发送平滑支付的能力。</p><p>这是通过让铸币厂运行定制化的软件来实现的，这样的软件可以让一个铸币厂仅支付一个闪电发票的一部分、其它铸币厂支付其余的部分。只要每个铸币厂都成功路由支付到最终目标，支付就成功。</p><p>甚至可以进一步定制他们的闪电节点，从而允许用户 <em>收取</em> 一笔发给多个铸币厂的支付。如果铸币厂们支持用户的钱包通过生成原像来完成支付（而不是由铸币厂来完成），那么每个用来接收资金的铸币厂都可以发行自己的发票，让收款用户来控制什么时候释放原像。只要每个参与的铸币厂都收到了路由过来的 HTLC，那么用户就可以放出所有原像，并成功在多个铸币厂之间分散收到的资金。</p><p>这个方案可以显著降低因为某一个铸币厂而丢失资金的风险，再结合 Nostr 的发现协议以及相关的信任网络，可以大大提高用户的安全性。</p><h2 id="给货币编程"><a href="#给货币编程" class="headerlink" title="给货币编程"></a>给货币编程</h2><p>Cashu 最有用的特性之一是，你可以给一个 ecash token 编写脚本功能，就跟使用比特币脚本来编写程序、锁定比特币 UTXO 一摸一样。Cashu token 可以在盲化 token、交给铸币厂公证之前编码脚本条件，日后，当这些 token 要赎回的时候，铸币厂可以检查其中的脚本条件是否得到了满足，如不满足就拒绝兑付。</p><p>当前，Cashu 已经实现了一种公钥脚本锁，也就是被锁定的 token 需要提供来自某个公钥的签名才能赎回。这让铸造出来的 token 被锁定、只能被某个私钥的主人赎回。一旦带有这样的公钥锁的 token 被铸造出来，别人就没法拿它兑换成比特币。</p><p>这可以用来实现收款人离线时候的安全支付。即使没有互联网连接，他们也可以通过验证铸币厂的签名来，确保自己收到的资金是没有别人可以花费的。他们可以安全地接受这种支付，因为他们知道自己可以在方便的时候赎回它。</p><p>这会带来一些复杂性，因为发送者必须提前锁定 token 给某一个收款人，如果收款人在收款时没有互联网连接的话。考虑到人们的花费有随机性，这就产生了一个问题，他们可能会花出去许多钱，但在没有被收款人接收时，也无法追回。</p><p>但脚本可以添加更多功能：创建出来的 token 要求来自某个公钥的签名才能赎回，或者，在一段时间过后，任何人都可以赎回。这就类似于 HTLC。Cashu 的规范也定义了一种真正的 HTLC token 脚本。</p><p>随着时间推移、人们需要更多应用场景，人们可以用来锁定 Cashu token 的脚本可以基于用户和铸币厂的需要任意扩展。我预期，这会成为这套协议在未来的一个非常强大的方面。它可以支持保管服务、多签名 token 以及大量的巧妙智能合约。Cashu 铸币厂可以强制执行比特币可以支持的任何脚本条件，而且还可以支持更多。</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>人们在使用托管商，人们一直在使用托管商，而且可能还会继续使用托管商，无论非托管的解决方案提供了何等的灵活性。这只是一个生活的真相：有些人无力，或不愿意承担责任、处理自主保管的复杂性。</p><p>Cashu 致力于激进地提升用户可得的托管服务。它可以给用户带来隐私性、审查抗性以及灵活性，这些都是传统的托管服务无法提供的。</p><p>Cashu 项目的目标不是使用托管商 “扩容比特币”，而是提供一套优化过的、具备隐私性的托管服务。我认为，这是一个值得称赞的目标，有望在未来给这些用户带来巨大的好处。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">看看 Cashu 所驱动的 ecash 铸币厂生态的长期愿景</summary>
    
    
    
    
    <category term="Ecash" scheme="https://www.btcstudy.org/tags/Ecash/"/>
    
  </entry>
  
  <entry>
    <title>CLN 的插件架构</title>
    <link href="https://www.btcstudy.org/2024/06/18/cln-plugin-architecture-by-roygbiv/"/>
    <id>https://www.btcstudy.org/2024/06/18/cln-plugin-architecture-by-roygbiv/</id>
    <published>2024-06-18T03:12:11.000Z</published>
    <updated>2024-09-02T04:30:25.017Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：roygbiv</em></p><p><em>来源：<a href="https://www.roygbiv.guide/cln-plugin-architecture/">https://www.roygbiv.guide/cln-plugin-architecture/</a></em></p></blockquote><p>C-Lightning(CLN) 是一套软件，让你的电脑可以跟比特币的闪电网络通信 …… 它是一种闪电网络节点实现。CLN 的开发者制作了一种办法，让任何人都可以给自己的节点添加定制化的功能。提供定制化功能的软件就叫做 “插件”。</p><blockquote><p>我在这篇文章中要告诉你的东西，全部都是从 Tony Aldon 的鸿篇巨制 <a href="https://lnroom.live/">lnroom.live</a> 中学来的。</p></blockquote><h2 id="运行-CLN"><a href="#运行-CLN" class="headerlink" title="运行 CLN"></a>运行 CLN</h2><p>首先，你要安装 CLN 软件。我建议从源代码开始编译。但所有的安装方法和指令都可以在这里<a href="https://github.com/ElementsProject/lightning#installation">找到</a>。</p><blockquote><p><a href="https://www.roygbiv.guide/author/farscapian/">Farscapian</a> 已经用 ROYGBIV 软件让这一切都非常简单：这种 Docker 软件可以让你一键安装 Bitcoin Core 和 CLN。看看这份<a href="https://github.com/farscapian/roygbiv-stack#readme">说明书</a>吧。</p></blockquote><p>安装好了之后，你可以使用 <code>lightningd</code> 命令来启动节点。</p><blockquote><p>译者注：一份中文的安装指南可见<a href="https://www.btcstudy.org/2023/09/08/run-lightning-node-with-core-lightning-implement/">这篇文章</a>，其中的技巧适用于所有基于 Linux 的系统。</p></blockquote><h2 id="RPC-方法"><a href="#RPC-方法" class="headerlink" title="RPC 方法"></a>RPC 方法</h2><p>CLN 带有一个很棒的命令行工具，通过运行 <code>lighting-cli</code> 命令前缀就可以调用。使用它，你可以访问 CLN 暴露出的所有 JSON RPC 方法。</p><blockquote><p>JSON PRC 是一套协议，用于编码消息及协助客户端和服务端应用之间的通信。</p></blockquote><p>事情从这里开始就变得有意思了。你可以在 CLN 节点上可以使用的许多 RPC 方法都来自插件。你可以在<a href="https://github.com/ElementsProject/lightning/tree/master/plugins">这里</a>看到一份插件清单。还有一些由<a href="https://github.com/lightningd/plugins">社区开发的插件</a>，你可以用来给自己的节点添加功能。</p><p>举个例子，<code>keysend</code> 是一种方法，可以用来发送不定数量的资金到另一个节点，只需知晓那个节点的公钥就行。Keysend 就是一个插件，可以在这里<a href="https://github.com/ElementsProject/lightning/blob/master/plugins/keysend.c">看到</a>。</p><blockquote><p>要了解如何使用定制化的插件，请看我的文章《<a href="https://www.roygbiv.guide/cln-plugin-architecture/www.roygbiv.guide/starting-prism-plugin-on-your-node/">starting the prism plugin on your node</a>》。</p></blockquote><h2 id="插件如何工作"><a href="#插件如何工作" class="headerlink" title="插件如何工作"></a>插件如何工作</h2><p>“插件可以用任何语言来编写，然后通过插件的 <code>stdin</code> 和 <code>stdout</code> 来跟 <code>lightningd</code> 通信。” —— <a href="https://docs.corelightning.org/docs/a-day-in-the-life-of-a-plugin">CLN 说明书</a></p><h3 id="Manifest"><a href="#Manifest" class="headerlink" title="Manifest"></a>Manifest</h3><p>在启动一个插件之后，它就会通过 <code>getmanifest</code> 请求在 <code>lightingd</code> 中注册。这个请求会被发送给你的插件的标准输入端口（stdin），并预计会从该插件的标准输出端口（stdout）中收到一个回应。</p><p><code>getmanifest</code> 请求看起来是这样的：</p><pre><code class="json">&#123;  &quot;jsonrpc&quot;: &quot;2.0&quot;,  &quot;id&quot;: 86,  &quot;method&quot;: &quot;getmanifest&quot;,  &quot;params&quot;: &#123;    &quot;allow-deprecated-apis&quot;: false  &#125;&#125;</code></pre><p>而来自程序的回应是这样的：</p><pre><code class="json">&#123;    &quot;jsonrpc&quot;: &quot;2.0&quot;,    &quot;id&quot;: req_id,    &quot;result&quot;: &#123;        &quot;dynamic&quot;: True,        &quot;options&quot;: [&#123;            &quot;name&quot;: &quot;foo_opt&quot;,            &quot;type&quot;: &quot;string&quot;,            &quot;default&quot;: &quot;bar&quot;,            &quot;description&quot;: &quot;description&quot;        &#125;],        &quot;rpcmethods&quot;: [&#123;            &quot;name&quot;: &quot;myplugin&quot;,            &quot;usage&quot;: &quot;&quot;,            &quot;description&quot;: &quot;description&quot;        &#125;]    &#125;&#125;</code></pre><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在 <code>getmanifset</code> 之后，<code>lightningd</code> 会发送初始化请求。这个请求提供了关于本节点的重要信息，例如用来访问 RPC 方法的 <code>lightnign-dir</code>。</p><p>对 <code>init</code> 请求的预期回应是这样的：</p><pre><code class="json">&#123;    &quot;jsonrpc&quot;: &quot;2.0&quot;,    &quot;id&quot;: req_id,    &quot;result&quot;: &#123;&#125;&#125;</code></pre><blockquote><p>要了解开发插件的细节，请看 Tony Aldon 的视频及文章《<a href="https://lnroom.live/2023-03-28-live-0001-understand-cln-plugin-mechanism-with-a-python-example/">Understand CLN Plugin mechanism with a Python example</a>》。</p></blockquote><h3 id="输出及输出的通信"><a href="#输出及输出的通信" class="headerlink" title="输出及输出的通信"></a>输出及输出的通信</h3><p>插件在 <code>lightningd</code> 中注册完成后，输入-输出 的循环就开始了。无论什么时候，只要调用插件中定义的方法，<code>lightingd</code> 就会给插件的 stdin 发送请求，然后从插件的 stdout 获得回应。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>插件是 CLN 后台程序中的一个子进程。CLN 中的许多开箱即用的功能都被制作成了插件，但任何用户都可以自由增加插件。</p><p>这个插件架构让许多特性可以共存在 CLN 中。这也是为什么我们决定将 BOLT12 prisms（棱镜支付）实现为一个 CLN 插件。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">插件架构让许多特性可以共存在 CLN 中</summary>
    
    
    
    
    <category term="开发" scheme="https://www.btcstudy.org/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Ark v2 降临</title>
    <link href="https://www.btcstudy.org/2024/06/12/introducing-ark-v2/"/>
    <id>https://www.btcstudy.org/2024/06/12/introducing-ark-v2/</id>
    <published>2024-06-12T08:41:05.000Z</published>
    <updated>2024-09-02T04:30:25.029Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Burak</em></p><p><em>来源：<a href="https://brqgoo.medium.com/introducing-ark-v2-2e7ab378e87b">https://brqgoo.medium.com/introducing-ark-v2-2e7ab378e87b</a></em></p></blockquote><p><img src="/../images/introducing-ark-v2/1_j7YeVmDEcvzL8r1mkRdhoA.webp" alt="1_j7YeVmDEcvzL8r1mkRdhoA"></p><p>迄今为止，对 Ark 构造最主要的顾虑是流动性锁定问题。随着网络中交易量的增加，服务供应商必须锁定更多的流动性，这让 Ark 最终成为高容量但低流动性的网络。</p><p>在一个服务器上运行 Ark 已经在实质上解决了流动性顾虑。在服务器上，Ark 可以将 24 小时作为一个回合，也就是 ASP（Ark 服务供应商）可以每日循环自己的资金。光这一点就胜过了闪电通道，因为建立服务器之后，你就可以毫不费力地接受支付，而不需要开启通道。</p><p>虽然在服务器上运行 Ark 从流动性角度看已经非常高效了，Ark 背后的理念是消灭技术门槛、为所有人拓展比特币支付，并且要做到对用户友好。这就是 Ark v2 的由来了。</p><p>Ark v2 让 ASP 可以回收流动性而无需等待过期时间（4 周）。看起来是不是美好得不真实？</p><p>在当前的 Ark 架构中，用户共享的 UTXO 的 TapTree 结构是这样的：</p><p><img src="/../images/introducing-ark-v2/1_VjsuiBPNgbidvMTP8dsmsw.webp" alt="1_VjsuiBPNgbidvMTP8dsmsw"></p><p style="text-align:center">- Ark v1 中共享 UTXO 的 taproot 脚本树结构 -</p><p>这个脚本树有两个分支：一个是 ASP <strong>清扫资金</strong>分支，另一个是用户<strong>展开内部状态</strong>分支。</p><p>清扫分支可以由 ASP 在 4 周后动用，以高效地回收锁定的资金。</p><p>而展开分支则可以由任何用户在任意时间动用，将解除拥堵控制而让所有用户共享的 UTXO 的内部状态全部暴露。</p><p style="text-align:center">- - -</p><p>而在 Ark v2 设计中，新的 TapTree 结构是这样的：</p><p><img src="/../images/introducing-ark-v2/1_mroBYoQJW-US-_nLISeKfg.webp" alt="1_mroBYoQJW-US-_nLISeKfg"></p><p>出现了两个更高层级的分支：<strong>左顶层分支</strong>和<strong>右顶层分支</strong>。</p><p>清扫分支和展开分支都在左顶层分支内，并且：</p><ol><li>清扫分支保持原样；</li><li>展开分支不能再随时触发；相反，只有在资金创建的 2 周之后才能触发。</li></ol><p>此外，还增加了一个顶层分支。我们管这个分支叫 “右顶层分支”，或者直接叫 “<strong>撤销分支</strong>”。这个分支对应的是撤销可能性的多种组合。</p><p>有足够多的用户花费自己的 vTXO 时，ASP 就会进入撤销分支，高效地回收对应的流动性，而不必忍受任何时间限制。</p><p>（译者注：如前所述，在一个 Ark 构造控制的资金（UTXO）中可能存在多位用户，他们是共享（share）这个 UTXO 的。为了分析的便利，我们就使用 “vTXO（虚拟的交易输出）” 这个概念 —— 这些用户在这个共享 UTXO 中的资金可以概念化为 vTXO，他们都是 vTXO 的持有者。）</p><p><img src="/../images/introducing-ark-v2/1_2J2-D2jcceTOG-6xD3Xudg.webp" alt="1_2J2-D2jcceTOG-6xD3Xudg"></p><p style="text-align:center">- 撤销分支 -</p><p>Ark v2 引入了跟闪电通道类似的撤销机制。在闪电通道中，用户通过揭晓一个私钥来撤销自己的通道状态。类似地，在 Ark v2 中，用户在花费一个 vTXO 时就揭晓一个私钥。不过，有区别的地方在于，在这里，用于作废状态的私钥会被聚合，然后用到集中回收资金的时候。</p><p>每个 vTXO 的拥有者都持有一个单独的撤销私钥。当足够多 vTXO 持有者揭晓自己的私钥，ASP 就会聚合这些私钥：</p><p><strong>聚合撤销私钥</strong> &#x3D; <em>sec1 + sec2 + sec3 … + secn</em></p><p><strong>聚合撤销公钥</strong> &#x3D; <em>sec1⋅G + sec2⋅G + sec3⋅G … + secn⋅G</em></p><p>使用一个来自这个聚合私钥的有效签名，ASP 就可以获得<strong>撤销分支</strong>内对应叶子的访问权。</p><p>一个<strong>撤销分支</strong>可以压缩几百万甚至数十亿个叶子，每个叶子都代表一种<strong>聚合撤销公钥</strong>组合，也就对应着具体的一种撤销可能性。虽然构造这么大的树可能是计算密集的，但具体的一个叶子可以很容易解锁，只需一个检查签名的操作码（CHECKSIG）：</p><pre><code>&lt;aggregate_revocation_public&gt; OP_CHECKSIG</code></pre><p><strong>位于撤销分支中的叶子</strong>，也必须使用一种限制条款来限制花费交易的输出，将资金交给 ASP 以及一棵修剪后的树，也就是在把锁定资金交还给 ASP 的同时，将资金重新分发给剩余的 vTXO 持有者。</p><p><img src="/../images/introducing-ark-v2/1_v6BykHuCyyLwo6KKyEtHkg.webp" alt="1_v6BykHuCyyLwo6KKyEtHkg"></p><p>撤销分支的叶子中的最终脚本将是这样的：</p><pre><code>&lt;aggregate_revocation_key&gt; OP_CHECKSIGVERIFY &lt;asp_key&gt; OP_CHECKSIGVERIFY&lt;constrained_outputs_template&gt; OP_CHECKTEMPLATEVERIFY</code></pre><p style="text-align:center">- - -</p><p>一个包含 16 个 vTXO 的共享 UTXO 将包含一个带有总计 805 个叶子的撤销分支。ASP 可以容易地构造出这样的分支，要验证内容的客户端也容易重新构造出来。</p><p>如果一轮中注册的 vTXO 的数量超过 16 个，那么组合树就会加深，最终可能让撤销分支包含几百万、数十亿个叶子。幸运的是，一棵 MAST 可以拥有高达 <a href="https://bitcoin.stackexchange.com/questions/110243/maximum-number-of-possible-mast-leaves">340282366920938463463374607431768211456</a> 个叶子，而且其 control block 的链上踪迹（体积）是 log n 级增长的，并且还能从隔离见证的折扣中获得好处。</p><p>问题不在于链上足迹，而在于计算。为了构造这样大型的撤销分支，ASP 可能需要定制化的硬件，比如 VPU。</p><p>又因为客户端无法重新构造出这样大的撤销分支，他们必须使用一种由 ASP 提供的 VPU 所生成的零知识证据，来验证撤销分支的内容。</p><p><img src="/../images/introducing-ark-v2/1_SV0WK9ZtOlJmcvt7u_SSMw.webp" alt="1_SV0WK9ZtOlJmcvt7u_SSMw"></p><p style="text-align:center">- vTXO 的数量-运算量对照表 -</p><p>此外，ASP 可以将共享 UTXO 切成几份，每份包含 16 vTXO；每多一份，链上体积会增加 43 vByte。</p><p>总体来说，这个新的设计引入了重大的开销，但似乎是值得的。</p><p style="text-align:center">- - -</p><p>注意，撤销点的设计改变了 vTXO 的输出点索引，让基于 CHECKSIG 的连接器（connector）设计变得无用。相反，新设计必须使用内省能力以及基于 CSFS 的连接器。这意味着，vTXO 的持有者必须仅签名连接器的输出点索引，以除去自身，也就是从签名消息中清除自己的输出点上下文。</p><p style="text-align:center">- - -</p><p>格外感谢 <a href="https://twitter.com/thebluematt?lang=en">Matt Corallo</a> 启发我开发出这个撤销设计。</p><p>（完）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;作者：Burak&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;来源：&lt;a href=&quot;https://brqgoo.medium.com/introducing-ark-v2-2e7ab378e87b&quot;&gt;https://brqgoo.medium.co</summary>
      
    
    
    
    
    <category term="Ark" scheme="https://www.btcstudy.org/tags/Ark/"/>
    
  </entry>
  
  <entry>
    <title>什么是 “Pedersen 承诺”？</title>
    <link href="https://www.btcstudy.org/2024/06/07/what-are-pedersen-commitments-and-how-they-work/"/>
    <id>https://www.btcstudy.org/2024/06/07/what-are-pedersen-commitments-and-how-they-work/</id>
    <published>2024-06-07T03:14:14.000Z</published>
    <updated>2024-09-02T04:30:25.061Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：RareSkills</em></p><p><em>来源：<a href="https://www.rareskills.io/post/pedersen-commitment">https://www.rareskills.io/post/pedersen-commitment</a></em></p></blockquote><p>“Pedersen 承诺” 让我们可以使用一个椭圆曲线点来表示任意大的向量，同时可以选择隐藏关于这个向量的任何信息。它给了我们一个重要的元件，让我们可以证明用这个点来编码的向量，又不必暴露这个向量本身。</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在讨论 Bulletproot 零知识证明技术的时候，人们常常这样说：“我们有两个向量，它们的内积（inner product）是 c。” 似乎这很普通，但实际上，你可以用这个机制来证明非常复杂的陈述（claim）。我们后面展开说。</p><p>但为了让这样的证明系统可以工作，这些向量就不能只有证明者知道 —— 不然证明者就可以随意改变它们。它们必须是真实世界中的数学实体。一般来说，证明者肯定不想直接把这两个向量交给验证者，但依然需要 “传递一些东西” 给验证者，表示自己已经选定了一对向量，不能再改变了。</p><p>这就是我们需要 Pedersen 承诺的地方。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>我们假设读者已经熟悉了椭圆曲线点加法和点乘法，以及 “曲线上的一个点” 意味着什么。如果你还不了解，请参考我们的《<a href="https://www.rareskills.io/zk-book">零知识证明之书</a>》的前面四章。</p><p>至于记号，我们用 <code>[A]</code> 来表示一个椭圆曲线（EC）点，用 <code>a</code> 表示一个<a href="https://www.rareskills.io/post/rings-and-fields">有限域</a>内的元素，而 <code>a[A]</code> 表示这个有限域元素 <code>a</code> 与椭圆曲线点 <code>[A]</code> 的点乘法。而表达式 <code>[A] + [B]</code> 表示这两个点的<a href="https://www.rareskills.io/post/elliptic-curve-addition">点加法</a>。</p><h2 id="传统的承诺方案"><a href="#传统的承诺方案" class="headerlink" title="传统的承诺方案"></a>传统的承诺方案</h2><p>在设计智能合约中的承诺揭晓函数时，我们通常使用这样的形式：</p><pre><code>commit = hash(value, salt)</code></pre><p>其中的 “salt（盐）” 是一个随机数值，用来阻止攻击者的暴力搜索猜测。比如说，如果我们是在承诺投出的一票，由于票的可选项是有限的，那么我们的票到底投给了谁，就可以通过尝试所有的选项、检查哈希值匹配来发现。（而加了盐，这样的暴力搜索就行不通了。）</p><p>盐在这种场景中的用法，有一个学术名词，叫做 “<strong>盲化</strong>（blinding）因子”。因为它是随机的，攻击者就仿佛失明了，猜不出被承诺的数值（上面式子中的 “value”）到底是什么。</p><p>因为攻击者无法通过 “诺言” 猜测出其背后的数值，我们就说这种承诺方案<strong>有藏匿效果</strong>。</p><p>而揭晓数值的阶段，承诺者揭晓数值和盐（在文献中，它们叫做 “<strong>契机</strong>（opening）”），另一方（或者智能合约）可以验证它们跟原本的承诺相匹配。如果在同一承诺方案中不可能用另一对 <code>(value, salt)</code> 来获得相同的诺言，我们就说这种方案<strong>有绑定效果</strong> —— 承诺者一旦揭晓诺言，就不可能再改变被承诺的数值（也即两者就绑定了）。</p><h3 id="术语总结"><a href="#术语总结" class="headerlink" title="术语总结"></a>术语总结</h3><ul><li>有<strong>藏匿</strong>效果的承诺方案不允许敌手知晓承诺者选择的数值。这通常是通过加入一个攻击者无法猜测的随机数来实现的。</li><li><strong>盲化</strong>因子则是让被承诺的数值无法通过暴力搜索得出的随机数。在一些我们并不在乎零知识性（而只在乎简洁性）的场景中，可能不使用盲化因子。</li><li><strong>契机</strong>则是计算出诺言的数值（被承诺的数值和盐）。</li><li>有<strong>绑定</strong>效果的承诺方案不允许承诺者使用不相同的契机计算出相同的诺言。也就是说，他们不应能够找出两对 <code>(value, salt)</code>，计算得出相同的诺言（在这里是哈希值）。</li></ul><h2 id="Pedersen-承诺"><a href="#Pedersen-承诺" class="headerlink" title="Pedersen 承诺"></a>Pedersen 承诺</h2><p>Pedersen 承诺方案的模式没有什么不同，只不过，它用的是椭圆曲线群，而不是密码学哈希函数。</p><p>在 “椭圆曲线上离散对数难解” 假设下，给定椭圆曲线点 <code>[U]</code> 和 <code>[G]</code>，我们无法计算出能让 <code>[U] = u[G]</code> 的 <code>u</code> 。</p><p>用 Python 语言的代码来说，就是：</p><pre><code class="python">from py_ecc.bn128 import G1, multiplyu = 569723450 # chosen randomlyU = multiply(G1, u)print(U, &quot;cannot compute the discrete log of U&quot;)</code></pre><p>我们说，<code>u</code> 是 <code>[U]</code> 的离散对数。即使我们并不能计算出 <code>u</code>，也依然管它叫 <code>[U]</code> 的离散对数，因为我们知道它存在。所有的（密码学）椭圆曲线点都有一个离散对数，即使我们无法计算出它。</p><p>在这个意义上，椭圆曲线点乘法就像一种哈希函数。它们是有绑定效果的，只要我们只允许在曲线阶数内的契机。</p><p>不过，虽然它有绑定效果，我们无法通过点反转出其离散对数，如果 <code>u</code> 的取值范围很小，我们就会遇到（跟上述投票案例）完全一样的问题。敌手可以通过遍历所有可能的 <code>x</code>、计算 <code>x[G]</code> 来猜测我们的 <code>x</code> 。</p><p>我们可以用下列方式实现 “Pedersen 式隐匿”：</p><pre><code>commitment = v[G] + s[Q]</code></pre><p>这里的 <code>v</code> 就是我们要承诺的数值，而 <code>s</code> 是盐（盲化因子）；<code>Q</code> 是另一个椭圆曲线点，承诺者不知道其离散对数。</p><p>我们要强调的是，虽然它们的离散对数都是未知的，<code>[G]</code> 和 <code>[Q]</code> 都是公开的，验证者和承诺者都知晓。</p><h3 id="为什么不能让承诺者知道-Q-的离散对数"><a href="#为什么不能让承诺者知道-Q-的离散对数" class="headerlink" title="为什么不能让承诺者知道 [Q] 的离散对数"></a>为什么不能让承诺者知道 <code>[Q]</code> 的离散对数</h3><p>假设承诺者知道 <code>[Q]</code> 背后的离散对数 <code>[Q] = d[G]</code> 。这会让承诺者可以找出两个拥有相同诺言的契机。原理如下。</p><pre><code>[C] = v[G] + s[Q]    = 10[G] + 15[Q]    = 10[G] + 15[dG]    [C′] = 11[G] + (15d−1)[G] [C] = [C′]</code></pre><p>读者可以手动为 <code>d</code> 代入任意数字，看看它是怎么工作的。</p><p><strong>承诺者不能知道他们所用的椭圆曲线点的离散对数关系。</strong></p><p>保证这一点的一个办法是，让验证者来为承诺者提供这个椭圆曲线点。不过，更简单的办法是，以随机且透明的办法选出一个椭圆曲线点，例如，伪随机地选出椭圆曲线点。给定一个随机的椭圆曲线点，我们就不知道其离散对数。</p><p>举个例子，我们可以从生成元（<code>[G]</code>）开始，哈希其 x 坐标值和 y 坐标值，然后喂入一个伪随机但确定的函数，用来寻找下一个点。</p><h2 id="Pedersen-承诺有用在哪？"><a href="#Pedersen-承诺有用在哪？" class="headerlink" title="Pedersen 承诺有用在哪？"></a>Pedersen 承诺有用在哪？</h2><p>看起来 Pedersen 承诺只是使用另一种哈希函数的常规承诺方案，它有用在哪儿？</p><p>这个方案有许多好处。</p><h3 id="同态可加"><a href="#同态可加" class="headerlink" title="同态可加"></a>同态可加</h3><p>给定一个生成元 <code>[G]</code>，我们可以将两个承诺加在一起：<code>a[G] + b[G] = (a + b)[G]</code> 。即使我们再加入随机盲化隐私，我们依然可以制作出有效的契机：</p><p>$$C_1 &#x3D; a[G] + s_1[Q]$$</p><p>$$C_2 &#x3D; b[G] + s_2[Q] $$</p><p>$$C_3 &#x3D; C_1 + C_2 $$</p><p>$$承诺揭晓  (a, b, s_1 + s_2) $$</p><p>$$验证者检查 C_3 ?&#x3D; a[G] + b[G] + (s_1 + s_2)[Q]$$</p><p>常规的密码学哈希函数（比如 SHA256）是做不到这样的。</p><p>（在 Pedersen 承诺中）<code>b[G]</code> 和 <code>s[Q]</code> 在相加时不会彼此 “冲突”。</p><p>你看下面这个等式成立吗？</p><pre><code>(a[G]+b[H]) + (c[G]+d[H]) = (a+c)[G] + (c+d)[H]</code></pre><p>（这里的 <code>[G]</code> 和 <code>[H]</code> 都是未知离散对数的两个椭圆曲线点）。</p><p>你可以把椭圆曲线点理解成正交维度（orthogonal dimensions）上的一种线性组合（linear combination）的基（basis）。</p><p>当存在有限域元素 $a_1, a_2, b_1, b_2$，以及椭圆曲线点 <code>[G]</code> 和 <code>[H]</code>，且 <code>[G]</code> 不等于 <code>[H]</code> 、$a_1 \ne a_2$、$b_1 \ne b_2$，即使 $a_1[G] + b_1[H] &#x3D; a_2[G] + b_2[H]$，依然不可能绕过离散对数难题而解出 $(a_1, a_2, b_1, b_2)$ 。</p><p>而且，当我们的椭圆曲线群的阶数足够大的时候，靠运气找出这样的匹配，更是渺茫。</p><p>换句话说，假设两个人计算各自的承诺 <code>[C] = a[G] + b[H]</code> 和 <code>[C&#39;] = a&#39;[G] + b&#39;[H]</code>，且 $a \ne a’$ 且 $b \ne b’$。只要 <code>[G]</code> 和 <code>[H]</code> 的离散对数未知，<code>[C]</code> 就不太可能等于 <code>[C&#39;]</code> 。</p><p><strong>Pedersen 承诺是 zk 友好的</strong></p><p>为椭圆曲线上的加法和乘法制作电路相对容易，因为唯一要求是常规的算术运算；但常规的哈希函数却要用到比特位移（bitshifting）和异或运算（XOR），需要栋梁的约束才能编码成零知识证明的电路。</p><p><strong>我们可以将任意多的点编码成一个点</strong></p><p>我们使用 <code>[G]</code> 和 <code>[Q]</code> 的例子也可以认为是一个不设盲化因子的 2 维的向量承诺。但我们也可以加入任意多的椭圆曲线点 $[G_1, G_2,…, G_n]$，承诺任意多个标量。</p><h3 id="Pedersen-向量承诺"><a href="#Pedersen-向量承诺" class="headerlink" title="Pedersen 向量承诺"></a>Pedersen 向量承诺</h3><p>我们把上述方案再推进一步，从而承诺一组数值，而不是一个数值和一个盲化因子。</p><p><strong>向量承诺方案</strong></p><p>假设我们有一组随机的椭圆曲线点（$[G_1, G_2,…, G_n]$）（它们的离散对数我们全都不知道，那么我们可以这样做：</p><p>$$[C] &#x3D; v_1[G_1] + v_2[G_2] + … + v_n[G_n] + r[Q]$$</p><p>这让我们可以用一个诺言 <code>[C]</code> 承诺许多个数值，并用 <code>r</code> 来藏匿。</p><p>因为承诺者并不知道任何一个生成元背后的离散对数，所以他们将无法知道 <code>[C]</code> 的离散对数。因此，这个方案有绑定效果：他们只能用 $[v_1, v_2,…, v_n]$ 来产生诺言 <code>[C]</code>，无法用另一组向量做到。</p><p><strong>向量承诺可以聚合</strong></p><p>我么可以把两个 Pedersen 向量承诺相加，得到一个对两个向量的诺言。承诺者依然可以用原本的向量来揭晓。这里有一个重要的实现细节，就是原本的两个向量承诺必须使用两组不同的椭圆曲线点来生成。</p><p>$$[C_1] &#x3D; v_1[G_1] + v_2[G_2] + … + v_n[G_n] + r[Q] $$</p><p>$$[C_2] &#x3D; w_1[H_1] + w_2[H_2] + … + w_n[H_n] + s[Q] $$</p><p>$$[C_3] &#x3D; [C_1] + [C_2] $$</p><p>这里，<code>r[Q]</code> 和 <code>s[Q]</code> 是盲化因子。即时承诺者没有承诺向量，整个诺言看起来依然像是一个随机的点。</p><p>承诺者后面可以揭晓原本的向量 $[v_1, v_2,…, v_n]$ 和 $[w_1, w_2,…, w_n]$，以及盲化因子 <code>r + s</code>。这也是有绑定效果的，无法用另一组向量和盲化因子产生相同的诺言。</p><p>我们给一组向量使用 $[G_1, G_2,…, G_n]$、给另一组使用 $[H_1, H_2,…, H_n]$ 不暗示着这些 <code>[G_i]</code> 生成元和 <code>[H_i]</code> 生成元内部有什么特殊关系。所有这些点都需要伪随机地选出来。它们仅仅只是记号上的重合，便于我们直接说 “这些椭圆曲线点向量与这组有限域元素向量搭配，那些椭圆曲线点向量与那些有限域元素向量搭配”。</p><p>我们可以承诺的向量的数量是没有内在上限的。</p><p><strong>考考读者</strong>：如果我们给两个承诺使用相同的生成元 $[G_1, G_2,…, G_n]$，然后再相加，承诺者如何为 $[C_3]$ 揭晓两组不同的向量？举个例子，使用另一组椭圆曲线点 $[H_1, H_2,…, H_n]$ 是不是可以避免这一点？</p><p><strong>考考读者</strong>：如果承诺者在揭晓时调换被承诺的值的位置，会发生什么事？</p><p>举个例子，他承诺的是：</p><p>$$[C_1] &#x3D; v_1[G_1] + v_2[G_2] + … + v_n[G_n] + r[Q]$$</p><p>然而公开的契机是：</p><p>$$[v_2, v_1, v_3, v4,…，v_n]$$</p><p>也就是说，承诺者调换了前面两个元素的位置，但其它东西一切不变。假设向量 $[G_1, G_2,…, G_n]$ 是不可调换的。</p><h2 id="透明地生成随机点"><a href="#透明地生成随机点" class="headerlink" title="透明地生成随机点"></a>透明地生成随机点</h2><p>我们如何能生成这些随机的椭圆曲线点？一种显然的解决方案是使用一个受信任的启动设置，但这并不是必要的。承诺者可以通过透明地随机选出一些我们不知道其离散对数的点。</p><p>他们可以先选择生成元 <code>[G]</code>，混合一个公开选出的随机数，然后哈希这个结果（需要对  field_modulus 取模），从而获得另一个数值。如果这个结果作为 x 值能够落在椭圆曲线上，那么就使用它作为下一个生成元，再次哈希它的 (x, y) 坐标值。相反，如果它作为 x 值，在椭圆曲线上没有对应点，那我们就递增 x 值，直到它有对应的椭圆曲线点。因为并不是由承诺者来生成这些点的，他们也不可能知道这些点的离散对数。这种算法的实现细节交给读者当作练习。</p><p>在任何情况下，都不应该通过乘法来生成一个点，因为这将导致我们知道其离散对数。你需要通过一个哈希函数来伪随机地得出一个 x 值，然后看看它是否落在椭圆曲线上。</p><p>从生成元 <code>[G]</code> 开始也是可以的（众所周知，其离散对数是 1），然后生成其它点。</p><p><strong>留给读者的练习</strong>：假设我们用点 <code>[G1]</code> 和 <code>[G2]</code> 承诺了一个 2 维向量。<code>[G1]</code> 的离散对数已知，但 <code>[G2]</code> 的离散对数未知。（我们暂时忽略盲化因子）。承诺者能够使用另一个 2 维向量来揭晓这个承诺吗？为什么呢？</p><p>（完）</p>]]></content>
    
    
    <summary type="html">让我们可以使用一个椭圆曲线点来表示任意大的向量</summary>
    
    
    
    
    <category term="密码学" scheme="https://www.btcstudy.org/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>来自曲线树的匿名用途 token</title>
    <link href="https://www.btcstudy.org/2024/05/30/anonymous-usage-tokens-from-curve-trees-or-autct/"/>
    <id>https://www.btcstudy.org/2024/05/30/anonymous-usage-tokens-from-curve-trees-or-autct/</id>
    <published>2024-05-30T07:45:54.000Z</published>
    <updated>2024-09-02T04:30:25.009Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：AdamISZ</em></p><p><em>来源：<a href="https://delvingbitcoin.org/t/anonymous-usage-tokens-from-curve-trees-or-autct/862">https://delvingbitcoin.org/t/anonymous-usage-tokens-from-curve-trees-or-autct/862</a></em></p><p><em>译者注：如正文所述，本文所描述的技术是在证明自己拥有一个 UTXO 的同时不暴露这个 UTXO 是什么。可以用在闪电网络中广播通道的容量。如能使用，可以大大改善闪电节点的隐私性。</em></p></blockquote><p>不知从什么时候开始（我认为是我们在 Joinmarket 中引入忠诚保单（fidelity bond）的时候），我一直在研究实现保护隐私的公钥所有权证明的最佳方式。</p><p>我也认为，闪电网络也在许多环节面临相同的问题，可能是在解决堵塞的时候，但（有人向我指出）更明显的是在通道的 gossip 中。</p><p>我认为，可能有一种优雅的方案，部分地解决了 “在 gossip 通道的时候，我们如何能既不揭晓这些通道背后的 UTXO，又让人们免于虚假通道的（严重）女巫攻击” 的问题。</p><p>让我的初步想法（见我在 RIDDLE 上的早期工作** ）难以真正付诸实践的因素是，所有基于环签名（ring signature）的方案都无法实现次线性（sublinear）的验证。粗略地说，它总是要求验证者 “通读” 一个跟环的大小相同的对象。所以，即使一个大小为 1000 的匿名集很好，证据的体积也很紧凑，但匿名集上升到 100 万的量级就完全不可行了。</p><p>但 “曲线树（<a href="https://eprint.iacr.org/2022/756.pdf">Curve Trees</a>）” 方法就解决了这个问题：你可以把它理解成一种默克尔树，只不过是代数形式的（使用的是点，而非哈希值），这就允许你创建零知识证据（ZKP）（在这里，算术电路使用 bulletproof），描述你放在这棵树上的对象（公钥）。那么，你就可以说，“这个公钥是这组 taproot 输出中的 10 万个公钥的其中之一，但你不会知道是哪一个；然后，我提供的这个 ‘公钥镜像’（可以理解成 token）已经绑定到了这个没揭晓的公钥中，所以我没法把它用在别的地方了”。我后面会介绍这个 “绑定” 是怎么实现的。</p><p>它在比特币中的显然应用是 —— 制作 N 个 taproot UTXO 公钥中的其中一个的所有权证明，并且 N 可以是任意大的数字。给定有一些 taproot 输出是粉尘，我们可以假设它是 “没有用的”，你可以设定一个下限值作为过滤器，过滤出有意义的 UTXO。几个月前，我得到的统计数字是这样的：</p><pre><code>面额（以聪为单位）   对应 UTXO 的数量（仅限 taproot 输出）&gt; 5 million         51674&gt; 2.5 million       81512&gt; 1 million         154130&gt; 500k              238060&gt; 250k              352235&gt; 100k              800843&gt; 50k               1043038&gt; 25k               1333547&gt; 10k               2853756&gt; 1000 sat          6084116&gt; 100 (i.e. ~all)   39034007</code></pre><p>所以，比如说，以 50 万聪为门槛，则只有 24 万个公钥，对曲线树来说依然是实用的。</p><p>回顾：“绑定”：曲线树证明是一种 “集合成员” 证明，并不保证稀缺性，因为从本质上说，它可以重复使用而不会暴露自己在复用。因此，我加入了一个 DLEQ（离散对数等式证明），类似于 Joinmarket 中的 PODLE（它就像环签名中的 “可链接性”），这就创建了一个额外的曲线点，可以证明你要证明其成员属性的公钥的 “公钥镜像”，而无需公开这个公钥。<a href="https://github.com/AdamISZ/aut-ct/blob/7e673b572a300fd43f0ba4b1839fe682be676d93/aut-ct.pdf">这里</a>有算法的简介；它用的是完全标准的 sigma 协议技术。</p><p>实际上，我做了大量测试，公钥集合的规模从 5 万到 250 万，然后我观察到，验证时间大部分介于 40 到 70 ms（毫秒）之间，虽然这不是合理控制下的科学结果；我的意思是，它还是很快的！从曲线树论文的表一可以看到他们为 secp&#x2F;secq 循环做的基准测试结果，甚至比这还要好得多。主要的点在于，树结构带来了对数扩展的效果，而 bulletproof 可以批量验证（每条曲线有一个单独的证据），所以扩展效果非常好（很难写出公式来描述它，因为有算术电路；基本上，100 万个公钥在现实中是很容易验证的）。</p><p>工作代码在我的 github 库 <a href="https://github.com/AdamISZ/aut-ct">aut-ct</a> 中。它也被用作曲线树论文作者的<a href="https://github.com/simonkamp/curve-trees/">基准测试代码</a>的基础。</p><p>运行测试应该蛮容易的，我觉得，跟着 README 做就好。有一些玩具一样的小规模和中等规模公钥集合，你可以尽情玩耍。不要细究我的 Rust 代码 : )</p><p>我甚至尽可能快地做了一个概念验证网站，是一个论坛，你需要使用一个 taproot 公钥所有权证据来登录：<a href="https://hodlboard.org/">hodlboard 11</a> 。注意，实情是，创建一个证明是非常复杂的，因为你必须能够触及你所拥有的一个 taproot UTXO 的一个私钥，也就是说，至少，还没有任何钱包支持这样的操作（只有 Bitcoin Core，你可以用多条命令来做到！）。不过，这种烦恼跟这个协议的应用场景（比如闪电网络）无关。只有在我们希望用户可以创建这样的证据、并且可以互操作时，才有这样的烦恼。</p><p>按照我的理解，很明显，这种办法不是 “一种完整的解决方案”：一个闪电节点想要（还是应该说 “不得不” 呢）广播其通道容量，但这个办法并不能做到这一点（除非以最基础的办法）：你可以在你的一系列 UTXO 中选择一个，也就是说，你可以广播 “一定范围内的数额”。</p><p>再来一些技术细节：</p><ul><li>证据的体积：会有变化，但不多。公钥集合的大小在 $10^4$ 到 $10^6$ 之间时，证据的大小在 3 ~ 4 kB 范围内。树结构本身的差异似乎不怎么影响证据的体积（基准测试的叶子数量从 256 到 1024，深度到 2 到 6）；记住，最终我们总是得到 2 个 bulletproot，因为一条曲线（不论 secp 还是 secq）上的多个证据可以聚合。</li><li>曲线点在添加到树上作为叶子之前，必须预处理。这是非常重度的计算。处理的目的是为了让从 x 坐标到曲线点的转换是清楚无误的（众所周知的 “y 坐标平局” 问题），但需要使用在算术电路里有效的算法。因为只需要为每个新公钥做一次处理，所以这个时间开销在任何场景中都可以改善，除了从头开始完全免信任地启动、制作一个证据的情形。详细讨论见<a href="https://github.com/AdamISZ/aut-ct/issues/10">此处</a>。</li><li>为了更大的加速效果，可以批处理验证（我认为证明也是如此，但我还不知道怎么做到）；bulletproof 算术电路 ZKP 已经有了，属性是一样的。</li><li>曲线树基于 bulletproot ZPK，这意味着我们不需要曲线配对（pairing），也不需要 ECDL（椭圆曲线上离散对数难题）以外的假设（并不是说人么一定会拒绝需要其它假设的提议，而是说，以 secp256k1 曲线作为我们的基础，我们真的不想处理配对 *** ）</li></ul><p>你可能（也应该）好奇的是，还有别的技术，能够像曲线树一样，为比特币的这个应用场景提供几乎常数级的快速验证吗？最强大的技术，例如，Groth16 及其后继者，都需要曲线配对；见下面的注释。另一种想法是微软提出的 SPARTAN，已经应用在<a href="https://github.com/personaelabs/spartan-ecdsa">这里</a>，也不要求曲线配对和 ECDL 之外的假设。我简单研究了 SPARTAN，但我 <em>不认为</em> 它强大到能够实现很快的验证。我还没有研究这个领域的 STARK（可扩展的透明知识陈述），可能也是一个方向。</p><p>这个想法可以延伸到哪里去？按我的理解，我们也许能将这个曲线树构造跟证书结合起来，比如用在 Wabisabi 中的 KVAC（公钥验证的匿名证书）。如果我们可以做到让一个人能够 <em>独立</em> 地构造一个综合证书 “这是价值 1.7 BTC 的公钥” 并且（a）不能复用价值；（2）无需中心协调服务端；那么 …… 我们是不是就快要满足 “良好的” 闪电网络 gossip 的需要了呢？我并不是很确定我在这一段里讲的东西。</p><p>** 虽然我一定程度上摒弃了早期 RIDDLE 的想法，但这是唯一一种我放弃了的数学构造，因为它太慢了 —— 那里关于产生自 (U)TXO 所有权的 token 的想法，我依然认为是有趣的。<a href="https://reyify.com/blog/riddle">关于 RIDDLE 的博客</a></p><p>*** 值得展开的是，在一个 <em>封闭</em> 的对等节点系统中，显然你可以让每个人都签名任意一种你喜欢的额外类型的公钥，也包括用在基于曲线配对系统中的公钥。但这会显著降低匿名集形成的 “自发性”，例如，你将无法包括跟闪电节点的运行无关的 taproot UTXO，等等。好处是你可以得到 <em>非常</em> 紧凑的证据，等等。我倾向于认为，3 kB 已经够紧凑了，因为从设计上来说，这样的证据不会有几百万个！</p>]]></content>
    
    
    <summary type="html">一种可以零知识证明的集合成员证据</summary>
    
    
    
    
    <category term="密码学" scheme="https://www.btcstudy.org/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    <category term="闪电网络隐私性" scheme="https://www.btcstudy.org/tags/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C%E9%9A%90%E7%A7%81%E6%80%A7/"/>
    
  </entry>
  
</feed>
